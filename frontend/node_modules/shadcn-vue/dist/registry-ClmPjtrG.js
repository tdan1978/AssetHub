import { _ as registrySchema, a as registryBaseColorSchema, b as stylesSchema, c as registryIndexSchema, f as registryItemFileSchema, g as registryResolvedItemsTreeSchema, i as registriesIndexSchema, n as iconsSchema, p as registryItemSchema, r as rawConfigSchema, s as registryConfigSchema, t as configSchema, x as workspaceConfigSchema, y as searchResultsSchema } from "./schema-Brc22MYG.js";
import path, { basename } from "pathe";
import prompts from "prompts";
import { z } from "zod";
import { existsSync, promises, statSync } from "fs";
import deepmerge from "deepmerge";
import fsExtra from "fs-extra";
import { createPathsMatcher, getTsconfig } from "get-tsconfig";
import { coerce } from "semver";
import { glob } from "tinyglobby";
import { loadConfig } from "c12";
import { colors } from "consola/utils";
import consola from "consola";
import ora from "ora";
import { homedir, tmpdir } from "os";
import { Project, QuoteKind, ScriptKind, SyntaxKind } from "ts-morph";
import { transform } from "vue-metamorph";
import { transform as transform$1 } from "@unovue/detypes";
import { ofetch } from "ofetch";
import { ProxyAgent } from "undici";
import { createHash } from "crypto";
import objectToString from "stringify-object";
import fuzzysort from "fuzzysort";

//#region src/utils/frameworks.ts
const FRAMEWORKS = {
	vite: {
		name: "vite",
		label: "Vite",
		links: {
			installation: "https://shadcn-vue.com/docs/installation/vite",
			tailwind: "https://tailwindcss.com/docs/guides/vite"
		}
	},
	nuxt3: {
		name: "nuxt3",
		label: "Nuxt 3",
		links: {
			installation: "https://shadcn-vue.com/docs/installation/nuxt",
			tailwind: "https://tailwindcss.com/docs/guides/nuxtjs"
		}
	},
	nuxt4: {
		name: "nuxt4",
		label: "Nuxt 4",
		links: {
			installation: "https://shadcn-vue.com/docs/installation/nuxt",
			tailwind: "https://tailwindcss.com/docs/guides/nuxtjs"
		}
	},
	astro: {
		name: "astro",
		label: "Astro",
		links: {
			installation: "https://shadcn-vue.com/docs/installation/astro",
			tailwind: "https://tailwindcss.com/docs/guides/astro"
		}
	},
	laravel: {
		name: "laravel",
		label: "Laravel",
		links: {
			installation: "https://shadcn-vue.com/docs/installation/laravel",
			tailwind: "https://tailwindcss.com/docs/guides/laravel"
		}
	},
	manual: {
		name: "manual",
		label: "Manual",
		links: {
			installation: "https://shadcn-vue.com/docs/installation/manual",
			tailwind: "https://tailwindcss.com/docs/installation"
		}
	},
	inertia: {
		name: "inertia",
		label: "Inertia",
		links: {
			installation: "https://shadcn-vue.com/docs/installation/manual",
			tailwind: "https://tailwindcss.com/docs/installation"
		}
	}
};

//#endregion
//#region src/registry/constants.ts
const REGISTRY_URL = process.env.REGISTRY_URL ?? "https://shadcn-vue.com/r";
const FALLBACK_STYLE = "new-york-v4";
const BASE_COLORS = [
	{
		name: "neutral",
		label: "Neutral"
	},
	{
		name: "gray",
		label: "Gray"
	},
	{
		name: "zinc",
		label: "Zinc"
	},
	{
		name: "stone",
		label: "Stone"
	},
	{
		name: "slate",
		label: "Slate"
	}
];
const BUILTIN_REGISTRIES = { "@shadcn": `${REGISTRY_URL}/styles/{style}/{name}.json` };
const DEPRECATED_COMPONENTS = [{
	name: "toast",
	deprecatedBy: "sonner",
	message: "The toast component is deprecated. Use the sonner component instead."
}, {
	name: "toaster",
	deprecatedBy: "sonner",
	message: "The toaster component is deprecated. Use the sonner component instead."
}];

//#endregion
//#region src/utils/highlighter.ts
const highlighter = {
	error: colors.red,
	warn: colors.yellow,
	info: colors.cyan,
	success: colors.green
};

//#endregion
//#region src/registry/errors.ts
const RegistryErrorCode = {
	NETWORK_ERROR: "NETWORK_ERROR",
	NOT_FOUND: "NOT_FOUND",
	UNAUTHORIZED: "UNAUTHORIZED",
	FORBIDDEN: "FORBIDDEN",
	FETCH_ERROR: "FETCH_ERROR",
	NOT_CONFIGURED: "NOT_CONFIGURED",
	INVALID_CONFIG: "INVALID_CONFIG",
	MISSING_ENV_VARS: "MISSING_ENV_VARS",
	LOCAL_FILE_ERROR: "LOCAL_FILE_ERROR",
	PARSE_ERROR: "PARSE_ERROR",
	VALIDATION_ERROR: "VALIDATION_ERROR",
	UNKNOWN_ERROR: "UNKNOWN_ERROR"
};
var RegistryError = class extends Error {
	constructor(message, options = {}) {
		super(message);
		this.name = "RegistryError";
		this.code = options.code || RegistryErrorCode.UNKNOWN_ERROR;
		this.statusCode = options.statusCode;
		this.cause = options.cause;
		this.context = options.context;
		this.suggestion = options.suggestion;
		this.timestamp = /* @__PURE__ */ new Date();
		if (Error.captureStackTrace) Error.captureStackTrace(this, this.constructor);
	}
	toJSON() {
		return {
			name: this.name,
			message: this.message,
			code: this.code,
			statusCode: this.statusCode,
			context: this.context,
			suggestion: this.suggestion,
			timestamp: this.timestamp,
			stack: this.stack
		};
	}
};
var RegistryNotFoundError = class extends RegistryError {
	constructor(url, cause) {
		const message = `The item at ${url} was not found. It may not exist at the registry.`;
		super(message, {
			code: RegistryErrorCode.NOT_FOUND,
			statusCode: 404,
			cause,
			context: { url },
			suggestion: "Check if the item name is correct and the registry URL is accessible."
		});
		this.url = url;
		this.name = "RegistryNotFoundError";
	}
};
var RegistryUnauthorizedError = class extends RegistryError {
	constructor(url, cause) {
		const message = `You are not authorized to access the item at ${url}. If this is a remote registry, you may need to authenticate.`;
		super(message, {
			code: RegistryErrorCode.UNAUTHORIZED,
			statusCode: 401,
			cause,
			context: { url },
			suggestion: "Check your authentication credentials and environment variables."
		});
		this.url = url;
		this.name = "RegistryUnauthorizedError";
	}
};
var RegistryForbiddenError = class extends RegistryError {
	constructor(url, cause) {
		const message = `You are not authorized to access the item at ${url}. If this is a remote registry, you may need to authenticate.`;
		super(message, {
			code: RegistryErrorCode.FORBIDDEN,
			statusCode: 403,
			cause,
			context: { url },
			suggestion: "Check your authentication credentials and environment variables."
		});
		this.url = url;
		this.name = "RegistryForbiddenError";
	}
};
var RegistryFetchError = class extends RegistryError {
	constructor(url, statusCode, responseBody, cause) {
		const baseMessage = statusCode ? `Failed to fetch from registry (${statusCode}): ${url}` : `Failed to fetch from registry: ${url}`;
		const message = typeof cause === "string" && cause ? `${baseMessage} - ${cause}` : baseMessage;
		let suggestion = "Check your network connection and try again.";
		if (statusCode === 404) suggestion = "The requested resource was not found. Check the URL or item name.";
		else if (statusCode === 500) suggestion = "The registry server encountered an error. Try again later.";
		else if (statusCode && statusCode >= 400 && statusCode < 500) suggestion = "There was a client error. Check your request parameters.";
		super(message, {
			code: RegistryErrorCode.FETCH_ERROR,
			statusCode,
			cause,
			context: {
				url,
				responseBody
			},
			suggestion
		});
		this.url = url;
		this.responseBody = responseBody;
		this.name = "RegistryFetchError";
	}
};
var RegistryNotConfiguredError = class extends RegistryError {
	constructor(registryName) {
		const message = registryName ? `Unknown registry "${registryName}". Make sure it is defined in components.json as follows:
{
  "registries": {
    "${registryName}": "[URL_TO_REGISTRY]"
  }
}` : "Unknown registry. Make sure it is defined in components.json under \"registries\".";
		super(message, {
			code: RegistryErrorCode.NOT_CONFIGURED,
			context: { registryName },
			suggestion: "Add the registry configuration to your components.json file. Consult the registry documentation for the correct format."
		});
		this.registryName = registryName;
		this.name = "RegistryNotConfiguredError";
	}
};
var RegistryLocalFileError = class extends RegistryError {
	constructor(filePath, cause) {
		super(`Failed to read local registry file: ${filePath}`, {
			code: RegistryErrorCode.LOCAL_FILE_ERROR,
			cause,
			context: { filePath },
			suggestion: "Check if the file exists and you have read permissions."
		});
		this.filePath = filePath;
		this.name = "RegistryLocalFileError";
	}
};
var RegistryParseError = class extends RegistryError {
	constructor(item, parseError) {
		let message = `Failed to parse registry item: ${item}`;
		if (parseError instanceof z.ZodError) message = `Failed to parse registry item: ${item}\n${parseError.errors.map((e) => `  - ${e.path.join(".")}: ${e.message}`).join("\n")}`;
		super(message, {
			code: RegistryErrorCode.PARSE_ERROR,
			cause: parseError,
			context: { item },
			suggestion: "The registry item may be corrupted or have an invalid format. Please make sure it returns a valid JSON object. See https://shadcn-vue.com/schema/registry-item.json."
		});
		this.item = item;
		this.parseError = parseError;
		this.name = "RegistryParseError";
	}
};
var RegistryMissingEnvironmentVariablesError = class extends RegistryError {
	constructor(registryName, missingVars) {
		const message = `Registry "${registryName}" requires the following environment variables:\n\n${missingVars.map((v) => `  â€¢ ${v}`).join("\n")}`;
		super(message, {
			code: RegistryErrorCode.MISSING_ENV_VARS,
			context: {
				registryName,
				missingVars
			},
			suggestion: "Set the required environment variables to your .env or .env.local file."
		});
		this.registryName = registryName;
		this.missingVars = missingVars;
		this.name = "RegistryMissingEnvironmentVariablesError";
	}
};
var RegistryInvalidNamespaceError = class extends RegistryError {
	constructor(name) {
		const message = `Invalid registry namespace: "${name}". Registry names must start with @ (e.g., @shadcn, @v0).`;
		super(message, {
			code: RegistryErrorCode.VALIDATION_ERROR,
			context: { name },
			suggestion: "Use a valid registry name starting with @ or provide a direct URL to the registry."
		});
		this.name = name;
		this.name = "RegistryInvalidNamespaceError";
	}
};
var ConfigParseError = class extends RegistryError {
	constructor(cwd, parseError) {
		let message = `Invalid components.json configuration in ${cwd}.`;
		if (parseError instanceof Error && parseError.message.includes("built-in registry and cannot be overridden")) message = `Invalid components.json configuration in ${highlighter.info(`${cwd}/components.json`)}:\n  - ${parseError.message}`;
		if (parseError instanceof SyntaxError) message = `Invalid components.json configuration in ${highlighter.info(`${cwd}/components.json`)}:\n  - Syntax error: ${parseError.message.replace(`${cwd}/components.json`, "")}`;
		if (parseError instanceof z.ZodError) message = `Invalid components.json configuration in ${highlighter.info(`${cwd}/components.json`)}:\n${parseError.errors.map((e) => `  - ${e.path.join(".")}: ${e.message}`).join("\n")}`;
		super(message, {
			code: RegistryErrorCode.INVALID_CONFIG,
			cause: parseError,
			context: { cwd },
			suggestion: "Check your components.json file for syntax errors or invalid configuration. Run 'npx shadcn@latest init' to regenerate a valid configuration."
		});
		this.cwd = cwd;
		this.name = "ConfigParseError";
	}
};
var RegistriesIndexParseError = class extends RegistryError {
	constructor(parseError) {
		let message = "Failed to parse registries index";
		if (parseError instanceof z.ZodError) {
			const invalidNamespaces = parseError.errors.filter((e) => e.path.length > 0).map((e) => `"${e.path[0]}"`).filter((v, i, arr) => arr.indexOf(v) === i);
			if (invalidNamespaces.length > 0) message = `Failed to parse registries index. Invalid registry namespace(s): ${invalidNamespaces.join(", ")}\n${parseError.errors.map((e) => `  - ${e.path.join(".")}: ${e.message}`).join("\n")}`;
			else message = `Failed to parse registries index:\n${parseError.errors.map((e) => `  - ${e.path.join(".")}: ${e.message}`).join("\n")}`;
		}
		super(message, {
			code: RegistryErrorCode.PARSE_ERROR,
			cause: parseError,
			context: { parseError },
			suggestion: "The registries index may be corrupted or have invalid registry namespace format. Registry names must start with @ (e.g., @shadcn, @example)."
		});
		this.parseError = parseError;
		this.name = "RegistriesIndexParseError";
	}
};

//#endregion
//#region src/utils/resolve-import.ts
function resolveImport(importPath, config) {
	const matcher = createPathsMatcher(config);
	if (matcher === null) return;
	return matcher(importPath)[0];
}

//#endregion
//#region src/utils/get-config.ts
const DEFAULT_COMPONENTS = "@/components";
const DEFAULT_UTILS = "@/lib/utils";
const DEFAULT_TAILWIND_CSS = "assets/css/tailwind.css";
const DEFAULT_TAILWIND_CONFIG = "tailwind.config.js";
async function getConfig(cwd) {
	const config = await getRawConfig(cwd);
	if (!config) return null;
	if (!config.iconLibrary) config.iconLibrary = config.style === "new-york" ? "radix" : "lucide";
	return await resolveConfigPaths(cwd, config);
}
async function resolveConfigPaths(cwd, config) {
	config.registries = {
		...BUILTIN_REGISTRIES,
		...config.registries || {}
	};
	const detectedFramework = await detectFrameworkConfigFiles(cwd);
	const isTypeScript = await isTypeScriptProject(cwd);
	const tsConfig = await getTsconfig(path.resolve(cwd, detectedFramework?.name === "nuxt4" ? "./.nuxt/tsconfig.app.json" : detectedFramework?.name === "nuxt3" ? "./.nuxt/tsconfig.json" : detectedFramework?.name === "inertia" ? "./inertia/tsconfig.json" : isTypeScript ? "./tsconfig.json" : "./jsconfig.json"), isTypeScript ? void 0 : "jsconfig.json");
	if (tsConfig === null) throw new Error(`Failed to load ${config.typescript ? "tsconfig" : "jsconfig"}.json.`.trim());
	return configSchema.parse({
		...config,
		resolvedPaths: {
			cwd,
			tailwindConfig: config.tailwind.config ? path.resolve(cwd, config.tailwind.config) : "",
			tailwindCss: path.resolve(cwd, config.tailwind.css),
			utils: await resolveImport(config.aliases.utils, tsConfig),
			components: await resolveImport(config.aliases.components, tsConfig),
			ui: config.aliases.ui ? await resolveImport(config.aliases.ui, tsConfig) : path.resolve(await resolveImport(config.aliases.components, tsConfig) ?? cwd, "ui"),
			lib: config.aliases.lib ? await resolveImport(config.aliases.lib, tsConfig) : path.resolve(await resolveImport(config.aliases.utils, tsConfig) ?? cwd, ".."),
			composables: config.aliases.composables ? await resolveImport(config.aliases.composables, tsConfig) : path.resolve(await resolveImport(config.aliases.components, tsConfig) ?? cwd, "..", "composables")
		}
	});
}
async function getRawConfig(cwd) {
	try {
		const configResult = await loadConfig({
			name: "components",
			configFile: "components",
			cwd,
			dotenv: false,
			packageJson: false,
			rcFile: false,
			jitiOptions: {
				rebuildFsCache: true,
				moduleCache: true
			}
		});
		if (!configResult.config || Object.keys(configResult.config).length === 0) return null;
		const config = rawConfigSchema.parse(configResult.config);
		if (config.registries) {
			for (const registryName of Object.keys(config.registries)) if (registryName in BUILTIN_REGISTRIES) throw new Error(`"${registryName}" is a built-in registry and cannot be overridden.`);
		}
		return config;
	} catch (error) {
		throw new ConfigParseError(cwd, error);
	}
}
async function getWorkspaceConfig(config) {
	let resolvedAliases = {};
	for (const key of Object.keys(config.aliases)) {
		if (!isAliasKey(key, config)) continue;
		const resolvedPath = config.resolvedPaths[key];
		const packageRoot = await findPackageRoot(config.resolvedPaths.cwd, resolvedPath);
		if (!packageRoot) {
			resolvedAliases[key] = config;
			continue;
		}
		resolvedAliases[key] = await getConfig(packageRoot);
	}
	const result = workspaceConfigSchema.safeParse(resolvedAliases);
	if (!result.success) return null;
	return result.data;
}
async function findPackageRoot(cwd, resolvedPath) {
	const commonRoot = findCommonRoot$1(cwd, resolvedPath);
	const relativePath = path.relative(commonRoot, resolvedPath);
	const matchingPackageRoot = (await glob("**/package.json", {
		cwd: commonRoot,
		deep: 3,
		ignore: [
			"**/node_modules/**",
			"**/dist/**",
			"**/build/**",
			"**/public/**"
		]
	})).map((pkgPath) => path.dirname(pkgPath)).find((pkgDir) => relativePath.startsWith(pkgDir));
	return matchingPackageRoot ? path.join(commonRoot, matchingPackageRoot) : null;
}
function isAliasKey(key, config) {
	return Object.keys(config.resolvedPaths).filter((key$1) => key$1 !== "utils").includes(key);
}
function findCommonRoot$1(cwd, resolvedPath) {
	const parts1 = cwd.split(path.sep);
	const parts2 = resolvedPath.split(path.sep);
	const commonParts = [];
	for (let i = 0; i < Math.min(parts1.length, parts2.length); i++) {
		if (parts1[i] !== parts2[i]) break;
		commonParts.push(parts1[i]);
	}
	return commonParts.join(path.sep);
}
async function getTargetStyleFromConfig(cwd, fallback) {
	return (await getProjectInfo(cwd))?.tailwindVersion === "v4" ? "new-york-v4" : fallback;
}
/**
* Creates a config object with sensible defaults.
* Useful for universal registry items that bypass framework detection.
*
* @param partial - Partial config values to override defaults
* @returns A complete Config object
*/
function createConfig(partial) {
	const defaultConfig = {
		typescript: true,
		resolvedPaths: {
			cwd: process.cwd(),
			tailwindConfig: "",
			tailwindCss: "",
			utils: "",
			components: "",
			ui: "",
			lib: "",
			composables: ""
		},
		style: "",
		tailwind: {
			config: "",
			css: "",
			baseColor: "",
			cssVariables: false
		},
		aliases: {
			components: "",
			utils: ""
		},
		registries: { ...BUILTIN_REGISTRIES }
	};
	if (partial) return {
		...defaultConfig,
		...partial,
		resolvedPaths: {
			...defaultConfig.resolvedPaths,
			...partial.resolvedPaths || {}
		},
		tailwind: {
			...defaultConfig.tailwind,
			...partial.tailwind || {}
		},
		aliases: {
			...defaultConfig.aliases,
			...partial.aliases || {}
		},
		registries: {
			...defaultConfig.registries,
			...partial.registries || {}
		}
	};
	return defaultConfig;
}

//#endregion
//#region src/utils/get-package-info.ts
function getPackageInfo(cwd = "", shouldThrow = true) {
	const packageJsonPath = path.join(cwd, "package.json");
	return fsExtra.readJSONSync(packageJsonPath, { throws: shouldThrow });
}

//#endregion
//#region src/utils/get-project-info.ts
const PROJECT_SHARED_IGNORE = [
	"**/node_modules/**",
	".nuxt",
	"public",
	"dist",
	"build"
];
const TS_CONFIG_SCHEMA = z.object({ compilerOptions: z.object({ paths: z.record(z.string().or(z.array(z.string()))) }) });
async function detectFrameworkConfigFiles(cwd) {
	const packageInfo = await getPackageInfo(cwd, false);
	const configFiles = await glob("**/{nuxt,vite,astro,wxt}.config.*|composer.json", {
		cwd,
		deep: 3,
		ignore: PROJECT_SHARED_IGNORE
	});
	if (configFiles.find((file) => file.startsWith("nuxt.config."))) {
		const nuxtPkg = packageInfo?.dependencies?.nuxt || packageInfo?.devDependencies?.nuxt;
		const nuxtVersion = nuxtPkg && coerce(nuxtPkg)?.version || "4.0.0";
		if (nuxtVersion.startsWith("4")) return FRAMEWORKS.nuxt4;
		else if (nuxtVersion.startsWith("3")) return FRAMEWORKS.nuxt3;
		return null;
	}
	if (configFiles.find((file) => file.startsWith("astro.config."))) return FRAMEWORKS.astro;
	if (configFiles.find((file) => file.startsWith("composer.json"))) return FRAMEWORKS.laravel;
	if (packageInfo?.dependencies?.["@inertiajs/vue3"] || packageInfo?.devDependencies?.["@inertiajs/vue3"] || await fsExtra.pathExists(path.join(cwd, "resources/js"))) return FRAMEWORKS.inertia;
	if (configFiles.find((file) => file.startsWith("wxt.config."))) return FRAMEWORKS.vite;
	if (configFiles.find((file) => file.startsWith("vite.config."))) return FRAMEWORKS.vite;
	return null;
}
async function isTypeScriptProject(cwd) {
	return (await glob("tsconfig.*", {
		cwd,
		deep: 1,
		ignore: PROJECT_SHARED_IGNORE
	})).length > 0;
}
async function getProjectInfo(cwd) {
	const [detectedFramework, typescript, isSrcDir, tailwindConfigFile, tailwindCssFile, tailwindVersion, aliasPrefix, packageJson] = await Promise.all([
		detectFrameworkConfigFiles(cwd),
		isTypeScriptProject(cwd),
		fsExtra.pathExists(path.resolve(cwd, "src")),
		getTailwindConfigFile(cwd),
		getTailwindCssFile(cwd),
		getTailwindVersion(cwd),
		getTsConfigAliasPrefix(cwd),
		getPackageInfo(cwd, false)
	]);
	return {
		framework: detectedFramework || FRAMEWORKS.manual,
		typescript,
		isSrcDir,
		tailwindConfigFile,
		tailwindCssFile,
		tailwindVersion,
		aliasPrefix
	};
}
async function getTailwindVersion(cwd) {
	const [packageInfo, config] = await Promise.all([getPackageInfo(cwd, false), getConfig(cwd)]);
	if (config?.tailwind?.config === "") return "v4";
	const hasNuxtTailwind = !!(packageInfo?.dependencies?.["@nuxtjs/tailwindcss"] || packageInfo?.devDependencies?.["@nuxtjs/tailwindcss"]);
	if (!!!(packageInfo?.dependencies?.tailwindcss || packageInfo?.devDependencies?.tailwindcss) && !hasNuxtTailwind) return null;
	if (/^(?:\^|~)?3(?:\.\d+)*(?:-.*)?$/.test(packageInfo?.dependencies?.tailwindcss || packageInfo?.devDependencies?.tailwindcss || "")) return "v3";
	return "v4";
}
async function getTailwindCssFile(cwd) {
	const [files, tailwindVersion] = await Promise.all([glob(["**/*.css", "**/*.scss"], {
		cwd,
		deep: 5,
		ignore: PROJECT_SHARED_IGNORE
	}), getTailwindVersion(cwd)]);
	if (!files.length) return null;
	for (const file of files) {
		const contents = await fsExtra.readFile(path.resolve(cwd, file), "utf8");
		if (contents.includes(`@import "tailwindcss"`) || contents.includes(`@import 'tailwindcss'`) || contents.includes(`@tailwind base`)) return file;
	}
	return null;
}
async function getTailwindConfigFile(cwd) {
	const files = await glob("tailwind.config.*", {
		cwd,
		deep: 3,
		ignore: PROJECT_SHARED_IGNORE
	});
	if (!files.length) return null;
	return files[0];
}
async function getTsConfigAliasPrefix(cwd) {
	const detectedFramework = await detectFrameworkConfigFiles(cwd);
	const isTypeScript = await isTypeScriptProject(cwd);
	const tsConfig = await getTsconfig(cwd, detectedFramework?.name === "nuxt4" ? "./.nuxt/tsconfig.app.json" : detectedFramework?.name === "nuxt3" ? "./.nuxt/tsconfig.json" : detectedFramework?.name === "inertia" ? "./inertia/tsconfig.json" : isTypeScript ? "./tsconfig.json" : "./jsconfig.json");
	if (tsConfig === null || !Object.entries(tsConfig.config.compilerOptions?.paths ?? {}).length) return null;
	const aliasPaths = tsConfig.config.compilerOptions?.paths ?? {};
	for (const [alias, paths] of Object.entries(aliasPaths)) if (paths.includes("./*") || paths.includes("./src/*") || paths.includes("./app/*") || paths.includes("./resources/js/*")) {
		const cleanAlias = alias.replace(/\/\*$/, "") ?? null;
		return cleanAlias === "#build" ? "@" : cleanAlias;
	}
	return Object.keys(aliasPaths)?.[0]?.replace(/\/\*$/, "") ?? null;
}
async function getProjectConfig(cwd, defaultProjectInfo = null) {
	const [existingConfig, projectInfo] = await Promise.all([getConfig(cwd), !defaultProjectInfo ? getProjectInfo(cwd) : Promise.resolve(defaultProjectInfo)]);
	if (existingConfig) return existingConfig;
	if (!projectInfo || !projectInfo.tailwindCssFile || projectInfo.tailwindVersion === "v3" && !projectInfo.tailwindConfigFile) return null;
	return await resolveConfigPaths(cwd, {
		$schema: "https://shadcn-vue.com/schema.json",
		typescript: projectInfo.typescript,
		style: "new-york",
		tailwind: {
			config: projectInfo.tailwindConfigFile ?? "",
			baseColor: "zinc",
			css: projectInfo.tailwindCssFile,
			cssVariables: true,
			prefix: ""
		},
		iconLibrary: "lucide",
		aliases: {
			components: `${projectInfo.aliasPrefix}/components`,
			ui: `${projectInfo.aliasPrefix}/components/ui`,
			composables: `${projectInfo.aliasPrefix}/composables`,
			lib: `${projectInfo.aliasPrefix}/lib`,
			utils: `${projectInfo.aliasPrefix}/lib/utils`
		}
	});
}
async function getProjectTailwindVersionFromConfig(config) {
	if (!config.resolvedPaths?.cwd) return "v3";
	const projectInfo = await getProjectInfo(config.resolvedPaths.cwd);
	if (!projectInfo?.tailwindVersion) return null;
	return projectInfo.tailwindVersion;
}

//#endregion
//#region src/utils/logger.ts
const logger = {
	error(...args) {
		consola.log(highlighter.error(args.join(" ")));
	},
	warn(...args) {
		consola.log(highlighter.warn(args.join(" ")));
	},
	info(...args) {
		consola.log(highlighter.info(args.join(" ")));
	},
	success(...args) {
		consola.log(highlighter.success(args.join(" ")));
	},
	log(...args) {
		consola.log(args.join(" "));
	},
	break() {
		consola.log("");
	}
};

//#endregion
//#region src/utils/spinner.ts
function spinner(text, options) {
	return ora({
		text,
		isSilent: options?.silent
	});
}

//#endregion
//#region src/registry/env.ts
function expandEnvVars(value) {
	return value.replace(/\$\{(\w+)\}/g, (_match, key) => process.env[key] || "");
}
function extractEnvVars(value) {
	const vars = [];
	const regex = /\$\{(\w+)\}/g;
	let match;
	while ((match = regex.exec(value)) !== null) vars.push(match[1]);
	return vars;
}

//#endregion
//#region src/registry/parser.ts
const REGISTRY_PATTERN = /^(@[a-z0-9](?:[\w-]*[a-z0-9])?)\/(.+)$/i;
function parseRegistryAndItemFromString(name) {
	if (!name.startsWith("@")) return {
		registry: null,
		item: name
	};
	const match = name.match(REGISTRY_PATTERN);
	if (match) return {
		registry: match[1],
		item: match[2]
	};
	return {
		registry: null,
		item: name
	};
}

//#endregion
//#region src/utils/compare.ts
function isContentSame(existingContent, newContent, options = {}) {
	const { ignoreImports = false } = options;
	const normalizedExisting = existingContent.replace(/\r\n/g, "\n").trim();
	const normalizedNew = newContent.replace(/\r\n/g, "\n").trim();
	if (normalizedExisting === normalizedNew) return true;
	if (!ignoreImports) return false;
	const importRegex = /^(import\s+(?:type\s+)?(?:\*\s+as\s+\w+|\{[^}]*\}|\w+)?(?:\s*,\s*(?:\{[^}]*\}|\w+))?\s+from\s+["'])([^"']+)(["'])/gm;
	const normalizeImports = (content) => {
		return content.replace(importRegex, (_match, prefix, importPath, suffix) => {
			if (importPath.startsWith(".")) return `${prefix}${importPath}${suffix}`;
			const parts = importPath.split("/");
			return `${prefix}@normalized/${parts[parts.length - 1]}${suffix}`;
		});
	};
	return normalizeImports(normalizedExisting) === normalizeImports(normalizedNew);
}

//#endregion
//#region src/utils/env-helpers.ts
function isEnvFile(filePath) {
	const fileName = path.basename(filePath);
	return /^\.env(?:\.|$)/.test(fileName);
}
/**
* Finds a file variant in the project.
* TODO: abstract this to a more generic function.
*/
function findExistingEnvFile(targetDir) {
	for (const variant of [
		".env.local",
		".env",
		".env.development.local",
		".env.development"
	]) {
		const filePath = path.join(targetDir, variant);
		if (existsSync(filePath)) return filePath;
	}
	return null;
}
/**
* Parse .env content into key-value pairs.
*/
function parseEnvContent(content) {
	const lines = content.split("\n");
	const env = {};
	for (const line of lines) {
		const trimmed = line.trim();
		if (!trimmed || trimmed.startsWith("#")) continue;
		const equalIndex = trimmed.indexOf("=");
		if (equalIndex === -1) continue;
		const key = trimmed.substring(0, equalIndex).trim();
		const value = trimmed.substring(equalIndex + 1).trim();
		if (key) env[key] = value.replace(/^["']|["']$/g, "");
	}
	return env;
}
/**
* Get the list of new keys that would be added when merging env content.
*/
function getNewEnvKeys(existingContent, newContent) {
	const existingEnv = parseEnvContent(existingContent);
	const newEnv = parseEnvContent(newContent);
	const newKeys = [];
	for (const key of Object.keys(newEnv)) if (!(key in existingEnv)) newKeys.push(key);
	return newKeys;
}
/**
* Merge env content by appending ONLY new keys that don't exist in the existing content.
* Existing keys are preserved with their original values.
*/
function mergeEnvContent(existingContent, newContent) {
	const existingEnv = parseEnvContent(existingContent);
	const newEnv = parseEnvContent(newContent);
	let result = existingContent.trimEnd();
	if (result && !result.endsWith("\n")) result += "\n";
	const newKeys = [];
	for (const [key, value] of Object.entries(newEnv)) if (!(key in existingEnv)) newKeys.push(`${key}=${value}`);
	if (newKeys.length > 0) {
		if (result) result += "\n";
		result += newKeys.join("\n");
		return `${result}\n`;
	}
	if (result && !result.endsWith("\n")) return `${result}\n`;
	return result;
}

//#endregion
//#region src/utils/transformers/transform-css-vars.ts
function transformCssVars(opts) {
	return {
		type: "codemod",
		name: "add prefix to tailwind classes",
		transform({ scriptASTs, sfcAST, utils: { traverseScriptAST, traverseTemplateAST } }) {
			let transformCount = 0;
			const { baseColor, config } = opts;
			if (config.tailwind?.cssVariables || !baseColor?.inlineColors) return transformCount;
			for (const scriptAST of scriptASTs) traverseScriptAST(scriptAST, { visitLiteral(path$1) {
				if (path$1.parent.value.type !== "ImportDeclaration" && typeof path$1.node.value === "string") {
					const raw = path$1.node.value;
					const mapped = applyColorMapping(raw, baseColor.inlineColors).trim();
					if (mapped !== raw) {
						path$1.node.value = mapped;
						transformCount++;
					}
				}
				return this.traverse(path$1);
			} });
			if (sfcAST) traverseTemplateAST(sfcAST, {
				enterNode(node) {
					if (node.type === "Literal" && typeof node.value === "string") {
						if (!["BinaryExpression", "Property"].includes(node.parent?.type ?? "")) {
							const raw = node.value;
							const mapped = applyColorMapping(raw, baseColor.inlineColors).trim();
							if (mapped !== raw) {
								node.value = mapped;
								transformCount++;
							}
						}
					} else if (node.type === "VLiteral" && typeof node.value === "string") {
						if (node.parent.key.name === "class") {
							const raw = node.value;
							const mapped = applyColorMapping(raw, baseColor.inlineColors).trim();
							if (mapped !== raw) {
								node.value = mapped;
								transformCount++;
							}
						}
					}
				},
				leaveNode() {}
			});
			return transformCount;
		}
	};
}
function splitClassName(className) {
	if (!className.includes("/") && !className.includes(":")) return [
		null,
		className,
		null
	];
	const parts = [];
	const [rest, alpha] = className.split("/");
	if (!rest.includes(":")) return [
		null,
		rest,
		alpha
	];
	const split = rest.split(":");
	const name = split.pop();
	const variant = split.join(":");
	parts.push(variant ?? null, name ?? null, alpha ?? null);
	return parts;
}
const PREFIXES = [
	"bg-",
	"text-",
	"border-",
	"ring-offset-",
	"ring-"
];
function applyColorMapping(input, mapping) {
	if (input.includes(" border ")) input = input.replace(" border ", " border border-border ");
	const classNames = input.split(" ");
	const lightMode = /* @__PURE__ */ new Set();
	const darkMode = /* @__PURE__ */ new Set();
	for (const className of classNames) {
		const [variant, value, modifier] = splitClassName(className);
		const prefix = PREFIXES.find((prefix$1) => value?.startsWith(prefix$1));
		if (!prefix) {
			if (!lightMode.has(className)) lightMode.add(className);
			continue;
		}
		const needle = value?.replace(prefix, "");
		if (needle && needle in mapping.light) {
			lightMode.add([variant, `${prefix}${mapping.light[needle]}`].filter(Boolean).join(":") + (modifier ? `/${modifier}` : ""));
			darkMode.add([
				"dark",
				variant,
				`${prefix}${mapping.dark[needle]}`
			].filter(Boolean).join(":") + (modifier ? `/${modifier}` : ""));
			continue;
		}
		if (!lightMode.has(className)) lightMode.add(className);
	}
	return [...Array.from(lightMode), ...Array.from(darkMode)].join(" ").trim();
}

//#endregion
//#region src/utils/transformers/transform-import.ts
function transformImport(opts) {
	return {
		type: "codemod",
		name: "modify import based on user config",
		transform({ scriptASTs, utils: { traverseScriptAST } }) {
			let transformCount = 0;
			const { config, isRemote } = opts;
			const utilsAlias = config.aliases?.utils;
			const utilsImport = `${typeof utilsAlias === "string" && utilsAlias.includes("/") ? utilsAlias.split("/")[0] : "@"}/lib/utils`;
			for (const scriptAST of scriptASTs) traverseScriptAST(scriptAST, { visitLiteral(path$1) {
				if (typeof path$1.node.value === "string") {
					const parent = path$1.parent.value;
					if (parent.type === "ImportDeclaration" || parent.type === "CallExpression" && parent.callee?.name === "import") {
						const sourcePath = path$1.node.value;
						const updatedImport = updateImportAliases(sourcePath, config, isRemote);
						if (updatedImport !== sourcePath) {
							path$1.node.value = updatedImport;
							transformCount++;
						}
						if (utilsImport === updatedImport || updatedImport === "@/lib/utils") {
							if (parent.type === "ImportDeclaration") {
								if ((parent.specifiers?.map((node) => node.local?.name ?? "") ?? []).find((i) => i === "cn") && config.aliases.utils) {
									path$1.node.value = utilsImport === updatedImport ? updatedImport.replace(utilsImport, config.aliases.utils) : config.aliases.utils;
									transformCount++;
								}
							} else if (parent.type === "CallExpression") {
								const grandParent = path$1.parent.parent?.value;
								if (grandParent?.type === "VariableDeclarator" && grandParent.id?.type === "ObjectPattern") {
									if (grandParent.id.properties?.some((prop) => prop.key?.name === "cn") && config.aliases.utils) {
										path$1.node.value = utilsImport === updatedImport ? updatedImport.replace(utilsImport, config.aliases.utils) : config.aliases.utils;
										transformCount++;
									}
								}
							}
						}
					}
				}
				return this.traverse(path$1);
			} });
			return transformCount;
		}
	};
}
function updateImportAliases(moduleSpecifier, config, isRemote = false) {
	if (!moduleSpecifier.startsWith("@/") && !isRemote) return moduleSpecifier;
	if (isRemote && moduleSpecifier.startsWith("@/")) moduleSpecifier = moduleSpecifier.replace(/^@\//, `@/registry/new-york/`);
	if (!moduleSpecifier.startsWith("@/registry/")) {
		const alias = config.aliases.components.split("/")[0];
		return moduleSpecifier.replace(/^@\//, `${alias}/`);
	}
	if (moduleSpecifier.match(/^@\/registry\/(.+)\/ui/)) return moduleSpecifier.replace(/^@\/registry\/(.+)\/ui/, config.aliases.ui ?? `${config.aliases.components}/ui`);
	if (config.aliases.components && moduleSpecifier.match(/^@\/registry\/(.+)\/components/)) return moduleSpecifier.replace(/^@\/registry\/(.+)\/components/, config.aliases.components);
	if (config.aliases.lib && moduleSpecifier.match(/^@\/registry\/(.+)\/lib/)) return moduleSpecifier.replace(/^@\/registry\/(.+)\/lib/, config.aliases.lib);
	if (config.aliases.composables && moduleSpecifier.match(/^@\/registry\/(.+)\/composables/)) return moduleSpecifier.replace(/^@\/registry\/(.+)\/composables/, config.aliases.composables);
	return moduleSpecifier.replace(/^@\/registry\/[^/]+/, config.aliases.components);
}

//#endregion
//#region src/utils/transformers/transform-sfc.ts
async function transformSFC(opts) {
	if (opts.config?.typescript) return opts.raw;
	return await transformByDetype(opts.raw, opts.filename).then((res) => res);
}
async function transformByDetype(content, filename) {
	return await transform$1(content, filename, {
		removeTsComments: true,
		prettierOptions: { proseWrap: "never" }
	});
}

//#endregion
//#region src/utils/transformers/transform-tw-prefix.ts
async function transformTwPrefix(opts) {
	const tailwindVersion = await getProjectTailwindVersionFromConfig(opts.config);
	return {
		type: "codemod",
		name: "add prefix to tailwind classes",
		transform({ scriptASTs, sfcAST, utils: { traverseScriptAST, traverseTemplateAST, astHelpers } }) {
			let transformCount = 0;
			const { config } = opts;
			if (!config.tailwind?.prefix) return transformCount;
			const addPrefix = (input) => {
				const result = applyPrefix(input, config.tailwind.prefix, tailwindVersion);
				transformCount++;
				return result;
			};
			function isVariantProperty(node) {
				if (node.type === "Property") {
					if (node.key?.type === "Identifier") {
						const keyName = node.key.name;
						return [
							"variant",
							"size",
							"color",
							"type",
							"state"
						].includes(keyName);
					}
					if (node.key?.type === "Literal" && typeof node.key.value === "string") {
						const keyName = node.key.value;
						return [
							"variant",
							"size",
							"color",
							"type",
							"state"
						].includes(keyName);
					}
				}
				return false;
			}
			function traverseExpression(expression) {
				if (expression.type === "CallExpression" && expression.callee?.type === "Identifier" && expression.callee.name === "cn") expression.arguments.forEach((arg) => {
					if (arg.type === "Literal" && typeof arg.value === "string") arg.value = addPrefix(arg.value);
					else if (arg.type === "ConditionalExpression") {
						if (arg.consequent?.type === "Literal" && typeof arg.consequent.value === "string") arg.consequent.value = addPrefix(arg.consequent.value);
						if (arg.alternate?.type === "Literal" && typeof arg.alternate.value === "string") arg.alternate.value = addPrefix(arg.alternate.value);
					} else if (arg.type === "BinaryExpression") {
						if (arg.right?.type === "Literal" && typeof arg.right.value === "string") arg.right.value = addPrefix(arg.right.value);
					} else if (arg.type === "ObjectExpression") arg.properties.forEach((prop) => {
						if (prop.type === "Property" && prop.value?.type === "Literal" && typeof prop.value.value === "string") {
							if (!isVariantProperty(prop)) prop.value.value = addPrefix(prop.value.value);
						}
					});
					else astHelpers.findAll(arg, { type: "Literal" }).forEach((literal) => {
						if (typeof literal.value === "string") {
							let shouldTransform = true;
							let parent = literal.parent;
							while (parent) {
								if (isVariantProperty(parent)) {
									shouldTransform = false;
									break;
								}
								parent = parent.parent;
							}
							if (shouldTransform) literal.value = addPrefix(literal.value);
						}
					});
				});
				else if (expression.type === "ConditionalExpression") {
					if (expression.consequent) traverseExpression(expression.consequent);
					if (expression.alternate) traverseExpression(expression.alternate);
				} else if (expression.type === "BinaryExpression") {
					if (expression.left) traverseExpression(expression.left);
					if (expression.right) traverseExpression(expression.right);
				}
			}
			for (const scriptAST of scriptASTs) traverseScriptAST(scriptAST, { visitCallExpression(path$1) {
				if (path$1.node.callee.type === "Identifier" && path$1.node.callee.name === "cva") {
					const args = path$1.node.arguments;
					if (args[0]?.type === "Literal" && typeof args[0].value === "string") args[0].value = addPrefix(args[0].value);
					if (args[1]?.type === "ObjectExpression") {
						const variantsProperty = args[1].properties.find((prop) => prop.type === "Property" && prop.key.type === "Identifier" && prop.key.name === "variants");
						if (variantsProperty && variantsProperty.type === "Property" && variantsProperty.value.type === "ObjectExpression") astHelpers.findAll(variantsProperty.value, { type: "Property" }).forEach((prop) => {
							if (prop.value?.type === "Literal" && typeof prop.value.value === "string") prop.value.value = addPrefix(prop.value.value);
							else if (prop.value?.type === "ArrayExpression") prop.value.elements.forEach((element) => {
								if (element?.type === "Literal" && typeof element.value === "string") element.value = addPrefix(element.value);
							});
						});
					}
				}
				if (path$1.node.callee.type === "Identifier" && path$1.node.callee.name === "cn") path$1.node.arguments.forEach((arg) => {
					if (arg.type === "Literal" && typeof arg.value === "string") arg.value = addPrefix(arg.value);
					else if (arg.type === "ConditionalExpression") {
						if (arg.consequent?.type === "Literal" && typeof arg.consequent.value === "string") arg.consequent.value = addPrefix(arg.consequent.value);
						if (arg.alternate?.type === "Literal" && typeof arg.alternate.value === "string") arg.alternate.value = addPrefix(arg.alternate.value);
					} else if (arg.type === "BinaryExpression") {
						if (arg.right?.type === "Literal" && typeof arg.right.value === "string") arg.right.value = addPrefix(arg.right.value);
					} else if (arg.type === "ObjectExpression") arg.properties.forEach((prop) => {
						if (prop.type === "Property" && prop.value?.type === "Literal" && typeof prop.value.value === "string") {
							if (!isVariantProperty(prop)) prop.value.value = addPrefix(prop.value.value);
						}
					});
					else astHelpers.findAll(arg, { type: "Literal" }).forEach((literal) => {
						if (typeof literal.value === "string") {
							let shouldTransform = true;
							let parent = literal.parent;
							while (parent) {
								if (isVariantProperty(parent)) {
									shouldTransform = false;
									break;
								}
								parent = parent.parent;
							}
							if (shouldTransform) literal.value = addPrefix(literal.value);
						}
					});
				});
				return this.traverse(path$1);
			} });
			if (sfcAST) traverseTemplateAST(sfcAST, {
				enterNode(node) {
					if (node.type === "VAttribute" && node.key.type === "VDirectiveKey") {
						if (node.key.argument?.type === "VIdentifier") {
							const argName = node.key.argument.name;
							if ([
								"class",
								"className",
								"classes",
								"classNames"
							].includes(argName)) {
								if (node.value?.type === "VExpressionContainer" && node.value.expression) traverseExpression(node.value.expression);
							}
						}
					} else if (node.type === "VLiteral" && typeof node.value === "string") {
						if (node.parent?.type === "VAttribute" && node.parent.key?.type === "VIdentifier" && [
							"class",
							"className",
							"classes",
							"classNames"
						].includes(node.parent.key.name)) node.value = `"${addPrefix(node.value.replace(/"/g, ""))}"`;
					}
				},
				leaveNode() {}
			});
			return transformCount;
		}
	};
}
function applyPrefix(input, prefix = "", tailwindVersion) {
	if (tailwindVersion === "v3") return input.split(" ").map((className) => {
		const [variant, value, modifier] = splitClassName(className);
		if (variant) return modifier ? `${variant}:${prefix}${value}/${modifier}` : `${variant}:${prefix}${value}`;
		else return modifier ? `${prefix}${value}/${modifier}` : `${prefix}${value}`;
	}).join(" ");
	return input.split(" ").map((className) => className.indexOf(`${prefix}:`) === 0 ? className : `${prefix}:${className.trim()}`).join(" ");
}

//#endregion
//#region src/utils/icon-libraries.ts
const ICON_LIBRARIES = {
	lucide: {
		name: "lucide-vue-next",
		package: "lucide-vue-next",
		import: "lucide-vue-next"
	},
	radix: {
		name: "@radix-icons/vue",
		package: "@radix-icons/vue",
		import: "@radix-icons/vue"
	},
	tabler: {
		name: "@tabler/icons-vue",
		package: "@tabler/icons-vue",
		import: "@tabler/icons-vue"
	},
	phosphor: {
		name: "@phosphor-icons/vue",
		package: "@phosphor-icons/vue",
		import: "@phosphor-icons/vue"
	}
};

//#endregion
//#region src/utils/transformers/transform-icons.ts
const SOURCE_LIBRARY = "lucide";
const ICON_LIBRARY_IMPORTS = new Set(Object.values(ICON_LIBRARIES).map((l) => l.import).filter(Boolean));
function transformIcons(opts, registryIcons) {
	return {
		type: "codemod",
		name: "modify import of icon library on user config",
		transform({ scriptASTs, sfcAST, utils: { traverseScriptAST, traverseTemplateAST } }) {
			let transformCount = 0;
			const { config } = opts;
			if (!config.iconLibrary || !(config.iconLibrary in ICON_LIBRARIES)) return transformCount;
			const sourceLibrary = SOURCE_LIBRARY;
			const targetLibrary = config.iconLibrary;
			if (sourceLibrary === targetLibrary) return transformCount;
			const targetedIconsMap = /* @__PURE__ */ new Map();
			for (const scriptAST of scriptASTs) traverseScriptAST(scriptAST, { visitImportDeclaration(path$1) {
				const source = String(path$1.node.source.value);
				if (![...ICON_LIBRARY_IMPORTS].some((prefix) => source.startsWith(prefix))) return this.traverse(path$1);
				let hasChanges = false;
				for (const specifier of path$1.node.specifiers ?? []) if (specifier.type === "ImportSpecifier") {
					const iconName = specifier.imported.name;
					const targetedIcon = registryIcons[iconName]?.[targetLibrary];
					if (!targetedIcon || targetedIconsMap.has(iconName)) continue;
					targetedIconsMap.set(iconName, targetedIcon);
					specifier.imported.name = targetedIcon;
					hasChanges = true;
				}
				if (hasChanges) {
					path$1.node.source.value = ICON_LIBRARIES[targetLibrary].import;
					transformCount++;
				}
				return this.traverse(path$1);
			} });
			if (sfcAST && targetedIconsMap.size > 0) traverseTemplateAST(sfcAST, { enterNode(node) {
				if (node.type === "VElement" && targetedIconsMap.has(node.rawName)) {
					node.rawName = targetedIconsMap.get(node.rawName) ?? "";
					transformCount++;
				}
			} });
			return transformCount;
		}
	};
}

//#endregion
//#region src/utils/transformers/index.ts
async function transform$2(opts) {
	const source = await transformSFC(opts);
	const registryIcons = await getRegistryIcons();
	return transform(source, opts.filename, [
		transformImport(opts),
		transformCssVars(opts),
		await transformTwPrefix(opts),
		transformIcons(opts, registryIcons)
	]).code;
}

//#endregion
//#region src/utils/updaters/update-files.ts
async function updateFiles(files, config, options) {
	if (!files?.length) return {
		filesCreated: [],
		filesUpdated: [],
		filesSkipped: []
	};
	options = {
		overwrite: false,
		force: false,
		silent: false,
		isRemote: false,
		isWorkspace: false,
		...options
	};
	const filesCreatedSpinner = spinner(`Updating files.`, { silent: options.silent })?.start();
	const [projectInfo, baseColor] = await Promise.all([getProjectInfo(config.resolvedPaths.cwd), config.tailwind.baseColor ? getRegistryBaseColor(config.tailwind.baseColor) : Promise.resolve(void 0)]);
	let filesCreated = [];
	let filesUpdated = [];
	let filesSkipped = [];
	let envVarsAdded = [];
	let envFile = null;
	for (let index = 0; index < files.length; index++) {
		const file = files[index];
		if (!file.content) continue;
		let filePath = resolveFilePath(file, config, {
			framework: projectInfo?.framework.name,
			commonRoot: findCommonRoot(files.map((f) => f.path), file.path),
			path: options.path,
			fileIndex: index
		});
		if (!filePath) continue;
		basename(file.path);
		const targetDir = path.dirname(filePath);
		if (!config.typescript) filePath = filePath.replace(/\.ts?$/, (match) => ".js");
		if (isEnvFile(filePath) && !existsSync(filePath)) {
			const alternativeEnvFile = findExistingEnvFile(targetDir);
			if (alternativeEnvFile) filePath = alternativeEnvFile;
		}
		const existingFile = existsSync(filePath);
		if (existingFile && statSync(filePath).isDirectory()) throw new Error(`Cannot write to ${filePath}: path exists and is a directory. Please provide a file path instead.`);
		const content = isEnvFile(filePath) ? file.content : await transform$2({
			filename: file.path,
			raw: file.content,
			config,
			baseColor,
			isRemote: options.isRemote
		});
		if (existingFile && !isEnvFile(filePath)) {
			if (isContentSame(await promises.readFile(filePath, "utf-8"), content, { ignoreImports: options.isWorkspace })) {
				filesSkipped.push(path.relative(config.resolvedPaths.cwd, filePath));
				continue;
			}
		}
		if (existingFile && !options.overwrite && !isEnvFile(filePath)) {
			filesCreatedSpinner.stop();
			if (options.rootSpinner) options.rootSpinner.stop();
			const { overwrite } = await prompts({
				type: "confirm",
				name: "overwrite",
				message: `The file ${highlighter.info(path.relative(config.resolvedPaths.ui, filePath))} already exists. Would you like to overwrite?`,
				initial: false
			});
			if (!overwrite) {
				filesSkipped.push(path.relative(config.resolvedPaths.cwd, filePath));
				if (options.rootSpinner) options.rootSpinner.start();
				continue;
			}
			filesCreatedSpinner?.start();
			if (options.rootSpinner) options.rootSpinner.start();
		}
		if (!existsSync(targetDir)) await promises.mkdir(targetDir, { recursive: true });
		if (isEnvFile(filePath) && existingFile) {
			const existingFileContent = await promises.readFile(filePath, "utf-8");
			const mergedContent = mergeEnvContent(existingFileContent, content);
			envVarsAdded = getNewEnvKeys(existingFileContent, content);
			envFile = path.relative(config.resolvedPaths.cwd, filePath);
			if (!envVarsAdded.length) {
				filesSkipped.push(path.relative(config.resolvedPaths.cwd, filePath));
				continue;
			}
			await promises.writeFile(filePath, mergedContent, "utf-8");
			filesUpdated.push(path.relative(config.resolvedPaths.cwd, filePath));
			continue;
		}
		await promises.writeFile(filePath, content, "utf-8");
		if (!existingFile) {
			filesCreated.push(path.relative(config.resolvedPaths.cwd, filePath));
			if (isEnvFile(filePath)) {
				envVarsAdded = Object.keys(parseEnvContent(content));
				envFile = path.relative(config.resolvedPaths.cwd, filePath);
			}
		} else filesUpdated.push(path.relative(config.resolvedPaths.cwd, filePath));
	}
	const updatedFiles = await resolveImports([
		...filesCreated,
		...filesUpdated,
		...filesSkipped
	], config);
	filesUpdated.push(...updatedFiles);
	filesUpdated = filesUpdated.filter((file) => !filesCreated.includes(file));
	if (!(filesCreated.length || filesUpdated.length) && !filesSkipped.length) filesCreatedSpinner?.info("No files updated.");
	filesCreated = Array.from(new Set(filesCreated));
	filesUpdated = Array.from(new Set(filesUpdated));
	filesSkipped = Array.from(new Set(filesSkipped));
	if (filesCreated.length) {
		filesCreatedSpinner?.succeed(`Created ${filesCreated.length} ${filesCreated.length === 1 ? "file" : "files"}:`);
		if (!options.silent) for (const file of filesCreated) logger.log(`  - ${file}`);
	} else filesCreatedSpinner?.stop();
	if (filesUpdated.length) {
		spinner(`Updated ${filesUpdated.length} ${filesUpdated.length === 1 ? "file" : "files"}:`, { silent: options.silent })?.info();
		if (!options.silent) for (const file of filesUpdated) logger.log(`  - ${file}`);
	}
	if (filesSkipped.length) {
		spinner(`Skipped ${filesSkipped.length} ${filesUpdated.length === 1 ? "file" : "files"}: (files might be identical, use --overwrite to overwrite)`, { silent: options.silent })?.info();
		if (!options.silent) for (const file of filesSkipped) logger.log(`  - ${file}`);
	}
	if (envVarsAdded.length && envFile) {
		spinner(`Added the following variables to ${highlighter.info(envFile)}:`)?.info();
		if (!options.silent) for (const key of envVarsAdded) logger.log(`  ${highlighter.success("+")} ${key}`);
	}
	if (!options.silent) logger.break();
	return {
		filesCreated,
		filesUpdated,
		filesSkipped
	};
}
function resolveFilePath(file, config, options) {
	if (options.path) {
		const resolvedPath = path.isAbsolute(options.path) ? options.path : path.join(config.resolvedPaths.cwd, options.path);
		if (/\.[^/\\]+$/.test(resolvedPath)) {
			if (options.fileIndex === 0) return resolvedPath;
		} else {
			const fileName = path.basename(file.path);
			return path.join(resolvedPath, fileName);
		}
	}
	if (file.target) {
		if (file.target.startsWith("~/")) return path.join(config.resolvedPaths.cwd, file.target.replace("~/", ""));
		let target = file.target;
		if (file.type === "registry:page") {
			target = resolvePageTarget(target, options.framework);
			if (!target) return "";
		}
		return path.join(config.resolvedPaths.cwd, target.replace("src/", ""));
	}
	const targetDir = resolveFileTargetDirectory(file, config);
	const relativePath = resolveNestedFilePath(file.path, options.commonRoot, config);
	return path.join(targetDir, relativePath);
}
function resolveFileTargetDirectory(file, config) {
	if (file.type === "registry:ui") return config.resolvedPaths.ui;
	if (file.type === "registry:lib") return config.resolvedPaths.lib;
	if (file.type === "registry:block" || file.type === "registry:component") return config.resolvedPaths.components;
	if (file.type === "registry:hook" || file.type === "registry:composable") return config.resolvedPaths.composables;
	return config.resolvedPaths.components;
}
function findCommonRoot(paths, needle) {
	const normalizedPaths = paths.map((p) => p.replace(/^\//, ""));
	const normalizedNeedle = needle.replace(/^\//, "");
	const needleDir = normalizedNeedle.split("/").slice(0, -1).join("/");
	if (!needleDir) return "";
	const needleSegments = needleDir.split("/");
	for (let i = needleSegments.length; i > 0; i--) {
		const testPath = needleSegments.slice(0, i).join("/");
		if (normalizedPaths.some((path$1) => path$1 !== normalizedNeedle && path$1.startsWith(`${testPath}/`))) return `/${testPath}`;
	}
	return `/${needleDir}`;
}
function resolveNestedFilePath(filePath, commonRoot, config) {
	const normalizedFilePath = filePath.replace(/^\/|\/$/g, "");
	const normalizedCommonRoot = commonRoot.replace(/^\/|\/$/g, "");
	const aliases = Object.values(config.aliases).map((alias) => alias.replace(/^@\//, "").replace(/^\/|\/$/g, "")).sort((a, b) => b.length - a.length);
	for (const alias of aliases) if (normalizedCommonRoot.includes(alias)) {
		const aliasEndIndex = normalizedFilePath.indexOf(alias) + alias.length;
		return normalizedFilePath.substring(aliasEndIndex).replace(/^\//, "");
	}
	return normalizedCommonRoot.split("/").pop() + normalizedFilePath.replace(normalizedCommonRoot, "");
}
function resolvePageTarget(target, framework) {
	if (!framework) return "";
	if (framework === "nuxt3" || framework === "nuxt4") return target;
	if (framework === "laravel") {
		let result = target.replace(/^app\//, "resources/js/pages/");
		result = result.replace(/\/page(\.[jt]sx?)$/, "$1");
		return result;
	}
	return "";
}
async function resolveImports(filePaths, config) {
	const projectInfo = await getProjectInfo(config.resolvedPaths.cwd);
	const tsConfig = getTsconfig(config.resolvedPaths.cwd);
	const updatedFiles = [];
	if (!projectInfo || tsConfig === null) return [];
	for (const filepath of filePaths) {
		const resolvedPath = path.resolve(config.resolvedPaths.cwd, filepath);
		if (!existsSync(resolvedPath)) continue;
		const content = await promises.readFile(resolvedPath, "utf-8");
		try {
			const importResolverTransformer = (opts) => ({
				name: "import-resolver",
				transform(node) {
					if (node.type === "ImportDeclaration" && node.source?.value) {
						const moduleSpecifier = node.source.value;
						if (projectInfo?.aliasPrefix && !moduleSpecifier.startsWith(`${projectInfo.aliasPrefix}/`)) return;
						const probableImportFilePath = resolveImport(moduleSpecifier, tsConfig);
						if (!probableImportFilePath) return;
						const resolvedImportFilePath = resolveModuleByProbablePath(probableImportFilePath, filePaths, config);
						if (!resolvedImportFilePath) return;
						const newImport = toAliasedImport(resolvedImportFilePath, config, projectInfo);
						if (!newImport || newImport === moduleSpecifier) return;
						node.source.value = newImport;
						node.source.raw = `'${newImport}'`;
					}
				}
			});
			const result = transform(content, resolvedPath, [importResolverTransformer({})]);
			if (result.code !== content) {
				await promises.writeFile(resolvedPath, result.code, "utf-8");
				updatedFiles.push(filepath);
			}
		} catch (error) {
			console.warn(`Failed to transform imports in ${filepath}:`, error);
		}
	}
	return updatedFiles;
}
/**
* Given an absolute "probable" import path (no ext),
* plus an array of absolute file paths you already know about,
* return 0â€“N matches (best match first), and also check disk for any missing ones.
*/
function resolveModuleByProbablePath(probableImportFilePath, files, config, extensions = [
	".vue",
	".ts",
	".js",
	".tsx",
	".jsx",
	".css"
]) {
	const cwd = path.normalize(config.resolvedPaths.cwd);
	const relativeFiles = files.map((f) => f.split(path.sep).join(path.posix.sep));
	const fileSet = new Set(relativeFiles);
	const extInPath = path.extname(probableImportFilePath);
	const hasExt = extInPath !== "";
	const absBase = hasExt ? probableImportFilePath.slice(0, -extInPath.length) : probableImportFilePath;
	const relBase = path.relative(cwd, absBase).split(path.sep).join(path.posix.sep);
	const tryExts = hasExt ? [extInPath] : extensions;
	const candidates = /* @__PURE__ */ new Set();
	for (const e of tryExts) {
		const absCand = absBase + e;
		const relCand = path.posix.normalize(path.relative(cwd, absCand));
		if (fileSet.has(relCand) || existsSync(absCand)) candidates.add(relCand);
		const absIdx = path.join(absBase, `index${e}`);
		const relIdx = path.posix.normalize(path.relative(cwd, absIdx));
		if (fileSet.has(relIdx) || existsSync(absIdx)) candidates.add(relIdx);
	}
	const name = path.basename(absBase);
	for (const f of relativeFiles) if (tryExts.some((e) => f.endsWith(`/${name}${e}`))) candidates.add(f);
	if (candidates.size === 0) return null;
	return Array.from(candidates).sort((a, b) => {
		const aExt = path.posix.extname(a);
		const bExt = path.posix.extname(b);
		const ord = tryExts.indexOf(aExt) - tryExts.indexOf(bExt);
		if (ord !== 0) return ord;
		return (relBase && a.startsWith(relBase) ? -1 : 1) - (relBase && b.startsWith(relBase) ? -1 : 1);
	})[0];
}
function toAliasedImport(filePath, config, projectInfo) {
	const abs = path.normalize(path.join(config.resolvedPaths.cwd, filePath));
	const matches = Object.entries(config.resolvedPaths).filter(([, root]) => root && abs.startsWith(path.normalize(root + path.sep))).sort((a, b) => b[1].length - a[1].length);
	if (matches.length === 0) return null;
	const [aliasKey, rootDir] = matches[0];
	let rel = path.relative(rootDir, abs);
	rel = rel.split(path.sep).join("/");
	const ext = path.posix.extname(rel);
	const keepExt = [
		".vue",
		".ts",
		".tsx",
		".js",
		".jsx"
	].includes(ext) ? "" : ext;
	let noExt = rel.slice(0, rel.length - ext.length);
	if (noExt.endsWith("/index")) noExt = noExt.slice(0, -6);
	const aliasBase = aliasKey === "cwd" ? projectInfo.aliasPrefix : config.aliases[aliasKey];
	if (!aliasBase) return null;
	let suffix = noExt === "" ? "" : `/${noExt}`;
	suffix = suffix.replace("/src", "");
	return `${aliasBase}${suffix}${keepExt}`;
}

//#endregion
//#region src/registry/utils.ts
const project = new Project({ compilerOptions: {} });
function isUrl$1(path$1) {
	try {
		new URL(path$1);
		return true;
	} catch (error) {
		return false;
	}
}
function isLocalFile(path$1) {
	return path$1.endsWith(".json") && !isUrl$1(path$1);
}
/**
* Check if a registry item is universal (framework-agnostic).
* A universal registry item must:
* 1. Have type "registry:item" or "registry:file"
* 2. If it has files, all files must have explicit targets and be type "registry:file" or "registry:item"
* It can be installed without framework detection or components.json.
*/
function isUniversalRegistryItem(registryItem) {
	if (!registryItem) return false;
	if (registryItem.type !== "registry:item" && registryItem.type !== "registry:file") return false;
	return (registryItem.files ?? []).every((file) => !!file.target && (file.type === "registry:file" || file.type === "registry:item"));
}
async function deduplicateFilesByTarget(filesArrays, config) {
	if (!canDeduplicateFiles(config)) return z.array(registryItemFileSchema).parse(filesArrays.flat().filter(Boolean));
	const projectInfo = await getProjectInfo(config.resolvedPaths.cwd);
	const targetMap = /* @__PURE__ */ new Map();
	const allFiles = z.array(registryItemFileSchema).parse(filesArrays.flat().filter(Boolean));
	allFiles.forEach((file) => {
		const resolvedPath = resolveFilePath(file, config, {
			framework: projectInfo?.framework.name,
			commonRoot: findCommonRoot(allFiles.map((f) => f.path), file.path)
		});
		if (resolvedPath) targetMap.set(resolvedPath, file);
	});
	return Array.from(targetMap.values());
}
function canDeduplicateFiles(config) {
	return !!(config?.resolvedPaths?.cwd && (config?.resolvedPaths?.ui || config?.resolvedPaths?.lib || config?.resolvedPaths?.components || config?.resolvedPaths?.composables));
}

//#endregion
//#region src/registry/config.ts
function resolveStyleFromConfig(config) {
	if (!config.style) return FALLBACK_STYLE;
	if (config.style === "new-york" && config.tailwind?.config === "") return FALLBACK_STYLE;
	return config.style;
}
function configWithDefaults(config) {
	const baseConfig = createConfig({
		style: FALLBACK_STYLE,
		registries: BUILTIN_REGISTRIES
	});
	if (!config) return baseConfig;
	return configSchema.parse(deepmerge(baseConfig, {
		...config,
		style: resolveStyleFromConfig(config),
		registries: {
			...BUILTIN_REGISTRIES,
			...config.registries
		}
	}));
}

//#endregion
//#region src/registry/context.ts
const context = { headers: {} };
function setRegistryHeaders(headers) {
	context.headers = {
		...context.headers,
		...headers
	};
}
function getRegistryHeadersFromContext(url) {
	return context.headers[url] || {};
}
function clearRegistryContext() {
	context.headers = {};
}

//#endregion
//#region src/registry/validator.ts
function extractEnvVarsFromRegistryConfig(config) {
	const vars = /* @__PURE__ */ new Set();
	if (typeof config === "string") extractEnvVars(config).forEach((v) => vars.add(v));
	else {
		extractEnvVars(config.url).forEach((v) => vars.add(v));
		if (config.params) Object.values(config.params).forEach((value) => {
			extractEnvVars(value).forEach((v) => vars.add(v));
		});
		if (config.headers) Object.values(config.headers).forEach((value) => {
			extractEnvVars(value).forEach((v) => vars.add(v));
		});
	}
	return Array.from(vars);
}
function validateRegistryConfig(registryName, config) {
	const missing = extractEnvVarsFromRegistryConfig(config).filter((v) => !process.env[v]);
	if (missing.length > 0) throw new RegistryMissingEnvironmentVariablesError(registryName, missing);
}

//#endregion
//#region src/registry/builder.ts
const NAME_PLACEHOLDER = "{name}";
const STYLE_PLACEHOLDER = "{style}";
const ENV_VAR_PATTERN = /\$\{(\w+)\}/g;
const QUERY_PARAM_SEPARATOR = "?";
const QUERY_PARAM_DELIMITER = "&";
function buildUrlAndHeadersForRegistryItem(name, config) {
	const { registry, item } = parseRegistryAndItemFromString(name);
	if (!registry) return null;
	const registryConfig = (config?.registries || {})[registry];
	if (!registryConfig) throw new RegistryNotConfiguredError(registry);
	validateRegistryConfig(registry, registryConfig);
	return {
		url: buildUrlFromRegistryConfig(item, registryConfig, config),
		headers: buildHeadersFromRegistryConfig(registryConfig)
	};
}
function buildUrlFromRegistryConfig(item, registryConfig, config) {
	if (typeof registryConfig === "string") {
		let url = registryConfig.replace(NAME_PLACEHOLDER, item);
		if (config?.style && url.includes(STYLE_PLACEHOLDER)) url = url.replace(STYLE_PLACEHOLDER, config.style);
		return expandEnvVars(url);
	}
	let baseUrl = registryConfig.url.replace(NAME_PLACEHOLDER, item);
	if (config?.style && baseUrl.includes(STYLE_PLACEHOLDER)) baseUrl = baseUrl.replace(STYLE_PLACEHOLDER, config.style);
	baseUrl = expandEnvVars(baseUrl);
	if (!registryConfig.params) return baseUrl;
	return appendQueryParams(baseUrl, registryConfig.params);
}
function buildHeadersFromRegistryConfig(config) {
	if (typeof config === "string" || !config.headers) return {};
	const headers = {};
	for (const [key, value] of Object.entries(config.headers)) {
		const expandedValue = expandEnvVars(value);
		if (shouldIncludeHeader(value, expandedValue)) headers[key] = expandedValue;
	}
	return headers;
}
function appendQueryParams(baseUrl, params) {
	const urlParams = new URLSearchParams();
	for (const [key, value] of Object.entries(params)) {
		const expandedValue = expandEnvVars(value);
		if (expandedValue) urlParams.append(key, expandedValue);
	}
	const queryString = urlParams.toString();
	if (!queryString) return baseUrl;
	return `${baseUrl}${baseUrl.includes(QUERY_PARAM_SEPARATOR) ? QUERY_PARAM_DELIMITER : QUERY_PARAM_SEPARATOR}${queryString}`;
}
function shouldIncludeHeader(originalValue, expandedValue) {
	const trimmedExpanded = expandedValue.trim();
	if (!trimmedExpanded) return false;
	if (originalValue.includes("${")) {
		if (originalValue.match(ENV_VAR_PATTERN)) return trimmedExpanded !== originalValue.replace(ENV_VAR_PATTERN, "").trim();
	}
	return true;
}
/**
* Resolves a registry URL from a path or URL string.
* Handles special cases like v0 registry URLs that need /json suffix.
*
* @param pathOrUrl - Either a relative path or a full URL
* @returns The resolved registry URL
*/
function resolveRegistryUrl(pathOrUrl) {
	if (isUrl$1(pathOrUrl)) {
		const url = new URL(pathOrUrl);
		if (url.pathname.match(/\/chat\/b\//) && !url.pathname.endsWith("/json")) url.pathname = `${url.pathname}/json`;
		return url.toString();
	}
	return `${REGISTRY_URL}/${pathOrUrl}`;
}

//#endregion
//#region src/registry/fetcher.ts
const agent = process.env.https_proxy ? new ProxyAgent(process.env.https_proxy) : void 0;
const registryCache = /* @__PURE__ */ new Map();
async function fetchRegistry(paths, options = {}) {
	options = {
		useCache: true,
		...options
	};
	try {
		return await Promise.all(paths.map(async (path$1) => {
			const url = resolveRegistryUrl(path$1);
			if (options.useCache && registryCache.has(url)) return registryCache.get(url);
			const fetchPromise = (async () => {
				const headers = getRegistryHeadersFromContext(url);
				return (await ofetch.raw(url, {
					agent,
					dispatcher: agent,
					parseResponse: JSON.parse,
					headers: { ...headers }
				}).catch(async (error) => {
					if (!error.response) throw new RegistryFetchError(url, void 0, error.message);
					const response = error.response;
					let messageFromServer;
					if (response.headers.get("content-type")?.includes("application/json")) {
						const json = await response._data;
						const parsed = z.object({
							detail: z.string().optional(),
							title: z.string().optional(),
							message: z.string().optional(),
							error: z.string().optional()
						}).safeParse(json);
						if (parsed.success) {
							messageFromServer = parsed.data.detail || parsed.data.message;
							if (parsed.data.error) messageFromServer = `[${parsed.data.error}] ${messageFromServer}`;
						}
					}
					if (response.status === 401) throw new RegistryUnauthorizedError(url, messageFromServer);
					if (response.status === 404) throw new RegistryNotFoundError(url, messageFromServer);
					if (response.status === 403) throw new RegistryForbiddenError(url, messageFromServer);
					throw new RegistryFetchError(url, response.status, messageFromServer);
				}))._data;
			})();
			if (options.useCache) registryCache.set(url, fetchPromise);
			return fetchPromise;
		}));
	} catch (error) {
		throw error;
	}
}
async function fetchRegistryLocal(filePath) {
	try {
		let expandedPath = filePath;
		if (filePath.startsWith("~/")) expandedPath = path.join(homedir(), filePath.slice(2));
		const resolvedPath = path.resolve(expandedPath);
		const content = await promises.readFile(resolvedPath, "utf8");
		const parsed = JSON.parse(content);
		try {
			return registryItemSchema.parse(parsed);
		} catch (error) {
			throw new RegistryParseError(filePath, error);
		}
	} catch (error) {
		if (error instanceof Error && (error.message.includes("ENOENT") || error.message.includes("no such file"))) throw new RegistryLocalFileError(filePath, error);
		if (error instanceof RegistryParseError) throw error;
		throw new RegistryLocalFileError(filePath, error);
	}
}

//#endregion
//#region src/utils/handle-error.ts
function handleError(error) {
	logger.break();
	logger.error(`Something went wrong. Please check the error below for more details.`);
	logger.error(`If the problem persists, please open an issue on GitHub.`);
	logger.error("");
	if (typeof error === "string") {
		logger.error(error);
		logger.break();
		process.exit(1);
	}
	if (error instanceof RegistryError) {
		if (error.message) {
			logger.error(error.cause ? "Error:" : "Message:");
			logger.error(error.message);
		}
		if (error.cause) {
			logger.error("\nMessage:");
			logger.error(error.cause);
		}
		if (error.suggestion) {
			logger.error("\nSuggestion:");
			logger.error(error.suggestion);
		}
		logger.break();
		process.exit(1);
	}
	if (error instanceof z.ZodError) {
		logger.error("Validation failed:");
		for (const [key, value] of Object.entries(error.flatten().fieldErrors)) logger.error(`- ${highlighter.info(key)}: ${value}`);
		logger.break();
		process.exit(1);
	}
	if (error instanceof Error) {
		logger.error(error.message);
		logger.break();
		process.exit(1);
	}
	logger.break();
	process.exit(1);
}

//#endregion
//#region src/utils/updaters/update-tailwind-config.ts
async function updateTailwindConfig(tailwindConfig, config, options) {
	if (!tailwindConfig) return;
	options = {
		silent: false,
		tailwindVersion: "v3",
		...options
	};
	if (options.tailwindVersion === "v4") return;
	const tailwindFileRelativePath = path.relative(config.resolvedPaths.cwd, config.resolvedPaths.tailwindConfig);
	const tailwindSpinner = spinner(`Updating ${highlighter.info(tailwindFileRelativePath)}`, { silent: options.silent }).start();
	const output = await transformTailwindConfig(await promises.readFile(config.resolvedPaths.tailwindConfig, "utf8"), tailwindConfig, config);
	await promises.writeFile(config.resolvedPaths.tailwindConfig, output, "utf8");
	tailwindSpinner?.succeed();
}
async function transformTailwindConfig(input, tailwindConfig, config) {
	const sourceFile = await _createSourceFile(input, config);
	const configObject = sourceFile.getDescendantsOfKind(SyntaxKind.ObjectLiteralExpression).find((node) => node.getProperties().some((property) => property.isKind(SyntaxKind.PropertyAssignment) && property.getName() === "content"));
	if (!configObject) return input;
	addTailwindConfigProperty(configObject, {
		name: "darkMode",
		value: "class"
	}, { quoteChar: _getQuoteChar(configObject) });
	tailwindConfig.plugins?.forEach((plugin) => {
		addTailwindConfigPlugin(configObject, plugin);
	});
	if (tailwindConfig.theme) await addTailwindConfigTheme(configObject, tailwindConfig.theme);
	return sourceFile.getFullText();
}
function addTailwindConfigProperty(configObject, property, { quoteChar }) {
	const existingProperty = configObject.getProperty("darkMode");
	if (!existingProperty) {
		const newProperty = {
			name: property.name,
			initializer: `[${quoteChar}${property.value}${quoteChar}]`
		};
		if (property.name === "darkMode") {
			configObject.insertPropertyAssignment(0, newProperty);
			return configObject;
		}
		configObject.addPropertyAssignment(newProperty);
		return configObject;
	}
	if (existingProperty.isKind(SyntaxKind.PropertyAssignment)) {
		const initializer = existingProperty.getInitializer();
		const newValue = `${quoteChar}${property.value}${quoteChar}`;
		if (initializer?.isKind(SyntaxKind.StringLiteral)) {
			const initializerText = initializer.getText();
			initializer.replaceWithText(`[${initializerText}, ${newValue}]`);
			return configObject;
		}
		if (initializer?.isKind(SyntaxKind.ArrayLiteralExpression)) {
			if (initializer.getElements().map((element) => element.getText()).includes(newValue)) return configObject;
			initializer.addElement(newValue);
		}
		return configObject;
	}
	return configObject;
}
async function addTailwindConfigTheme(configObject, theme) {
	if (!configObject.getProperty("theme")) configObject.addPropertyAssignment({
		name: "theme",
		initializer: "{}"
	});
	nestSpreadProperties(configObject);
	const themeInitializer = (configObject.getPropertyOrThrow("theme")?.asKindOrThrow(SyntaxKind.PropertyAssignment)).getInitializer();
	if (themeInitializer?.isKind(SyntaxKind.ObjectLiteralExpression)) {
		const resultString = objectToString(deepmerge(await parseObjectLiteral(themeInitializer.getText()), theme, { arrayMerge: (dst, src) => src })).replace(/'\.\.\.(.*)'/g, "...$1").replace(/'"/g, "'").replace(/"'/g, "'").replace(/'\[/g, "[").replace(/\]'/g, "]").replace(/'\\'/g, "'").replace(/\\'/g, "'").replace(/\\''/g, "'").replace(/''/g, "'");
		themeInitializer.replaceWithText(resultString);
	}
	unnestSpreadProperties(configObject);
}
function addTailwindConfigPlugin(configObject, plugin) {
	const existingPlugins = configObject.getProperty("plugins");
	if (!existingPlugins) {
		configObject.addPropertyAssignment({
			name: "plugins",
			initializer: `[${plugin}]`
		});
		return configObject;
	}
	if (existingPlugins.isKind(SyntaxKind.PropertyAssignment)) {
		const initializer = existingPlugins.getInitializer();
		if (initializer?.isKind(SyntaxKind.ArrayLiteralExpression)) {
			if (initializer.getElements().map((element) => {
				return element.getText().replace(/["']/g, "");
			}).includes(plugin.replace(/["']/g, ""))) return configObject;
			initializer.addElement(plugin);
		}
		return configObject;
	}
	return configObject;
}
async function _createSourceFile(input, config) {
	const dir = await promises.mkdtemp(path.join(tmpdir(), "shadcn-"));
	const resolvedPath = config?.resolvedPaths?.tailwindConfig || "tailwind.config.ts";
	const tempFile = path.join(dir, `shadcn-${path.basename(resolvedPath)}`);
	return new Project({ compilerOptions: {} }).createSourceFile(tempFile, input, { scriptKind: path.extname(resolvedPath) === ".ts" ? ScriptKind.TS : ScriptKind.JS });
}
function _getQuoteChar(configObject) {
	return configObject.getFirstDescendantByKind(SyntaxKind.StringLiteral)?.getQuoteKind() === QuoteKind.Single ? "'" : "\"";
}
function nestSpreadProperties(obj) {
	const properties = obj.getProperties();
	for (let i = 0; i < properties.length; i++) {
		const prop = properties[i];
		if (prop.isKind(SyntaxKind.SpreadAssignment)) {
			const spreadAssignment = prop.asKindOrThrow(SyntaxKind.SpreadAssignment);
			const spreadText = spreadAssignment.getExpression().getText();
			obj.insertPropertyAssignment(i, {
				name: `"___${spreadText.replace(/^\.\.\./, "")}"`,
				initializer: `"...${spreadText.replace(/^\.\.\./, "")}"`
			});
			spreadAssignment.remove();
		} else if (prop.isKind(SyntaxKind.PropertyAssignment)) {
			const initializer = prop.asKindOrThrow(SyntaxKind.PropertyAssignment).getInitializer();
			if (initializer && initializer.isKind(SyntaxKind.ObjectLiteralExpression)) nestSpreadProperties(initializer.asKindOrThrow(SyntaxKind.ObjectLiteralExpression));
			else if (initializer && initializer.isKind(SyntaxKind.ArrayLiteralExpression)) nestSpreadElements(initializer.asKindOrThrow(SyntaxKind.ArrayLiteralExpression));
		}
	}
}
function nestSpreadElements(arr) {
	const elements = arr.getElements();
	for (let j = 0; j < elements.length; j++) {
		const element = elements[j];
		if (element.isKind(SyntaxKind.ObjectLiteralExpression)) nestSpreadProperties(element.asKindOrThrow(SyntaxKind.ObjectLiteralExpression));
		else if (element.isKind(SyntaxKind.ArrayLiteralExpression)) nestSpreadElements(element.asKindOrThrow(SyntaxKind.ArrayLiteralExpression));
		else if (element.isKind(SyntaxKind.SpreadElement)) {
			const spreadText = element.getText();
			arr.removeElement(j);
			arr.insertElement(j, `"${spreadText}"`);
		}
	}
}
function unnestSpreadProperties(obj) {
	const properties = obj.getProperties();
	for (let i = 0; i < properties.length; i++) {
		const prop = properties[i];
		if (prop.isKind(SyntaxKind.PropertyAssignment)) {
			const propAssignment = prop;
			const initializer = propAssignment.getInitializer();
			if (initializer && initializer.isKind(SyntaxKind.StringLiteral)) {
				const value = initializer.asKindOrThrow(SyntaxKind.StringLiteral).getLiteralValue();
				if (value.startsWith("...")) {
					obj.insertSpreadAssignment(i, { expression: value.slice(3) });
					propAssignment.remove();
				}
			} else if (initializer?.isKind(SyntaxKind.ObjectLiteralExpression)) unnestSpreadProperties(initializer);
			else if (initializer && initializer.isKind(SyntaxKind.ArrayLiteralExpression)) unsetSpreadElements(initializer.asKindOrThrow(SyntaxKind.ArrayLiteralExpression));
		}
	}
}
function unsetSpreadElements(arr) {
	const elements = arr.getElements();
	for (let j = 0; j < elements.length; j++) {
		const element = elements[j];
		if (element.isKind(SyntaxKind.ObjectLiteralExpression)) unnestSpreadProperties(element.asKindOrThrow(SyntaxKind.ObjectLiteralExpression));
		else if (element.isKind(SyntaxKind.ArrayLiteralExpression)) unsetSpreadElements(element.asKindOrThrow(SyntaxKind.ArrayLiteralExpression));
		else if (element.isKind(SyntaxKind.StringLiteral)) {
			const spreadText = element.getText();
			const spreadTest = /^['"](\.\.\..*)['"]$/g;
			if (spreadTest.test(spreadText)) {
				arr.removeElement(j);
				arr.insertElement(j, spreadText.replace(spreadTest, "$1"));
			}
		}
	}
}
async function parseObjectLiteral(objectLiteralString) {
	const statement = (await _createSourceFile(`const theme = ${objectLiteralString}`, null)).getStatements()[0];
	if (statement?.getKind() === SyntaxKind.VariableStatement) {
		const initializer = (statement.getDeclarationList()?.getDeclarations()[0]).getInitializer();
		if (initializer?.isKind(SyntaxKind.ObjectLiteralExpression)) return await parseObjectLiteralExpression(initializer);
	}
	throw new Error("Invalid input: not an object literal");
}
function parseObjectLiteralExpression(node) {
	const result = {};
	for (const property of node.getProperties()) if (property.isKind(SyntaxKind.PropertyAssignment)) {
		const name = property.getName().replace(/'/g, "");
		if (property.getInitializer()?.isKind(SyntaxKind.ObjectLiteralExpression)) result[name] = parseObjectLiteralExpression(property.getInitializer());
		else if (property.getInitializer()?.isKind(SyntaxKind.ArrayLiteralExpression)) result[name] = parseArrayLiteralExpression(property.getInitializer());
		else result[name] = parseValue(property.getInitializer());
	}
	return result;
}
function parseArrayLiteralExpression(node) {
	const result = [];
	for (const element of node.getElements()) if (element.isKind(SyntaxKind.ObjectLiteralExpression)) result.push(parseObjectLiteralExpression(element.asKindOrThrow(SyntaxKind.ObjectLiteralExpression)));
	else if (element.isKind(SyntaxKind.ArrayLiteralExpression)) result.push(parseArrayLiteralExpression(element.asKindOrThrow(SyntaxKind.ArrayLiteralExpression)));
	else result.push(parseValue(element));
	return result;
}
function parseValue(node) {
	switch (node.getKind()) {
		case SyntaxKind.StringLiteral: return node.getText();
		case SyntaxKind.NumericLiteral: return Number(node.getText());
		case SyntaxKind.TrueKeyword: return true;
		case SyntaxKind.FalseKeyword: return false;
		case SyntaxKind.NullKeyword: return null;
		case SyntaxKind.ArrayLiteralExpression: return node.getElements().map(parseValue);
		case SyntaxKind.ObjectLiteralExpression: return parseObjectLiteralExpression(node);
		default: return node.getText();
	}
}
function buildTailwindThemeColorsFromCssVars(cssVars) {
	const result = {};
	for (const key of Object.keys(cssVars)) {
		const parts = key.split("-");
		const colorName = parts[0];
		const subType = parts.slice(1).join("-");
		if (subType === "") if (typeof result[colorName] === "object") result[colorName].DEFAULT = `hsl(var(--${key}))`;
		else result[colorName] = `hsl(var(--${key}))`;
		else {
			if (typeof result[colorName] !== "object") result[colorName] = { DEFAULT: `hsl(var(--${colorName}))` };
			result[colorName][subType] = `hsl(var(--${key}))`;
		}
	}
	for (const [colorName, value] of Object.entries(result)) if (typeof value === "object" && value.DEFAULT === `hsl(var(--${colorName}))` && !(colorName in cssVars)) delete value.DEFAULT;
	return result;
}

//#endregion
//#region src/registry/resolver.ts
function resolveRegistryItemsFromRegistries(items, config) {
	const registryHeaders = {};
	const resolvedItems = [...items];
	if (!config?.registries) {
		setRegistryHeaders({});
		return resolvedItems;
	}
	for (let i = 0; i < resolvedItems.length; i++) {
		const resolved = buildUrlAndHeadersForRegistryItem(resolvedItems[i], config);
		if (resolved) {
			resolvedItems[i] = resolved.url;
			if (Object.keys(resolved.headers).length > 0) registryHeaders[resolved.url] = resolved.headers;
		}
	}
	setRegistryHeaders(registryHeaders);
	return resolvedItems;
}
async function fetchRegistryItems(items, config, options = {}) {
	return await Promise.all(items.map(async (item) => {
		if (isLocalFile(item)) return fetchRegistryLocal(item);
		if (isUrl$1(item)) {
			const [result$1] = await fetchRegistry([item], options);
			try {
				return registryItemSchema.parse(result$1);
			} catch (error) {
				throw new RegistryParseError(item, error);
			}
		}
		if (item.startsWith("@") && config?.registries) {
			const [result$1] = await fetchRegistry(resolveRegistryItemsFromRegistries([item], config), options);
			try {
				return registryItemSchema.parse(result$1);
			} catch (error) {
				throw new RegistryParseError(item, error);
			}
		}
		const [result] = await fetchRegistry([`styles/${config?.style ?? "new-york-v4"}/${item}.json`], options);
		try {
			return registryItemSchema.parse(result);
		} catch (error) {
			throw new RegistryParseError(item, error);
		}
	}));
}
registryItemSchema.extend({ _source: z.string().optional() });
async function resolveRegistryTree(names, config, options = {}) {
	try {
		options = {
			useCache: true,
			...options
		};
		let payload = [];
		const allDependencyItems = [];
		const allDependencyRegistryNames = [];
		const uniqueNames = Array.from(new Set(names));
		const results = await fetchRegistryItems(uniqueNames, config, options);
		const resultMap = /* @__PURE__ */ new Map();
		for (let i = 0; i < results.length; i++) if (results[i]) resultMap.set(uniqueNames[i], results[i]);
		for (const [sourceName, item] of Array.from(resultMap.entries())) {
			const itemWithSource = {
				...item,
				_source: sourceName
			};
			payload.push(itemWithSource);
			if (item.registryDependencies) {
				let resolvedDependencies = item.registryDependencies;
				if (!config?.registries) {
					const namespacedDeps = item.registryDependencies.filter((dep) => dep.startsWith("@"));
					if (namespacedDeps.length > 0) {
						const { registry } = parseRegistryAndItemFromString(namespacedDeps[0]);
						throw new RegistryNotConfiguredError(registry);
					}
				} else resolvedDependencies = resolveRegistryItemsFromRegistries(item.registryDependencies, config);
				const { items, registryNames } = await resolveDependenciesRecursively(resolvedDependencies, config, options, new Set(uniqueNames));
				allDependencyItems.push(...items);
				allDependencyRegistryNames.push(...registryNames);
			}
		}
		payload.push(...allDependencyItems);
		if (allDependencyRegistryNames.length > 0) {
			const uniqueRegistryNames = Array.from(new Set(allDependencyRegistryNames));
			const nonNamespacedItems = uniqueRegistryNames.filter((name) => !name.startsWith("@"));
			const namespacedDepItems = uniqueRegistryNames.filter((name) => name.startsWith("@"));
			if (namespacedDepItems.length > 0) {
				const depResults = await fetchRegistryItems(namespacedDepItems, config, options);
				for (let i = 0; i < depResults.length; i++) {
					const itemWithSource = {
						...depResults[i],
						_source: namespacedDepItems[i]
					};
					payload.push(itemWithSource);
				}
			}
			if (nonNamespacedItems.length > 0) {
				const index = await getShadcnRegistryIndex();
				if (!index && payload.length === 0) return null;
				if (index) {
					if (nonNamespacedItems.includes("index")) nonNamespacedItems.unshift("index");
					const registryUrls = [];
					for (const name of nonNamespacedItems) {
						const itemDependencies = await resolveRegistryDependencies(name, config, options);
						registryUrls.push(...itemDependencies);
					}
					const result = await fetchRegistry(Array.from(new Set(registryUrls)), options);
					const registryPayload = z.array(registryItemSchema).parse(result);
					payload.push(...registryPayload);
				}
			}
		}
		if (!payload.length) return null;
		if (uniqueNames.includes("index") || allDependencyRegistryNames.includes("index")) {
			if (config.tailwind.baseColor) {
				const theme = await registryGetTheme(config.tailwind.baseColor, config);
				if (theme) payload.unshift(theme);
			}
		}
		const sourceMap = /* @__PURE__ */ new Map();
		payload.forEach((item) => {
			const source = item._source || item.name;
			sourceMap.set(item, source);
		});
		payload = topologicalSortRegistryItems(payload, sourceMap);
		payload.sort((a, b) => {
			if (a.type === "registry:theme" && b.type !== "registry:theme") return -1;
			if (a.type !== "registry:theme" && b.type === "registry:theme") return 1;
			return 0;
		});
		let tailwind = {};
		payload.forEach((item) => {
			tailwind = deepmerge(tailwind, item.tailwind ?? {});
		});
		let cssVars = {};
		payload.forEach((item) => {
			cssVars = deepmerge(cssVars, item.cssVars ?? {});
		});
		let css = {};
		payload.forEach((item) => {
			css = deepmerge(css, item.css ?? {});
		});
		let docs = "";
		payload.forEach((item) => {
			if (item.docs) docs += `${item.docs}\n`;
		});
		let envVars = {};
		payload.forEach((item) => {
			envVars = deepmerge(envVars, item.envVars ?? {});
		});
		const deduplicatedFiles = await deduplicateFilesByTarget(payload.map((item) => item.files ?? []), config);
		const parsed = registryResolvedItemsTreeSchema.parse({
			dependencies: deepmerge.all(payload.map((item) => item.dependencies ?? [])),
			devDependencies: deepmerge.all(payload.map((item) => item.devDependencies ?? [])),
			files: deduplicatedFiles,
			tailwind,
			cssVars,
			css,
			docs
		});
		if (Object.keys(envVars).length > 0) parsed.envVars = envVars;
		return parsed;
	} catch (error) {
		handleError(error);
		return null;
	}
}
async function resolveDependenciesRecursively(dependencies, config, options = {}, visited = /* @__PURE__ */ new Set()) {
	const items = [];
	const registryNames = [];
	for (const dep of dependencies) {
		if (visited.has(dep)) continue;
		visited.add(dep);
		if (isUrl$1(dep) || isLocalFile(dep)) {
			const [item] = await fetchRegistryItems([dep], config, options);
			if (item) {
				items.push(item);
				if (item.registryDependencies) {
					const nested = await resolveDependenciesRecursively(config?.registries ? resolveRegistryItemsFromRegistries(item.registryDependencies, config) : item.registryDependencies, config, options, visited);
					items.push(...nested.items);
					registryNames.push(...nested.registryNames);
				}
			}
		} else if (dep.startsWith("@") && config?.registries) {
			const { registry } = parseRegistryAndItemFromString(dep);
			if (registry && !(registry in config.registries)) throw new RegistryNotConfiguredError(registry);
			const [item] = await fetchRegistryItems([dep], config, options);
			if (item) {
				items.push(item);
				if (item.registryDependencies) {
					const nested = await resolveDependenciesRecursively(config?.registries ? resolveRegistryItemsFromRegistries(item.registryDependencies, config) : item.registryDependencies, config, options, visited);
					items.push(...nested.items);
					registryNames.push(...nested.registryNames);
				}
			}
		} else {
			registryNames.push(dep);
			if (config) try {
				const [item] = await fetchRegistryItems([dep], config, options);
				if (item && item.registryDependencies) {
					const nested = await resolveDependenciesRecursively(config?.registries ? resolveRegistryItemsFromRegistries(item.registryDependencies, config) : item.registryDependencies, config, options, visited);
					items.push(...nested.items);
					registryNames.push(...nested.registryNames);
				}
			} catch (error) {}
		}
	}
	return {
		items,
		registryNames
	};
}
async function resolveRegistryDependencies(url, config, options = {}) {
	if (isUrl$1(url)) return [url];
	const { registryNames } = await resolveDependenciesRecursively([url], config, options, /* @__PURE__ */ new Set());
	const style = config.resolvedPaths?.cwd ? await getTargetStyleFromConfig(config.resolvedPaths.cwd, config.style) : config.style;
	const urls = registryNames.map((name) => resolveRegistryUrl(isUrl$1(name) ? name : `styles/${style}/${name}.json`));
	return Array.from(new Set(urls));
}
async function registryGetTheme(name, config) {
	const [baseColor, tailwindVersion] = await Promise.all([getRegistryBaseColor(name), getProjectTailwindVersionFromConfig(config)]);
	if (!baseColor) return null;
	const theme = {
		name,
		type: "registry:theme",
		tailwind: { config: { theme: { extend: {
			borderRadius: {
				lg: "var(--radius)",
				md: "calc(var(--radius) - 2px)",
				sm: "calc(var(--radius) - 4px)"
			},
			colors: {}
		} } } },
		cssVars: {
			theme: {},
			light: { radius: "0.5rem" },
			dark: {}
		}
	};
	if (config.tailwind.cssVariables) {
		theme.tailwind.config.theme.extend.colors = {
			...theme.tailwind.config.theme.extend.colors,
			...buildTailwindThemeColorsFromCssVars(baseColor.cssVars.dark ?? {})
		};
		theme.cssVars = {
			theme: {
				...baseColor.cssVars.theme,
				...theme.cssVars.theme
			},
			light: {
				...baseColor.cssVars.light,
				...theme.cssVars.light
			},
			dark: {
				...baseColor.cssVars.dark,
				...theme.cssVars.dark
			}
		};
		if (tailwindVersion === "v4" && baseColor.cssVarsV4) theme.cssVars = {
			theme: {
				...baseColor.cssVarsV4.theme,
				...theme.cssVars.theme
			},
			light: {
				radius: "0.625rem",
				...baseColor.cssVarsV4.light
			},
			dark: { ...baseColor.cssVarsV4.dark }
		};
	}
	return theme;
}
function computeItemHash(item, source) {
	const identifier = source || item.name;
	const hash = createHash("sha256").update(identifier).digest("hex").substring(0, 8);
	return `${item.name}::${hash}`;
}
function extractItemIdentifierFromDependency(dependency) {
	if (isUrl$1(dependency)) {
		const pathname = new URL(dependency).pathname;
		const match = pathname.match(/\/([^/]+)\.json$/);
		const name = match ? match[1] : path.basename(pathname, ".json");
		return {
			name,
			hash: computeItemHash({ name }, dependency)
		};
	}
	if (isLocalFile(dependency)) {
		const match = dependency.match(/\/([^/]+)\.json$/);
		const name = match ? match[1] : path.basename(dependency, ".json");
		return {
			name,
			hash: computeItemHash({ name }, dependency)
		};
	}
	const { item } = parseRegistryAndItemFromString(dependency);
	return {
		name: item,
		hash: computeItemHash({ name: item }, dependency)
	};
}
function topologicalSortRegistryItems(items, sourceMap) {
	const itemMap = /* @__PURE__ */ new Map();
	const hashToItem = /* @__PURE__ */ new Map();
	const inDegree = /* @__PURE__ */ new Map();
	const adjacencyList = /* @__PURE__ */ new Map();
	items.forEach((item) => {
		const hash = computeItemHash(item, sourceMap.get(item) || item.name);
		itemMap.set(hash, item);
		hashToItem.set(hash, item);
		inDegree.set(hash, 0);
		adjacencyList.set(hash, []);
	});
	const depToHashes = /* @__PURE__ */ new Map();
	items.forEach((item) => {
		const source = sourceMap.get(item) || item.name;
		const hash = computeItemHash(item, source);
		if (!depToHashes.has(item.name)) depToHashes.set(item.name, []);
		depToHashes.get(item.name).push(hash);
		if (source !== item.name) {
			if (!depToHashes.has(source)) depToHashes.set(source, []);
			depToHashes.get(source).push(hash);
		}
	});
	items.forEach((item) => {
		const itemHash = computeItemHash(item, sourceMap.get(item) || item.name);
		if (item.registryDependencies) item.registryDependencies.forEach((dep) => {
			let depHash;
			const exactMatches = depToHashes.get(dep) || [];
			if (exactMatches.length === 1) depHash = exactMatches[0];
			else if (exactMatches.length > 1) depHash = exactMatches[0];
			else {
				const { name } = extractItemIdentifierFromDependency(dep);
				const nameMatches = depToHashes.get(name) || [];
				if (nameMatches.length > 0) depHash = nameMatches[0];
			}
			if (depHash && itemMap.has(depHash)) {
				adjacencyList.get(depHash).push(itemHash);
				inDegree.set(itemHash, inDegree.get(itemHash) + 1);
			}
		});
	});
	const queue = [];
	const sorted = [];
	inDegree.forEach((degree, hash) => {
		if (degree === 0) queue.push(hash);
	});
	while (queue.length > 0) {
		const currentHash = queue.shift();
		const item = itemMap.get(currentHash);
		sorted.push(item);
		adjacencyList.get(currentHash).forEach((dependentHash) => {
			const newDegree = inDegree.get(dependentHash) - 1;
			inDegree.set(dependentHash, newDegree);
			if (newDegree === 0) queue.push(dependentHash);
		});
	}
	if (sorted.length !== items.length) {
		console.warn("Circular dependency detected in registry items");
		const sortedHashes = new Set(sorted.map((item) => {
			return computeItemHash(item, sourceMap.get(item) || item.name);
		}));
		items.forEach((item) => {
			const hash = computeItemHash(item, sourceMap.get(item) || item.name);
			if (!sortedHashes.has(hash)) sorted.push(item);
		});
	}
	return sorted;
}

//#endregion
//#region src/registry/api.ts
async function getRegistry(name, options) {
	const { config, useCache } = options || {};
	if (isUrl$1(name)) {
		const [result$1] = await fetchRegistry([name], { useCache });
		try {
			return registrySchema.parse(result$1);
		} catch (error) {
			throw new RegistryParseError(name, error);
		}
	}
	if (!name.startsWith("@")) throw new RegistryInvalidNamespaceError(name);
	let registryName = name;
	if (!registryName.endsWith("/registry")) registryName = `${registryName}/registry`;
	const urlAndHeaders = buildUrlAndHeadersForRegistryItem(registryName, configWithDefaults(config));
	if (!urlAndHeaders?.url) throw new RegistryNotFoundError(registryName);
	if (urlAndHeaders.headers && Object.keys(urlAndHeaders.headers).length > 0) setRegistryHeaders({ [urlAndHeaders.url]: urlAndHeaders.headers });
	const [result] = await fetchRegistry([urlAndHeaders.url], { useCache });
	try {
		return registrySchema.parse(result);
	} catch (error) {
		throw new RegistryParseError(registryName, error);
	}
}
async function getRegistryItems(items, options) {
	const { config, useCache = false } = options || {};
	clearRegistryContext();
	return fetchRegistryItems(items, configWithDefaults(config), { useCache });
}
async function resolveRegistryItems(items, options) {
	const { config, useCache = false } = options || {};
	clearRegistryContext();
	return resolveRegistryTree(items, configWithDefaults(config), { useCache });
}
async function getRegistriesConfig(cwd) {
	const configResult = await getRawConfig(cwd);
	if (!configResult) return { registries: BUILTIN_REGISTRIES };
	const registriesConfig = z.object({ registries: registryConfigSchema.optional() }).safeParse(configResult);
	if (!registriesConfig.success) throw new ConfigParseError(cwd, registriesConfig.error);
	return { registries: {
		...BUILTIN_REGISTRIES,
		...registriesConfig.data.registries || {}
	} };
}
async function getShadcnRegistryIndex() {
	try {
		const [result] = await fetchRegistry(["index.json"]);
		return registryIndexSchema.parse(result);
	} catch (error) {
		logger.error("\n");
		handleError(error);
	}
}
async function getRegistryStyles() {
	try {
		const [result] = await fetchRegistry(["styles/index.json"]);
		return stylesSchema.parse(result);
	} catch (error) {
		logger.error("\n");
		handleError(error);
		return [];
	}
}
async function getRegistryIcons() {
	try {
		const [result] = await fetchRegistry(["icons/index.json"]);
		return iconsSchema.parse(result);
	} catch (error) {
		handleError(error);
		return {};
	}
}
async function getRegistryBaseColors() {
	return BASE_COLORS;
}
async function getRegistryBaseColor(baseColor) {
	try {
		const [result] = await fetchRegistry([`colors/${baseColor}.json`]);
		return registryBaseColorSchema.parse(result);
	} catch (error) {
		handleError(error);
	}
}
/**
* @deprecated This function is deprecated and will be removed in a future version.
*/
async function resolveTree(index, names) {
	const tree = [];
	for (const name of names) {
		const entry = index.find((entry$1) => entry$1.name === name);
		if (!entry) continue;
		tree.push(entry);
		if (entry.registryDependencies) {
			const dependencies = await resolveTree(index, entry.registryDependencies);
			tree.push(...dependencies);
		}
	}
	return tree.filter((component, index$1, self) => self.findIndex((c) => c.name === component.name) === index$1);
}
/**
* @deprecated This function is deprecated and will be removed in a future version.
*/
async function fetchTree(style, tree) {
	try {
		return (await fetchRegistry(tree.map((item) => `styles/${style}/${item.name}.json`))).map((result) => registryItemSchema.parse(result));
	} catch (error) {
		handleError(error);
		return [];
	}
}
/**
* @deprecated This function is deprecated and will be removed in a future version.
*/
async function getItemTargetPath(config, item, override) {
	if (override) return override;
	if (item.type === "registry:ui") return config.resolvedPaths.ui ?? config.resolvedPaths.components;
	const [parent, type] = item.type?.split(":") ?? [];
	if (!(parent in config.resolvedPaths)) return null;
	return path.join(config.resolvedPaths[parent], type);
}
async function getRegistriesIndex(options) {
	options = {
		useCache: true,
		...options
	};
	const [data] = await fetchRegistry([`${REGISTRY_URL}/registries.json`], { useCache: options.useCache });
	try {
		return registriesIndexSchema.parse(data);
	} catch (error) {
		if (error instanceof z.ZodError) throw new RegistriesIndexParseError(error);
		throw error;
	}
}

//#endregion
//#region src/registry/search.ts
async function searchRegistries(registries, options) {
	const { query, limit, offset, config, useCache } = options || {};
	let allItems = [];
	for (const registry of registries) {
		const itemsWithRegistry = ((await getRegistry(registry, {
			config,
			useCache
		})).items || []).map((item) => ({
			name: item.name,
			type: item.type,
			description: item.description,
			registry,
			addCommandArgument: buildRegistryItemNameFromRegistry(item.name, registry)
		}));
		allItems = allItems.concat(itemsWithRegistry);
	}
	if (query) allItems = searchItems(allItems, {
		query,
		limit: allItems.length,
		keys: ["name", "description"]
	});
	const paginationOffset = offset || 0;
	const paginationLimit = limit || allItems.length;
	const totalItems = allItems.length;
	const result = {
		pagination: {
			total: totalItems,
			offset: paginationOffset,
			limit: paginationLimit,
			hasMore: paginationOffset + paginationLimit < totalItems
		},
		items: allItems.slice(paginationOffset, paginationOffset + paginationLimit)
	};
	return searchResultsSchema.parse(result);
}
const searchableItemSchema = z.object({
	name: z.string(),
	type: z.string().optional(),
	description: z.string().optional(),
	registry: z.string().optional(),
	addCommandArgument: z.string().optional()
}).passthrough();
function searchItems(items, options) {
	options = {
		limit: 100,
		threshold: -1e4,
		...options
	};
	const results = fuzzysort.go(options.query, items, {
		keys: options.keys,
		threshold: options.threshold,
		limit: options.limit
	}).map((result) => result.obj);
	return z.array(searchableItemSchema).parse(results);
}
function isUrl(string) {
	try {
		new URL(string);
		return true;
	} catch {
		return false;
	}
}
function buildRegistryItemNameFromRegistry(name, registry) {
	if (!isUrl(registry)) return `${registry}/${name}`;
	const protocolEnd = registry.indexOf("://") + 3;
	const hostEnd = registry.indexOf("/", protocolEnd);
	if (hostEnd === -1) {
		const queryStart = registry.indexOf("?", protocolEnd);
		if (queryStart !== -1) return registry.substring(0, queryStart) + registry.substring(queryStart).replace(/\bregistry\b/g, name);
		return registry;
	}
	const hostPart = registry.substring(0, hostEnd);
	const pathAndQuery = registry.substring(hostEnd);
	const pathEnd = pathAndQuery.includes("?") ? pathAndQuery.indexOf("?") : pathAndQuery.length;
	const pathOnly = pathAndQuery.substring(0, pathEnd);
	const queryAndAfter = pathAndQuery.substring(pathEnd);
	const lastIndex = pathOnly.lastIndexOf("registry");
	let updatedPath = pathOnly;
	if (lastIndex !== -1) updatedPath = pathOnly.substring(0, lastIndex) + name + pathOnly.substring(lastIndex + 8);
	const updatedQuery = queryAndAfter.replace(/\bregistry\b/g, name);
	return hostPart + updatedPath + updatedQuery;
}

//#endregion
export { RegistryLocalFileError as $, mergeEnvContent as A, DEFAULT_TAILWIND_CSS as B, configWithDefaults as C, ICON_LIBRARIES as D, transform$2 as E, getProjectInfo as F, getConfig as G, createConfig as H, getProjectTailwindVersionFromConfig as I, RegistriesIndexParseError as J, getWorkspaceConfig as K, getPackageInfo as L, spinner as M, logger as N, findExistingEnvFile as O, getProjectConfig as P, RegistryInvalidNamespaceError as Q, DEFAULT_COMPONENTS as R, clearRegistryContext as S, updateFiles as T, findCommonRoot$1 as U, DEFAULT_UTILS as V, findPackageRoot as W, RegistryFetchError as X, RegistryError as Y, RegistryForbiddenError as Z, _createSourceFile as _, getRegistriesIndex as a, highlighter as at, handleError as b, getRegistryBaseColors as c, DEPRECATED_COMPONENTS as ct, getRegistryStyles as d, RegistryMissingEnvironmentVariablesError as et, getShadcnRegistryIndex as f, resolveRegistryTree as g, fetchRegistryItems as h, getRegistriesConfig as i, RegistryUnauthorizedError as it, parseRegistryAndItemFromString as j, getNewEnvKeys as k, getRegistryIcons as l, resolveTree as m, fetchTree as n, RegistryNotFoundError as nt, getRegistry as o, BASE_COLORS as ot, resolveRegistryItems as p, resolveConfigPaths as q, getItemTargetPath as r, RegistryParseError as rt, getRegistryBaseColor as s, BUILTIN_REGISTRIES as st, searchRegistries as t, RegistryNotConfiguredError as tt, getRegistryItems as u, _getQuoteChar as v, isUniversalRegistryItem as w, buildUrlAndHeadersForRegistryItem as x, updateTailwindConfig as y, DEFAULT_TAILWIND_CONFIG as z };
//# sourceMappingURL=registry-ClmPjtrG.js.map