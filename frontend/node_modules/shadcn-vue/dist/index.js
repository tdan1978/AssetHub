#!/usr/bin/env node
import { A as mergeEnvContent, B as DEFAULT_TAILWIND_CSS, C as configWithDefaults, D as ICON_LIBRARIES, E as transform, F as getProjectInfo, G as getConfig, H as createConfig, I as getProjectTailwindVersionFromConfig, K as getWorkspaceConfig, L as getPackageInfo, M as spinner, N as logger, O as findExistingEnvFile, P as getProjectConfig, R as DEFAULT_COMPONENTS, S as clearRegistryContext, T as updateFiles, U as findCommonRoot, V as DEFAULT_UTILS, W as findPackageRoot, _ as _createSourceFile, a as getRegistriesIndex, at as highlighter, b as handleError, c as getRegistryBaseColors, ct as DEPRECATED_COMPONENTS, d as getRegistryStyles, f as getShadcnRegistryIndex, g as resolveRegistryTree, h as fetchRegistryItems, i as getRegistriesConfig, j as parseRegistryAndItemFromString, k as getNewEnvKeys, l as getRegistryIcons, m as resolveTree, n as fetchTree, o as getRegistry, ot as BASE_COLORS, p as resolveRegistryItems, q as resolveConfigPaths, r as getItemTargetPath, s as getRegistryBaseColor, st as BUILTIN_REGISTRIES, tt as RegistryNotConfiguredError, u as getRegistryItems, v as _getQuoteChar, w as isUniversalRegistryItem, x as buildUrlAndHeadersForRegistryItem, y as updateTailwindConfig, z as DEFAULT_TAILWIND_CONFIG } from "./registry-ClmPjtrG.js";
import { _ as registrySchema, p as registryItemSchema, r as rawConfigSchema } from "./schema-Brc22MYG.js";
import { t as server } from "./mcp-9eE0BYQA.js";
import { Command } from "commander";
import path, { isAbsolute, join, normalize, resolve, sep } from "pathe";
import prompts from "prompts";
import z$1, { z } from "zod";
import { existsSync, promises } from "fs";
import deepmerge from "deepmerge";
import fsExtra from "fs-extra";
import { glob } from "tinyglobby";
import consola from "consola";
import * as fs from "fs/promises";
import { tmpdir } from "os";
import { Project, ScriptKind, SyntaxKind } from "ts-morph";
import { randomBytes } from "crypto";
import postcss from "postcss";
import AtRule from "postcss/lib/at-rule";
import { addDependency, detectPackageManager } from "nypm";
import * as path$1 from "path";
import { diffLines } from "diff";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { x } from "tinyexec";

//#region src/utils/errors.ts
const MISSING_DIR_OR_EMPTY_PROJECT = "1";
const MISSING_CONFIG = "3";
const TAILWIND_NOT_CONFIGURED = "5";
const IMPORT_ALIAS_MISSING = "6";
const UNSUPPORTED_FRAMEWORK = "7";
const BUILD_MISSING_REGISTRY_FILE = "13";

//#endregion
//#region src/preflights/preflight-init.ts
async function preFlightInit(options) {
	const errors = {};
	if (!fsExtra.existsSync(options.cwd) || !fsExtra.existsSync(path.resolve(options.cwd, "package.json"))) {
		errors[MISSING_DIR_OR_EMPTY_PROJECT] = true;
		return {
			errors,
			projectInfo: null
		};
	}
	const projectSpinner = spinner(`Preflight checks.`, { silent: options.silent }).start();
	if (fsExtra.existsSync(path.resolve(options.cwd, "components.json")) && !options.force) {
		projectSpinner?.fail();
		logger.break();
		logger.error(`A ${highlighter.info("components.json")} file already exists at ${highlighter.info(options.cwd)}.\nTo start over, remove the ${highlighter.info("components.json")} file and run ${highlighter.info("init")} again.`);
		logger.break();
		process.exit(1);
	}
	projectSpinner?.succeed();
	const frameworkSpinner = spinner(`Verifying framework.`, { silent: options.silent }).start();
	const projectInfo = await getProjectInfo(options.cwd);
	if (!projectInfo || projectInfo?.framework.name === "manual") {
		errors[UNSUPPORTED_FRAMEWORK] = true;
		frameworkSpinner?.fail();
		logger.break();
		if (projectInfo?.framework.links.installation) logger.error(`We could not detect a supported framework at ${highlighter.info(options.cwd)}.\nVisit ${highlighter.info(projectInfo?.framework.links.installation)} to manually configure your project.\nOnce configured, you can use the cli to add components.`);
		logger.break();
		process.exit(1);
	}
	frameworkSpinner?.succeed(`Verifying framework. Found ${highlighter.info(projectInfo.framework.label)}.`);
	let tailwindSpinnerMessage = "Validating Tailwind CSS.";
	if (projectInfo.tailwindVersion === "v4") tailwindSpinnerMessage = `Validating Tailwind CSS config. Found ${highlighter.info("v4")}.`;
	const tailwindSpinner = spinner(tailwindSpinnerMessage, { silent: options.silent }).start();
	if (projectInfo.tailwindVersion === "v3" && (!projectInfo?.tailwindConfigFile || !projectInfo?.tailwindCssFile)) {
		errors[TAILWIND_NOT_CONFIGURED] = true;
		tailwindSpinner?.fail();
	} else if (projectInfo.tailwindVersion === "v4" && !projectInfo?.tailwindCssFile) {
		errors[TAILWIND_NOT_CONFIGURED] = true;
		tailwindSpinner?.fail();
	} else if (!projectInfo.tailwindVersion) {
		errors[TAILWIND_NOT_CONFIGURED] = true;
		tailwindSpinner?.fail();
	} else tailwindSpinner?.succeed();
	const tsConfigSpinner = spinner(`Validating import alias.`, { silent: options.silent }).start();
	if (!projectInfo?.aliasPrefix) {
		errors[IMPORT_ALIAS_MISSING] = true;
		tsConfigSpinner?.fail();
	} else tsConfigSpinner?.succeed();
	if (Object.keys(errors).length > 0) {
		if (errors[TAILWIND_NOT_CONFIGURED]) {
			logger.break();
			logger.error(`No Tailwind CSS configuration found at ${highlighter.info(options.cwd)}.`);
			logger.error(`It is likely you do not have Tailwind CSS installed or have an invalid configuration.`);
			logger.error(`Install Tailwind CSS then try again.`);
			if (projectInfo?.framework.links.tailwind) logger.error(`Visit ${highlighter.info(projectInfo?.framework.links.tailwind)} to get started.`);
		}
		if (errors[IMPORT_ALIAS_MISSING]) {
			logger.break();
			logger.error(`No import alias found in your tsconfig.json file.`);
			if (projectInfo?.framework.links.installation) logger.error(`Visit ${highlighter.info(projectInfo?.framework.links.installation)} to learn how to set an import alias.`);
		}
		logger.break();
		process.exit(1);
	}
	return {
		errors,
		projectInfo
	};
}

//#endregion
//#region src/utils/is-safe-target.ts
function isSafeTarget(targetPath, cwd) {
	if (targetPath.includes("\0")) return false;
	let decodedPath;
	try {
		decodedPath = targetPath;
		let prevPath = "";
		while (decodedPath !== prevPath && decodedPath.includes("%")) {
			prevPath = decodedPath;
			decodedPath = decodeURIComponent(decodedPath);
		}
	} catch {
		return false;
	}
	const normalizedTarget = normalize(decodedPath);
	const normalizedRoot = normalize(cwd);
	const hasPathTraversal = (path$2) => {
		return path$2.replace(/\[\.\.\..*?\]/g, "").includes("..");
	};
	if (hasPathTraversal(normalizedTarget) || hasPathTraversal(decodedPath) || hasPathTraversal(targetPath)) return false;
	const cleanPath = (path$2) => path$2.replace(/\[\.\.\..*?\]/g, "");
	const cleanTarget = cleanPath(targetPath);
	const cleanDecoded = cleanPath(decodedPath);
	if ([
		/\.\.[/\\]/,
		/[/\\]\.\./,
		/\.\./,
		/\.\.%/,
		/\0/,
		/[\x01-\x1F]/
	].some((pattern) => pattern.test(cleanTarget) || pattern.test(cleanDecoded))) return false;
	if ((targetPath.includes("~") || decodedPath.includes("~")) && (targetPath.includes("../") || decodedPath.includes("../"))) return false;
	if (/^[a-z]:[/\\]/i.test(decodedPath)) {
		if (process.platform === "win32") return decodedPath.toLowerCase().startsWith(cwd.toLowerCase());
		return false;
	}
	const absoluteTarget = isAbsolute(normalizedTarget) ? normalizedTarget : resolve(normalizedRoot, normalizedTarget);
	const safeRoot = normalizedRoot.endsWith(sep) ? normalizedRoot : normalizedRoot + sep;
	return absoluteTarget === normalizedRoot || absoluteTarget.startsWith(safeRoot);
}

//#endregion
//#region src/utils/updaters/update-css.ts
async function updateCss(css, config, options) {
	if (!config.resolvedPaths.tailwindCss || !css || Object.keys(css).length === 0) return;
	options = {
		silent: false,
		...options
	};
	const cssFilepath = config.resolvedPaths.tailwindCss;
	const cssFilepathRelative = path.relative(config.resolvedPaths.cwd, cssFilepath);
	const cssSpinner = spinner(`Updating ${highlighter.info(cssFilepathRelative)}`, { silent: options.silent }).start();
	let output = await transformCss(await promises.readFile(cssFilepath, "utf8"), css);
	await promises.writeFile(cssFilepath, output, "utf8");
	cssSpinner.succeed();
}
async function transformCss(input, css) {
	const result = await postcss([updateCssPlugin(css)]).process(input, { from: void 0 });
	let output = result.css;
	const root = result.root;
	if (root.nodes && root.nodes.length > 0) {
		const lastNode = root.nodes[root.nodes.length - 1];
		if (lastNode.type === "atrule" && !lastNode.nodes && !output.trimEnd().endsWith(";")) output = `${output.trimEnd()};`;
	}
	output = output.replace(/\/\* ---break--- \*\//g, "");
	output = output.replace(/(\n\s*\n)+/g, "\n\n");
	output = output.trimEnd();
	return output;
}
function updateCssPlugin(css) {
	return {
		postcssPlugin: "update-css",
		Once(root) {
			for (const [selector, properties] of Object.entries(css)) if (selector.startsWith("@")) {
				const atRuleMatch = selector.match(/@([a-z-]+)\s*(.*)/i);
				if (!atRuleMatch) continue;
				const [, name, params] = atRuleMatch;
				if (name === "import") {
					if (!root.nodes?.find((node) => node.type === "atrule" && node.name === "import" && node.params === params)) {
						const importRule = postcss.atRule({
							name: "import",
							params,
							raws: { semicolon: true }
						});
						const importNodes = root.nodes?.filter((node) => node.type === "atrule" && node.name === "import");
						if (importNodes && importNodes.length > 0) {
							const lastImport = importNodes[importNodes.length - 1];
							importRule.raws.before = "\n";
							root.insertAfter(lastImport, importRule);
						} else {
							if (!root.nodes || root.nodes.length === 0) importRule.raws.before = "";
							else importRule.raws.before = "";
							root.prepend(importRule);
						}
					}
				} else if (name === "plugin") {
					let quotedParams = params;
					if (params && !params.startsWith("\"") && !params.startsWith("'")) quotedParams = `"${params}"`;
					const normalizeParams = (p) => {
						if (p.startsWith("\"") && p.endsWith("\"")) return p.slice(1, -1);
						if (p.startsWith("'") && p.endsWith("'")) return p.slice(1, -1);
						return p;
					};
					if (!root.nodes?.find((node) => {
						if (node.type !== "atrule" || node.name !== "plugin") return false;
						return normalizeParams(node.params) === normalizeParams(params);
					})) {
						const pluginRule = postcss.atRule({
							name: "plugin",
							params: quotedParams,
							raws: {
								semicolon: true,
								before: "\n"
							}
						});
						const importNodes = root.nodes?.filter((node) => node.type === "atrule" && node.name === "import");
						const pluginNodes = root.nodes?.filter((node) => node.type === "atrule" && node.name === "plugin");
						if (pluginNodes && pluginNodes.length > 0) {
							const lastPlugin = pluginNodes[pluginNodes.length - 1];
							root.insertAfter(lastPlugin, pluginRule);
						} else if (importNodes && importNodes.length > 0) {
							const lastImport = importNodes[importNodes.length - 1];
							root.insertAfter(lastImport, pluginRule);
							root.insertBefore(pluginRule, postcss.comment({ text: "---break---" }));
							root.insertAfter(pluginRule, postcss.comment({ text: "---break---" }));
						} else {
							root.prepend(pluginRule);
							root.insertBefore(pluginRule, postcss.comment({ text: "---break---" }));
							root.insertAfter(pluginRule, postcss.comment({ text: "---break---" }));
						}
					}
				} else if (typeof properties === "object" && Object.keys(properties).length === 0) {
					if (!root.nodes?.find((node) => node.type === "atrule" && node.name === name && node.params === params)) {
						const newAtRule = postcss.atRule({
							name,
							params,
							raws: { semicolon: true }
						});
						root.append(newAtRule);
						root.insertBefore(newAtRule, postcss.comment({ text: "---break---" }));
					}
				} else if (name === "keyframes") {
					let themeInline = root.nodes?.find((node) => node.type === "atrule" && node.name === "theme" && node.params === "inline");
					if (!themeInline) {
						themeInline = postcss.atRule({
							name: "theme",
							params: "inline",
							raws: {
								semicolon: true,
								between: " ",
								before: "\n"
							}
						});
						root.append(themeInline);
						root.insertBefore(themeInline, postcss.comment({ text: "---break---" }));
					}
					const existingKeyframesRule = themeInline.nodes?.find((node) => node.type === "atrule" && node.name === "keyframes" && node.params === params);
					let keyframesRule;
					if (existingKeyframesRule) {
						keyframesRule = postcss.atRule({
							name: "keyframes",
							params,
							raws: {
								semicolon: true,
								between: " ",
								before: "\n  "
							}
						});
						existingKeyframesRule.replaceWith(keyframesRule);
					} else {
						keyframesRule = postcss.atRule({
							name: "keyframes",
							params,
							raws: {
								semicolon: true,
								between: " ",
								before: "\n  "
							}
						});
						themeInline.append(keyframesRule);
					}
					if (typeof properties === "object") for (const [step, stepProps] of Object.entries(properties)) processRule(keyframesRule, step, stepProps);
				} else if (name === "utility") {
					const utilityAtRule = root.nodes?.find((node) => node.type === "atrule" && node.name === name && node.params === params);
					if (!utilityAtRule) {
						const atRule = postcss.atRule({
							name,
							params,
							raws: {
								semicolon: true,
								between: " ",
								before: "\n"
							}
						});
						root.append(atRule);
						root.insertBefore(atRule, postcss.comment({ text: "---break---" }));
						if (typeof properties === "object") {
							for (const [prop, value] of Object.entries(properties)) if (typeof value === "string") {
								const decl = postcss.decl({
									prop,
									value,
									raws: {
										semicolon: true,
										before: "\n    "
									}
								});
								atRule.append(decl);
							} else if (typeof value === "object") processRule(atRule, prop, value);
						}
					} else if (typeof properties === "object") {
						for (const [prop, value] of Object.entries(properties)) if (typeof value === "string") {
							const existingDecl = utilityAtRule.nodes?.find((node) => node.type === "decl" && node.prop === prop);
							const decl = postcss.decl({
								prop,
								value,
								raws: {
									semicolon: true,
									before: "\n    "
								}
							});
							existingDecl ? existingDecl.replaceWith(decl) : utilityAtRule.append(decl);
						} else if (typeof value === "object") processRule(utilityAtRule, prop, value);
					}
				} else if (name === "property") processRule(root, selector, properties);
				else processAtRule(root, name, params, properties);
			} else processRule(root, selector, properties);
		}
	};
}
function processAtRule(root, name, params, properties) {
	let atRule = root.nodes?.find((node) => node.type === "atrule" && node.name === name && node.params === params);
	if (!atRule) {
		atRule = postcss.atRule({
			name,
			params,
			raws: {
				semicolon: true,
				between: " ",
				before: "\n"
			}
		});
		root.append(atRule);
		root.insertBefore(atRule, postcss.comment({ text: "---break---" }));
	}
	if (typeof properties === "object") for (const [childSelector, childProps] of Object.entries(properties)) if (childSelector.startsWith("@")) {
		const nestedMatch = childSelector.match(/@([a-z-]+)\s*(.*)/i);
		if (nestedMatch) {
			const [, nestedName, nestedParams] = nestedMatch;
			processAtRule(atRule, nestedName, nestedParams, childProps);
		}
	} else processRule(atRule, childSelector, childProps);
	else if (typeof properties === "string") try {
		const tempRule = postcss.parse(`.temp{${properties}}`).first;
		if (tempRule && tempRule.nodes) {
			const rule = postcss.rule({
				selector: "temp",
				raws: {
					semicolon: true,
					between: " ",
					before: "\n  "
				}
			});
			tempRule.nodes.forEach((node) => {
				if (node.type === "decl") {
					const clone = node.clone();
					clone.raws.before = "\n    ";
					rule.append(clone);
				}
			});
			if (rule.nodes?.length) atRule.append(rule);
		}
	} catch (error) {
		console.error("Error parsing at-rule content:", properties, error);
		throw error;
	}
}
function processRule(parent, selector, properties) {
	let rule = parent.nodes?.find((node) => node.type === "rule" && node.selector === selector);
	if (!rule) {
		rule = postcss.rule({
			selector,
			raws: {
				semicolon: true,
				between: " ",
				before: "\n  "
			}
		});
		parent.append(rule);
	}
	if (typeof properties === "object") {
		for (const [prop, value] of Object.entries(properties)) if (prop.startsWith("@") && typeof value === "object" && value !== null && Object.keys(value).length === 0) {
			const atRuleMatch = prop.match(/@([a-z-]+)\s*(.*)/i);
			if (atRuleMatch) {
				const [, atRuleName, atRuleParams] = atRuleMatch;
				const atRule = postcss.atRule({
					name: atRuleName,
					params: atRuleParams,
					raws: {
						semicolon: true,
						before: "\n    "
					}
				});
				rule.append(atRule);
			}
		} else if (typeof value === "string") {
			const decl = postcss.decl({
				prop,
				value,
				raws: {
					semicolon: true,
					before: "\n    "
				}
			});
			const existingDecl = rule.nodes?.find((node) => node.type === "decl" && node.prop === prop);
			existingDecl ? existingDecl.replaceWith(decl) : rule.append(decl);
		} else if (typeof value === "object") processRule(parent, prop.startsWith("&") ? selector.replace(/^([^:]+)/, `$1${prop.substring(1)}`) : prop, value);
	} else if (typeof properties === "string") try {
		const tempRule = postcss.parse(`.temp{${properties}}`).first;
		if (tempRule && tempRule.nodes) tempRule.nodes.forEach((node) => {
			if (node.type === "decl") {
				const clone = node.clone();
				clone.raws.before = "\n    ";
				rule?.append(clone);
			}
		});
	} catch (error) {
		console.error("Error parsing rule content:", selector, properties, error);
		throw error;
	}
}

//#endregion
//#region src/utils/updaters/update-css-vars.ts
async function updateCssVars(cssVars, config, options) {
	if (!config.resolvedPaths.tailwindCss || !Object.keys(cssVars ?? {}).length) return;
	options = {
		cleanupDefaultNextStyles: false,
		silent: false,
		tailwindVersion: "v3",
		overwriteCssVars: false,
		initIndex: true,
		...options
	};
	const cssFilepath = config.resolvedPaths.tailwindCss;
	const cssFilepathRelative = path.relative(config.resolvedPaths.cwd, cssFilepath);
	const cssVarsSpinner = spinner(`Updating CSS variables in ${highlighter.info(cssFilepathRelative)}`, { silent: options.silent }).start();
	const output = await transformCssVars(await promises.readFile(cssFilepath, "utf8"), cssVars ?? {}, config, {
		cleanupDefaultNextStyles: options.cleanupDefaultNextStyles,
		tailwindVersion: options.tailwindVersion,
		tailwindConfig: options.tailwindConfig,
		overwriteCssVars: options.overwriteCssVars,
		initIndex: options.initIndex
	});
	await promises.writeFile(cssFilepath, output, "utf8");
	cssVarsSpinner.succeed();
}
async function transformCssVars(input, cssVars, config, options = {
	cleanupDefaultNextStyles: false,
	tailwindVersion: "v3",
	tailwindConfig: void 0,
	overwriteCssVars: false,
	initIndex: true
}) {
	options = {
		cleanupDefaultNextStyles: false,
		tailwindVersion: "v3",
		tailwindConfig: void 0,
		overwriteCssVars: false,
		initIndex: true,
		...options
	};
	let plugins = [updateCssVarsPlugin(cssVars)];
	if (options.cleanupDefaultNextStyles) plugins.push(cleanupDefaultNextStylesPlugin());
	if (options.tailwindVersion === "v4") {
		plugins = [];
		if (config.resolvedPaths?.cwd) {
			const packageInfo = getPackageInfo(config.resolvedPaths.cwd);
			if (!packageInfo?.dependencies?.["tailwindcss-animate"] && !packageInfo?.devDependencies?.["tailwindcss-animate"] && options.initIndex) plugins.push(addCustomImport({ params: "tw-animate-css" }));
		}
		plugins.push(addCustomVariant({ params: "dark (&:is(.dark *))" }));
		if (options.cleanupDefaultNextStyles) plugins.push(cleanupDefaultNextStylesPlugin());
		plugins.push(updateCssVarsPluginV4(cssVars, { overwriteCssVars: options.overwriteCssVars }));
		plugins.push(updateThemePlugin(cssVars));
		if (options.tailwindConfig) {
			plugins.push(updateTailwindConfigPlugin(options.tailwindConfig));
			plugins.push(updateTailwindConfigAnimationPlugin(options.tailwindConfig));
			plugins.push(updateTailwindConfigKeyframesPlugin(options.tailwindConfig));
		}
	}
	if (config.tailwind.cssVariables && options.initIndex) plugins.push(updateBaseLayerPlugin({ tailwindVersion: options.tailwindVersion }));
	let output = (await postcss(plugins).process(input, { from: void 0 })).css;
	output = output.replace(/\/\* ---break--- \*\//g, "");
	if (options.tailwindVersion === "v4") output = output.replace(/(\n\s*\n)+/g, "\n\n");
	return output;
}
function updateBaseLayerPlugin({ tailwindVersion }) {
	return {
		postcssPlugin: "update-base-layer",
		Once(root) {
			const requiredRules = [{
				selector: "*",
				apply: tailwindVersion === "v4" ? "border-border outline-ring/50" : "border-border"
			}, {
				selector: "body",
				apply: "bg-background text-foreground"
			}];
			let baseLayer = root.nodes.find((node) => node.type === "atrule" && node.name === "layer" && node.params === "base" && requiredRules.every(({ selector, apply }) => node.nodes?.some((rule) => rule.type === "rule" && rule.selector === selector && rule.nodes.some((applyRule) => applyRule.type === "atrule" && applyRule.name === "apply" && applyRule.params === apply))));
			if (!baseLayer) {
				baseLayer = postcss.atRule({
					name: "layer",
					params: "base",
					raws: {
						semicolon: true,
						between: " ",
						before: "\n"
					}
				});
				root.append(baseLayer);
				root.insertBefore(baseLayer, postcss.comment({ text: "---break---" }));
			}
			requiredRules.forEach(({ selector, apply }) => {
				if (!baseLayer?.nodes?.find((node) => node.type === "rule" && node.selector === selector)) baseLayer?.append(postcss.rule({
					selector,
					nodes: [postcss.atRule({
						name: "apply",
						params: apply,
						raws: {
							semicolon: true,
							before: "\n    "
						}
					})],
					raws: {
						semicolon: true,
						between: " ",
						before: "\n  "
					}
				}));
			});
		}
	};
}
function updateCssVarsPlugin(cssVars) {
	return {
		postcssPlugin: "update-css-vars",
		Once(root) {
			let baseLayer = root.nodes.find((node) => node.type === "atrule" && node.name === "layer" && node.params === "base");
			if (!(baseLayer instanceof AtRule)) {
				baseLayer = postcss.atRule({
					name: "layer",
					params: "base",
					nodes: [],
					raws: {
						semicolon: true,
						before: "\n",
						between: " "
					}
				});
				root.append(baseLayer);
				root.insertBefore(baseLayer, postcss.comment({ text: "---break---" }));
			}
			if (baseLayer !== void 0) Object.entries(cssVars).forEach(([key, vars]) => {
				const selector = key === "light" ? ":root" : `.${key}`;
				addOrUpdateVars(baseLayer, selector, vars);
			});
		}
	};
}
function removeConflictVars(root) {
	const rootRule = root.nodes.find((node) => node.type === "rule" && node.selector === ":root");
	if (rootRule) {
		const propsToRemove = ["--background", "--foreground"];
		rootRule.nodes.filter((node) => node.type === "decl" && propsToRemove.includes(node.prop)).forEach((node) => node.remove());
		if (rootRule.nodes.length === 0) rootRule.remove();
	}
}
function cleanupDefaultNextStylesPlugin() {
	return {
		postcssPlugin: "cleanup-default-next-styles",
		Once(root) {
			const bodyRule = root.nodes.find((node) => node.type === "rule" && node.selector === "body");
			if (bodyRule) {
				bodyRule.nodes.find((node) => node.type === "decl" && node.prop === "color" && ["rgb(var(--foreground-rgb))", "var(--foreground)"].includes(node.value))?.remove();
				bodyRule.nodes.find((node) => {
					return node.type === "decl" && node.prop === "background" && (node.value.startsWith("linear-gradient") || node.value === "var(--background)");
				})?.remove();
				bodyRule.nodes.find((node) => node.type === "decl" && node.prop === "font-family" && node.value === "Arial, Helvetica, sans-serif")?.remove();
				if (bodyRule.nodes.length === 0) bodyRule.remove();
			}
			removeConflictVars(root);
			const darkRootRule = root.nodes.find((node) => node.type === "atrule" && node.params === "(prefers-color-scheme: dark)");
			if (darkRootRule) {
				removeConflictVars(darkRootRule);
				if (darkRootRule.nodes.length === 0) darkRootRule.remove();
			}
		}
	};
}
function addOrUpdateVars(baseLayer, selector, vars) {
	let ruleNode = baseLayer.nodes?.find((node) => node.type === "rule" && node.selector === selector);
	if (!ruleNode) {
		if (Object.keys(vars).length > 0) {
			ruleNode = postcss.rule({
				selector,
				raws: {
					between: " ",
					before: "\n  "
				}
			});
			baseLayer.append(ruleNode);
		}
	}
	Object.entries(vars).forEach(([key, value]) => {
		const prop = `--${key.replace(/^--/, "")}`;
		const newDecl = postcss.decl({
			prop,
			value,
			raws: { semicolon: true }
		});
		const existingDecl = ruleNode?.nodes.find((node) => node.type === "decl" && node.prop === prop);
		existingDecl ? existingDecl.replaceWith(newDecl) : ruleNode?.append(newDecl);
	});
}
function updateCssVarsPluginV4(cssVars, options) {
	return {
		postcssPlugin: "update-css-vars-v4",
		Once(root) {
			Object.entries(cssVars).forEach(([key, vars]) => {
				let selector = key === "light" ? ":root" : `.${key}`;
				if (key === "theme") {
					selector = "@theme";
					const themeNode = upsertThemeNode(root);
					Object.entries(vars).forEach(([key$1, value]) => {
						const prop = `--${key$1.replace(/^--/, "")}`;
						const newDecl = postcss.decl({
							prop,
							value,
							raws: { semicolon: true }
						});
						const existingDecl = themeNode?.nodes?.find((node) => node.type === "decl" && node.prop === prop);
						if (options.overwriteCssVars) if (existingDecl) existingDecl.replaceWith(newDecl);
						else themeNode?.append(newDecl);
						else if (!existingDecl) themeNode?.append(newDecl);
					});
					return;
				}
				let ruleNode = root.nodes?.find((node) => node.type === "rule" && node.selector === selector);
				if (!ruleNode && Object.keys(vars).length > 0) {
					ruleNode = postcss.rule({
						selector,
						nodes: [],
						raws: {
							semicolon: true,
							between: " ",
							before: "\n"
						}
					});
					root.append(ruleNode);
					root.insertBefore(ruleNode, postcss.comment({ text: "---break---" }));
				}
				Object.entries(vars).forEach(([key$1, value]) => {
					let prop = `--${key$1.replace(/^--/, "")}`;
					if (prop === "--sidebar-background") prop = "--sidebar";
					if (isLocalHSLValue(value)) value = `hsl(${value})`;
					const newDecl = postcss.decl({
						prop,
						value,
						raws: { semicolon: true }
					});
					const existingDecl = ruleNode?.nodes.find((node) => node.type === "decl" && node.prop === prop);
					if (options.overwriteCssVars) if (existingDecl) existingDecl.replaceWith(newDecl);
					else ruleNode?.append(newDecl);
					else if (!existingDecl) ruleNode?.append(newDecl);
				});
			});
		}
	};
}
function updateThemePlugin(cssVars) {
	return {
		postcssPlugin: "update-theme",
		Once(root) {
			const variables = Array.from(new Set(Object.keys(cssVars).flatMap((key) => Object.keys(cssVars[key] || {}))));
			if (!variables.length) return;
			const themeNode = upsertThemeNode(root);
			const themeVarNodes = themeNode.nodes?.filter((node) => node.type === "decl" && node.prop.startsWith("--"));
			for (const variable of variables) {
				const value = Object.values(cssVars).find((vars) => vars[variable])?.[variable];
				if (!value) continue;
				if (variable === "radius") {
					for (const [key, value$1] of Object.entries({
						sm: "calc(var(--radius) - 4px)",
						md: "calc(var(--radius) - 2px)",
						lg: "var(--radius)",
						xl: "calc(var(--radius) + 4px)"
					})) {
						const cssVarNode$1 = postcss.decl({
							prop: `--radius-${key}`,
							value: value$1,
							raws: { semicolon: true }
						});
						if (themeNode?.nodes?.find((node) => node.type === "decl" && node.prop === cssVarNode$1.prop)) continue;
						themeNode?.append(cssVarNode$1);
					}
					continue;
				}
				let prop = isLocalHSLValue(value) || isColorValue(value) ? `--color-${variable.replace(/^--/, "")}` : `--${variable.replace(/^--/, "")}`;
				if (prop === "--color-sidebar-background") prop = "--color-sidebar";
				let propValue = `var(--${variable})`;
				if (prop === "--color-sidebar") propValue = "var(--sidebar)";
				const cssVarNode = postcss.decl({
					prop,
					value: propValue,
					raws: { semicolon: true }
				});
				if (!themeNode?.nodes?.find((node) => node.type === "decl" && node.prop === cssVarNode.prop)) if (themeVarNodes?.length) themeNode?.insertAfter(themeVarNodes[themeVarNodes.length - 1], cssVarNode);
				else themeNode?.append(cssVarNode);
			}
		}
	};
}
function upsertThemeNode(root) {
	let themeNode = root.nodes.find((node) => node.type === "atrule" && node.name === "theme" && node.params === "inline");
	if (!themeNode) {
		themeNode = postcss.atRule({
			name: "theme",
			params: "inline",
			nodes: [],
			raws: {
				semicolon: true,
				between: " ",
				before: "\n"
			}
		});
		root.append(themeNode);
		root.insertBefore(themeNode, postcss.comment({ text: "---break---" }));
	}
	return themeNode;
}
function addCustomVariant({ params }) {
	return {
		postcssPlugin: "add-custom-variant",
		Once(root) {
			if (!root.nodes.find((node) => node.type === "atrule" && node.name === "custom-variant")) {
				const importNodes = root.nodes.filter((node) => node.type === "atrule" && node.name === "import");
				const variantNode = postcss.atRule({
					name: "custom-variant",
					params,
					raws: {
						semicolon: true,
						before: "\n"
					}
				});
				if (importNodes.length > 0) {
					const lastImport = importNodes[importNodes.length - 1];
					root.insertAfter(lastImport, variantNode);
				} else root.insertAfter(root.nodes[0], variantNode);
				root.insertBefore(variantNode, postcss.comment({ text: "---break---" }));
			}
		}
	};
}
function addCustomImport({ params }) {
	return {
		postcssPlugin: "add-custom-import",
		Once(root) {
			const importNodes = root.nodes.filter((node) => node.type === "atrule" && node.name === "import");
			const customVariantNode = root.nodes.find((node) => node.type === "atrule" && node.name === "custom-variant");
			if (!importNodes.some((node) => node.params.replace(/["']/g, "") === params)) {
				const importNode = postcss.atRule({
					name: "import",
					params: `"${params}"`,
					raws: {
						semicolon: true,
						before: "\n"
					}
				});
				if (importNodes.length > 0) {
					const lastImport = importNodes[importNodes.length - 1];
					root.insertAfter(lastImport, importNode);
				} else if (customVariantNode) {
					root.insertBefore(customVariantNode, importNode);
					root.insertBefore(customVariantNode, postcss.comment({ text: "---break---" }));
				} else {
					root.prepend(importNode);
					root.insertAfter(importNode, postcss.comment({ text: "---break---" }));
				}
			}
		}
	};
}
function updateTailwindConfigPlugin(tailwindConfig) {
	return {
		postcssPlugin: "update-tailwind-config",
		Once(root) {
			if (!tailwindConfig?.plugins) return;
			const quote = getQuoteType(root) === "single" ? "'" : "\"";
			const pluginNodes = root.nodes.filter((node) => node.type === "atrule" && node.name === "plugin");
			const lastPluginNode = pluginNodes[pluginNodes.length - 1] || root.nodes[0];
			for (const plugin of tailwindConfig.plugins) {
				const pluginName = plugin.replace(/^require\(["']|["']\)$/g, "");
				if (pluginNodes.some((node) => {
					return node.params.replace(/["']/g, "") === pluginName;
				})) continue;
				const pluginNode = postcss.atRule({
					name: "plugin",
					params: `${quote}${pluginName}${quote}`,
					raws: {
						semicolon: true,
						before: "\n"
					}
				});
				root.insertAfter(lastPluginNode, pluginNode);
				root.insertBefore(pluginNode, postcss.comment({ text: "---break---" }));
			}
		}
	};
}
function updateTailwindConfigKeyframesPlugin(tailwindConfig) {
	return {
		postcssPlugin: "update-tailwind-config-keyframes",
		Once(root) {
			if (!tailwindConfig?.theme?.extend?.keyframes) return;
			const themeNode = upsertThemeNode(root);
			const existingKeyFrameNodes = themeNode.nodes?.filter((node) => node.type === "atrule" && node.name === "keyframes");
			const keyframeValueSchema = z.record(z.string(), z.record(z.string(), z.string()));
			for (const [keyframeName, keyframeValue] of Object.entries(tailwindConfig.theme.extend.keyframes)) {
				if (typeof keyframeName !== "string") continue;
				const parsedKeyframeValue = keyframeValueSchema.safeParse(keyframeValue);
				if (!parsedKeyframeValue.success) continue;
				if (existingKeyFrameNodes?.find((node) => node.type === "atrule" && node.name === "keyframes" && node.params === keyframeName)) continue;
				const keyframeNode = postcss.atRule({
					name: "keyframes",
					params: keyframeName,
					nodes: [],
					raws: {
						semicolon: true,
						between: " ",
						before: "\n  "
					}
				});
				for (const [key, values] of Object.entries(parsedKeyframeValue.data)) {
					const rule = postcss.rule({
						selector: key,
						nodes: Object.entries(values).map(([key$1, value]) => postcss.decl({
							prop: key$1,
							value,
							raws: {
								semicolon: true,
								before: "\n      ",
								between: ": "
							}
						})),
						raws: {
							semicolon: true,
							between: " ",
							before: "\n    "
						}
					});
					keyframeNode.append(rule);
				}
				themeNode.append(keyframeNode);
				themeNode.insertBefore(keyframeNode, postcss.comment({ text: "---break---" }));
			}
		}
	};
}
function updateTailwindConfigAnimationPlugin(tailwindConfig) {
	return {
		postcssPlugin: "update-tailwind-config-animation",
		Once(root) {
			if (!tailwindConfig?.theme?.extend?.animation) return;
			const themeNode = upsertThemeNode(root);
			const existingAnimationNodes = themeNode.nodes?.filter((node) => node.type === "decl" && node.prop.startsWith("--animate-"));
			const parsedAnimationValue = z.record(z.string(), z.string()).safeParse(tailwindConfig.theme.extend.animation);
			if (!parsedAnimationValue.success) return;
			for (const [key, value] of Object.entries(parsedAnimationValue.data)) {
				const prop = `--animate-${key}`;
				if (existingAnimationNodes?.find((node) => node.prop === prop)) continue;
				const animationNode = postcss.decl({
					prop,
					value,
					raws: {
						semicolon: true,
						between: ": ",
						before: "\n  "
					}
				});
				themeNode.append(animationNode);
			}
		}
	};
}
function getQuoteType(root) {
	if (root.nodes[0].toString().includes("'")) return "single";
	return "double";
}
function isLocalHSLValue(value) {
	if (value.startsWith("hsl") || value.startsWith("rgb") || value.startsWith("#") || value.startsWith("oklch")) return false;
	const chunks = value.split(" ");
	return chunks.length === 3 && chunks.slice(1, 3).every((chunk) => chunk.includes("%"));
}
function isColorValue(value) {
	return value.startsWith("hsl") || value.startsWith("rgb") || value.startsWith("#") || value.startsWith("oklch") || value.includes("var(--color-");
}

//#endregion
//#region src/utils/updaters/update-dependencies.ts
async function updateDependencies(dependencies, devDependencies, config, options) {
	dependencies = Array.from(new Set(dependencies));
	devDependencies = Array.from(new Set(devDependencies));
	if (!dependencies?.length && !devDependencies?.length) return;
	options = {
		silent: false,
		...options
	};
	const dependenciesSpinner = spinner(`Installing dependencies.`, { silent: options.silent })?.start();
	dependenciesSpinner?.start();
	if (dependencies?.length) await addDependency(dependencies, {
		cwd: config.resolvedPaths.cwd,
		silent: true,
		dev: false
	});
	if (devDependencies?.length) await addDependency(devDependencies, {
		cwd: config.resolvedPaths.cwd,
		silent: true,
		dev: true
	});
	dependenciesSpinner?.succeed();
}

//#endregion
//#region src/utils/updaters/update-env-vars.ts
async function updateEnvVars(envVars, config, options) {
	if (!envVars || Object.keys(envVars).length === 0) return {
		envVarsAdded: [],
		envFileUpdated: null,
		envFileCreated: null
	};
	options = {
		silent: false,
		...options
	};
	const envSpinner = spinner(`Adding environment variables.`, { silent: options.silent })?.start();
	const projectRoot = config.resolvedPaths.cwd;
	let envFilePath = path.join(projectRoot, ".env.local");
	const existingEnvFile = findExistingEnvFile(projectRoot);
	if (existingEnvFile) envFilePath = existingEnvFile;
	const envFileExists = existsSync(envFilePath);
	const envFileName = path.basename(envFilePath);
	const newEnvContent = Object.entries(envVars).map(([key, value]) => `${key}=${value}`).join("\n");
	let envVarsAdded = [];
	let envFileUpdated = null;
	let envFileCreated = null;
	if (envFileExists) {
		const existingContent = await promises.readFile(envFilePath, "utf-8");
		const mergedContent = mergeEnvContent(existingContent, newEnvContent);
		envVarsAdded = getNewEnvKeys(existingContent, newEnvContent);
		if (envVarsAdded.length > 0) {
			await promises.writeFile(envFilePath, mergedContent, "utf-8");
			envFileUpdated = path.relative(projectRoot, envFilePath);
			envSpinner?.succeed(`Added the following variables to ${highlighter.info(envFileName)}:`);
			if (!options.silent) for (const key of envVarsAdded) logger.log(`  ${highlighter.success("+")} ${key}`);
		} else envSpinner?.stop();
	} else {
		await promises.writeFile(envFilePath, `${newEnvContent}\n`, "utf-8");
		envFileCreated = path.relative(projectRoot, envFilePath);
		envVarsAdded = Object.keys(envVars);
		envSpinner?.succeed(`Added the following variables to ${highlighter.info(envFileName)}:`);
		if (!options.silent) for (const key of envVarsAdded) logger.log(`  ${highlighter.success("+")} ${key}`);
	}
	if (!options.silent && envVarsAdded.length > 0) logger.break();
	return {
		envVarsAdded,
		envFileUpdated,
		envFileCreated
	};
}

//#endregion
//#region src/utils/add-components.ts
async function addComponents(components, config, options) {
	options = {
		overwrite: false,
		silent: false,
		isNewProject: false,
		baseStyle: true,
		...options
	};
	const workspaceConfig = await getWorkspaceConfig(config);
	if (workspaceConfig && workspaceConfig.ui && workspaceConfig.ui.resolvedPaths.cwd !== config.resolvedPaths.cwd) return await addWorkspaceComponents(components, config, workspaceConfig, {
		...options,
		isRemote: components?.length === 1 && !!components[0].match(/\/chat\/b\//)
	});
	return await addProjectComponents(components, config, options);
}
async function addProjectComponents(components, config, options) {
	if (!options.baseStyle && !components.length) return;
	const registrySpinner = spinner(`Checking registry.`, { silent: options.silent })?.start();
	const tree = await resolveRegistryTree(components, configWithDefaults(config));
	if (!tree) {
		registrySpinner?.fail();
		return handleError(/* @__PURE__ */ new Error("Failed to fetch components from registry."));
	}
	try {
		validateFilesTarget(tree.files ?? [], config.resolvedPaths.cwd);
	} catch (error) {
		registrySpinner?.fail();
		return handleError(error);
	}
	registrySpinner?.succeed();
	const tailwindVersion = await getProjectTailwindVersionFromConfig(config);
	await updateTailwindConfig(tree.tailwind?.config, config, {
		silent: options.silent,
		tailwindVersion
	});
	const overwriteCssVars = await shouldOverwriteCssVars(components, config);
	await updateCssVars(tree.cssVars, config, {
		cleanupDefaultNextStyles: options.isNewProject,
		silent: options.silent,
		tailwindVersion,
		tailwindConfig: tree.tailwind?.config,
		overwriteCssVars,
		initIndex: options.baseStyle
	});
	await updateCss(tree.css, config, { silent: options.silent });
	await updateEnvVars(tree.envVars, config, { silent: options.silent });
	await updateDependencies(tree.dependencies, tree.devDependencies, config, { silent: options.silent });
	await updateFiles(tree.files, config, {
		overwrite: options.overwrite,
		silent: options.silent,
		path: options.path
	});
	if (tree.docs) logger.info(tree.docs);
}
async function addWorkspaceComponents(components, config, workspaceConfig, options) {
	if (!options.baseStyle && !components.length) return;
	const registrySpinner = spinner(`Checking registry.`, { silent: options.silent })?.start();
	const tree = await resolveRegistryTree(components, configWithDefaults(config));
	if (!tree) {
		registrySpinner?.fail();
		return handleError(/* @__PURE__ */ new Error("Failed to fetch components from registry."));
	}
	try {
		validateFilesTarget(tree.files ?? [], config.resolvedPaths.cwd);
	} catch (error) {
		registrySpinner?.fail();
		return handleError(error);
	}
	registrySpinner?.succeed();
	const filesCreated = [];
	const filesUpdated = [];
	const filesSkipped = [];
	const rootSpinner = spinner(`Installing components.`)?.start();
	const mainTargetConfig = workspaceConfig.ui;
	const tailwindVersion = await getProjectTailwindVersionFromConfig(mainTargetConfig);
	const workspaceRoot = findCommonRoot(config.resolvedPaths.cwd, mainTargetConfig.resolvedPaths.ui);
	if (tree.tailwind?.config) {
		await updateTailwindConfig(tree.tailwind?.config, mainTargetConfig, {
			silent: true,
			tailwindVersion
		});
		filesUpdated.push(path.relative(workspaceRoot, mainTargetConfig.resolvedPaths.tailwindConfig));
	}
	if (tree.cssVars) {
		const overwriteCssVars = await shouldOverwriteCssVars(components, config);
		await updateCssVars(tree.cssVars, mainTargetConfig, {
			silent: true,
			tailwindVersion,
			tailwindConfig: tree.tailwind?.config,
			overwriteCssVars
		});
		filesUpdated.push(path.relative(workspaceRoot, mainTargetConfig.resolvedPaths.tailwindCss));
	}
	if (tree.css) {
		await updateCss(tree.css, mainTargetConfig, { silent: true });
		filesUpdated.push(path.relative(workspaceRoot, mainTargetConfig.resolvedPaths.tailwindCss));
	}
	if (tree.envVars) await updateEnvVars(tree.envVars, mainTargetConfig, { silent: true });
	await updateDependencies(tree.dependencies, tree.devDependencies, mainTargetConfig, { silent: true });
	const filesByType = /* @__PURE__ */ new Map();
	for (const file of tree.files ?? []) {
		const type = file.type || "registry:ui";
		if (!filesByType.has(type)) filesByType.set(type, []);
		filesByType.get(type).push(file);
	}
	for (const type of Array.from(filesByType.keys())) {
		const typeFiles = filesByType.get(type);
		let targetConfig = type === "registry:ui" ? workspaceConfig.ui : config;
		const typeWorkspaceRoot = findCommonRoot(config.resolvedPaths.cwd, targetConfig.resolvedPaths.ui || targetConfig.resolvedPaths.cwd);
		const packageRoot = await findPackageRoot(typeWorkspaceRoot, targetConfig.resolvedPaths.cwd) ?? targetConfig.resolvedPaths.cwd;
		const files = await updateFiles(typeFiles, targetConfig, {
			overwrite: options.overwrite,
			silent: true,
			rootSpinner,
			isRemote: options.isRemote,
			isWorkspace: true,
			path: options.path
		});
		filesCreated.push(...files.filesCreated.map((file) => path.relative(typeWorkspaceRoot, path.join(packageRoot, file))));
		filesUpdated.push(...files.filesUpdated.map((file) => path.relative(typeWorkspaceRoot, path.join(packageRoot, file))));
		filesSkipped.push(...files.filesSkipped.map((file) => path.relative(typeWorkspaceRoot, path.join(packageRoot, file))));
	}
	rootSpinner?.succeed();
	filesCreated.sort();
	filesUpdated.sort();
	filesSkipped.sort();
	if (!(filesCreated.length || filesUpdated.length) && !filesSkipped.length) spinner(`No files updated.`, { silent: options.silent })?.info();
	if (filesCreated.length) {
		spinner(`Created ${filesCreated.length} ${filesCreated.length === 1 ? "file" : "files"}:`, { silent: options.silent })?.succeed();
		for (const file of filesCreated) logger.log(`  - ${file}`);
	}
	if (filesUpdated.length) {
		spinner(`Updated ${filesUpdated.length} ${filesUpdated.length === 1 ? "file" : "files"}:`, { silent: options.silent })?.info();
		for (const file of filesUpdated) logger.log(`  - ${file}`);
	}
	if (filesSkipped.length) {
		spinner(`Skipped ${filesSkipped.length} ${filesUpdated.length === 1 ? "file" : "files"}: (use --overwrite to overwrite)`, { silent: options.silent })?.info();
		for (const file of filesSkipped) logger.log(`  - ${file}`);
	}
	if (tree.docs) logger.info(tree.docs);
}
async function shouldOverwriteCssVars(components, config) {
	const result = await getRegistryItems(components, { config });
	return z.array(registryItemSchema).parse(result).some((component) => component.type === "registry:theme" || component.type === "registry:style");
}
function validateFilesTarget(files, cwd) {
	for (const file of files) {
		if (!file?.target) continue;
		if (!isSafeTarget(file.target, cwd)) throw new Error(`We found an unsafe file path "${file.target} in the registry item. Installation aborted.`);
	}
}

//#endregion
//#region src/utils/env-loader.ts
async function loadEnvFiles(cwd = process.cwd()) {
	try {
		const { config } = await import("@dotenvx/dotenvx");
		for (const envFile of [
			".env.local",
			".env.development.local",
			".env.development",
			".env"
		]) {
			const envPath = join(cwd, envFile);
			if (existsSync(envPath)) config({
				path: envPath,
				overload: false,
				quiet: true
			});
		}
	} catch (error) {
		logger.warn("Failed to load env files:", error);
	}
}

//#endregion
//#region src/utils/file-helper.ts
const FILE_BACKUP_SUFFIX = ".bak";
function createFileBackup(filePath) {
	if (!fsExtra.existsSync(filePath)) return null;
	const backupPath = `${filePath}${FILE_BACKUP_SUFFIX}`;
	try {
		fsExtra.renameSync(filePath, backupPath);
		return backupPath;
	} catch (error) {
		console.error(`Failed to create backup of ${filePath}: ${error}`);
		return null;
	}
}
function restoreFileBackup(filePath) {
	const backupPath = `${filePath}${FILE_BACKUP_SUFFIX}`;
	if (!fsExtra.existsSync(backupPath)) return false;
	try {
		fsExtra.renameSync(backupPath, filePath);
		return true;
	} catch (error) {
		console.error(`Warning: Could not restore backup file ${backupPath}: ${error}`);
		return false;
	}
}
function deleteFileBackup(filePath) {
	const backupPath = `${filePath}${FILE_BACKUP_SUFFIX}`;
	if (!fsExtra.existsSync(backupPath)) return false;
	try {
		fsExtra.unlinkSync(backupPath);
		return true;
	} catch (error) {
		return false;
	}
}

//#endregion
//#region src/registry/namespaces.ts
async function resolveRegistryNamespaces(components, config) {
	const discoveredNamespaces = /* @__PURE__ */ new Set();
	const visitedItems = /* @__PURE__ */ new Set();
	const itemsToProcess = [...components];
	while (itemsToProcess.length > 0) {
		const currentItem = itemsToProcess.shift();
		if (visitedItems.has(currentItem)) continue;
		visitedItems.add(currentItem);
		const { registry } = parseRegistryAndItemFromString(currentItem);
		if (registry && !BUILTIN_REGISTRIES[registry]) discoveredNamespaces.add(registry);
		try {
			const [item] = await fetchRegistryItems([currentItem], config, { useCache: true });
			if (item?.registryDependencies) for (const dep of item.registryDependencies) {
				const { registry: depRegistry } = parseRegistryAndItemFromString(dep);
				if (depRegistry && !BUILTIN_REGISTRIES[depRegistry]) discoveredNamespaces.add(depRegistry);
				if (!visitedItems.has(dep)) itemsToProcess.push(dep);
			}
		} catch (error) {
			if (error instanceof RegistryNotConfiguredError) {
				const { registry: registry$1 } = parseRegistryAndItemFromString(currentItem);
				if (registry$1 && !BUILTIN_REGISTRIES[registry$1]) discoveredNamespaces.add(registry$1);
				continue;
			}
			continue;
		}
	}
	return Array.from(discoveredNamespaces);
}

//#endregion
//#region src/utils/registries.ts
async function ensureRegistriesInConfig(components, config, options = {}) {
	options = {
		silent: false,
		writeFile: true,
		...options
	};
	const missingRegistries = (await resolveRegistryNamespaces(components, config)).filter((registry) => !config.registries?.[registry] && !Object.keys(BUILTIN_REGISTRIES).includes(registry));
	if (missingRegistries.length === 0) return {
		config,
		newRegistries: []
	};
	const registryIndex = await getRegistriesIndex({ useCache: process.env.NODE_ENV !== "development" });
	if (!registryIndex) return {
		config,
		newRegistries: []
	};
	const foundRegistries = {};
	for (const registry of missingRegistries) if (registryIndex[registry]) foundRegistries[registry] = registryIndex[registry];
	if (Object.keys(foundRegistries).length === 0) return {
		config,
		newRegistries: []
	};
	const existingRegistries = Object.fromEntries(Object.entries(config.registries || {}).filter(([key]) => !Object.keys(BUILTIN_REGISTRIES).includes(key)));
	const newConfigWithRegistries = {
		...config,
		registries: {
			...existingRegistries,
			...foundRegistries
		}
	};
	if (options.writeFile) {
		const { resolvedPaths, ...configWithoutResolvedPaths } = newConfigWithRegistries;
		const configSpinner = spinner("Updating components.json.", { silent: options.silent }).start();
		const updatedConfig = rawConfigSchema.parse(configWithoutResolvedPaths);
		await fsExtra.writeFile(path.resolve(config.resolvedPaths.cwd, "components.json"), `${JSON.stringify(updatedConfig, null, 2)}\n`, "utf-8");
		configSpinner.succeed();
	}
	return {
		config: newConfigWithRegistries,
		newRegistries: Object.keys(foundRegistries)
	};
}

//#endregion
//#region src/utils/updaters/update-tailwind-content.ts
async function updateTailwindContent(content, config, options) {
	if (!content) return;
	options = {
		silent: false,
		...options
	};
	const tailwindFileRelativePath = path.relative(config.resolvedPaths.cwd, config.resolvedPaths.tailwindConfig);
	const tailwindSpinner = spinner(`Updating ${highlighter.info(tailwindFileRelativePath)}`, { silent: options.silent }).start();
	const output = await transformTailwindContent(await promises.readFile(config.resolvedPaths.tailwindConfig, "utf8"), content, config);
	await promises.writeFile(config.resolvedPaths.tailwindConfig, output, "utf8");
	tailwindSpinner?.succeed();
}
async function transformTailwindContent(input, content, config) {
	const sourceFile = await _createSourceFile(input, config);
	const configObject = sourceFile.getDescendantsOfKind(SyntaxKind.ObjectLiteralExpression).find((node) => node.getProperties().some((property) => property.isKind(SyntaxKind.PropertyAssignment) && property.getName() === "content"));
	if (!configObject) return input;
	addTailwindConfigContent(configObject, content);
	return sourceFile.getFullText();
}
async function addTailwindConfigContent(configObject, content) {
	const quoteChar = _getQuoteChar(configObject);
	const existingProperty = configObject.getProperty("content");
	if (!existingProperty) {
		const newProperty = {
			name: "content",
			initializer: `[${quoteChar}${content.join(`${quoteChar}, ${quoteChar}`)}${quoteChar}]`
		};
		configObject.addPropertyAssignment(newProperty);
		return configObject;
	}
	if (existingProperty.isKind(SyntaxKind.PropertyAssignment)) {
		const initializer = existingProperty.getInitializer();
		if (initializer?.isKind(SyntaxKind.ArrayLiteralExpression)) for (const contentItem of content) {
			const newValue = `${quoteChar}${contentItem}${quoteChar}`;
			if (initializer.getElements().map((element) => element.getText()).includes(newValue)) continue;
			initializer.addElement(newValue);
		}
		return configObject;
	}
	return configObject;
}

//#endregion
//#region src/commands/init.ts
process.on("exit", (code) => {
	const filePath = path.resolve(process.cwd(), "components.json");
	if (code === 0) return deleteFileBackup(filePath);
	return restoreFileBackup(filePath);
});
const initOptionsSchema = z.object({
	cwd: z.string(),
	components: z.array(z.string()).optional(),
	yes: z.boolean(),
	defaults: z.boolean(),
	force: z.boolean(),
	silent: z.boolean(),
	isNewProject: z.boolean(),
	srcDir: z.boolean().optional(),
	cssVariables: z.boolean(),
	baseColor: z.string().optional().refine((val) => {
		if (val) return BASE_COLORS.find((color) => color.name === val);
		return true;
	}, { message: `Invalid base color. Please use '${BASE_COLORS.map((color) => color.name).join("', '")}'` }),
	baseStyle: z.boolean()
});
const init = new Command().name("init").description("initialize your project and install dependencies").argument("[components...]", "names, url or local path to component").option("-b, --base-color <base-color>", "the base color to use. (neutral, gray, zinc, stone, slate)", void 0).option("-y, --yes", "skip confirmation prompt.", true).option("-d, --defaults,", "use default configuration.", false).option("-f, --force", "force overwrite of existing configuration.", false).option("-c, --cwd <cwd>", "the working directory. defaults to the current directory.", process.cwd()).option("-s, --silent", "mute output.", false).option("--css-variables", "use css variables for theming.", true).option("--no-css-variables", "do not use css variables for theming.").option("--no-base-style", "do not install the base shadcn style.").action(async (components, opts) => {
	try {
		if (opts.defaults) {
			opts.template = opts.template || "next";
			opts.baseColor = opts.baseColor || "neutral";
		}
		const options = initOptionsSchema.parse({
			cwd: path.resolve(opts.cwd),
			isNewProject: false,
			components,
			...opts
		});
		await loadEnvFiles(options.cwd);
		if (components.length > 0) {
			let shadowConfig = configWithDefaults(createConfig({ resolvedPaths: { cwd: options.cwd } }));
			const componentsJsonPath = path.resolve(options.cwd, "components.json");
			if (fsExtra.existsSync(componentsJsonPath)) {
				const existingConfig = await fsExtra.readJson(componentsJsonPath);
				const config = rawConfigSchema.partial().parse(existingConfig);
				const baseConfig = createConfig({ resolvedPaths: { cwd: options.cwd } });
				shadowConfig = configWithDefaults({
					...config,
					resolvedPaths: {
						...baseConfig.resolvedPaths,
						cwd: options.cwd
					}
				});
				createFileBackup(componentsJsonPath);
			}
			const { config: updatedConfig } = await ensureRegistriesInConfig(components, shadowConfig, {
				silent: true,
				writeFile: false
			});
			shadowConfig = updatedConfig;
			buildUrlAndHeadersForRegistryItem(components[0], shadowConfig);
			const [item] = await getRegistryItems([components[0]], { config: shadowConfig });
			if (item?.type === "registry:style") {
				options.baseColor = "neutral";
				options.baseStyle = item.extends === "none" ? false : options.baseStyle;
			}
		}
		if (!options.baseStyle) options.baseColor = "neutral";
		await runInit(options);
		logger.log(`${highlighter.success("Success!")} Project initialization completed.\nYou may now add components.`);
		deleteFileBackup(path.resolve(options.cwd, "components.json"));
		logger.break();
	} catch (error) {
		logger.break();
		handleError(error);
	} finally {
		clearRegistryContext();
	}
});
async function runInit(options) {
	let projectInfo;
	if (!options.skipPreflight) {
		const preflight = await preFlightInit(options);
		if (preflight.errors[MISSING_DIR_OR_EMPTY_PROJECT]) process.exit(1);
		projectInfo = preflight.projectInfo;
	} else projectInfo = await getProjectInfo(options.cwd);
	const projectConfig = await getProjectConfig(options.cwd, projectInfo);
	let config = projectConfig ? await promptForMinimalConfig(projectConfig, options) : await promptForConfig(await getConfig(options.cwd));
	if (!options.yes) {
		const { proceed } = await prompts({
			type: "confirm",
			name: "proceed",
			message: `Write configuration to ${highlighter.info("components.json")}. Proceed?`,
			initial: true
		});
		if (!proceed) process.exit(0);
	}
	const components = [...options.baseStyle ? ["index"] : [], ...options.components ?? []];
	const { config: configWithRegistries } = await ensureRegistriesInConfig(components, await resolveConfigPaths(options.cwd, config), { silent: true });
	if (configWithRegistries.registries) config.registries = configWithRegistries.registries;
	const componentSpinner = spinner(`Writing components.json.`).start();
	const targetPath = path.resolve(options.cwd, "components.json");
	const backupPath = `${targetPath}${FILE_BACKUP_SUFFIX}`;
	if (!options.force && fsExtra.existsSync(backupPath)) {
		const { registries, ...merged } = deepmerge(await fsExtra.readJson(backupPath), config);
		config = {
			...merged,
			registries
		};
	}
	config.registries = Object.fromEntries(Object.entries(config.registries || {}).filter(([key]) => !Object.keys(BUILTIN_REGISTRIES).includes(key)));
	await promises.writeFile(targetPath, `${JSON.stringify(config, null, 2)}\n`, "utf8");
	componentSpinner.succeed();
	const fullConfig = await resolveConfigPaths(options.cwd, config);
	await addComponents(components, fullConfig, {
		overwrite: true,
		silent: options.silent,
		baseStyle: options.baseStyle,
		isNewProject: options.isNewProject || projectInfo?.framework.name === "nuxt4"
	});
	if (options.isNewProject && options.srcDir) await updateTailwindContent(["./src/**/*.{js,ts,jsx,tsx,mdx}"], fullConfig, { silent: options.silent });
	return fullConfig;
}
async function promptForConfig(defaultConfig = null) {
	const [styles, baseColors] = await Promise.all([getRegistryStyles(), getRegistryBaseColors()]);
	logger.info("");
	const options = await prompts([
		{
			type: "toggle",
			name: "typescript",
			message: `Would you like to use ${highlighter.info("TypeScript")} (recommended)?`,
			initial: defaultConfig?.typescript ?? true,
			active: "yes",
			inactive: "no"
		},
		{
			type: "select",
			name: "style",
			message: `Which ${highlighter.info("style")} would you like to use?`,
			choices: styles.map((style) => ({
				title: style.label,
				value: style.name
			}))
		},
		{
			type: "select",
			name: "tailwindBaseColor",
			message: `Which color would you like to use as the ${highlighter.info("base color")}?`,
			choices: baseColors.map((color) => ({
				title: color.label,
				value: color.name
			}))
		},
		{
			type: "text",
			name: "tailwindCss",
			message: `Where is your ${highlighter.info("global CSS")} file?`,
			initial: defaultConfig?.tailwind.css ?? DEFAULT_TAILWIND_CSS
		},
		{
			type: "toggle",
			name: "tailwindCssVariables",
			message: `Would you like to use ${highlighter.info("CSS variables")} for theming?`,
			initial: defaultConfig?.tailwind.cssVariables ?? true,
			active: "yes",
			inactive: "no"
		},
		{
			type: "text",
			name: "tailwindPrefix",
			message: `Are you using a custom ${highlighter.info("tailwind prefix eg. tw-")}? (Leave blank if not)`,
			initial: ""
		},
		{
			type: "text",
			name: "tailwindConfig",
			message: `Where is your ${highlighter.info("tailwind.config.js")} located?`,
			initial: defaultConfig?.tailwind.config ?? DEFAULT_TAILWIND_CONFIG
		},
		{
			type: "text",
			name: "components",
			message: `Configure the import alias for ${highlighter.info("components")}:`,
			initial: defaultConfig?.aliases.components ?? DEFAULT_COMPONENTS
		},
		{
			type: "text",
			name: "utils",
			message: `Configure the import alias for ${highlighter.info("utils")}:`,
			initial: defaultConfig?.aliases.utils ?? DEFAULT_UTILS
		}
	]);
	return rawConfigSchema.parse({
		$schema: "https://shadcn-vue.com/schema.json",
		style: options.style,
		tailwind: {
			config: options.tailwindConfig,
			css: options.tailwindCss,
			baseColor: options.tailwindBaseColor,
			cssVariables: options.tailwindCssVariables,
			prefix: options.tailwindPrefix
		},
		typescript: options.typescript,
		aliases: {
			utils: options.utils,
			components: options.components,
			lib: options.components.replace(/\/components$/, "/lib"),
			composables: options.components.replace(/\/components$/, "/composables")
		}
	});
}
async function promptForMinimalConfig(defaultConfig, opts) {
	let style = defaultConfig.style;
	let baseColor = opts.baseColor;
	let cssVariables = defaultConfig.tailwind.cssVariables;
	if (!opts.defaults) {
		const [styles, baseColors, tailwindVersion] = await Promise.all([
			getRegistryStyles(),
			getRegistryBaseColors(),
			getProjectTailwindVersionFromConfig(defaultConfig)
		]);
		const options = await prompts([{
			type: tailwindVersion === "v4" ? null : "select",
			name: "style",
			message: `Which ${highlighter.info("style")} would you like to use?`,
			choices: styles.map((style$1) => ({
				title: style$1.name === "new-york" ? "New York (Recommended)" : style$1.label,
				value: style$1.name
			})),
			initial: 0
		}, {
			type: opts.baseColor ? null : "select",
			name: "tailwindBaseColor",
			message: `Which color would you like to use as the ${highlighter.info("base color")}?`,
			choices: baseColors.map((color) => ({
				title: color.label,
				value: color.name
			}))
		}]);
		style = options.style ?? "new-york";
		baseColor = options.tailwindBaseColor ?? baseColor;
		cssVariables = opts.cssVariables;
	}
	return rawConfigSchema.parse({
		$schema: defaultConfig?.$schema,
		style,
		tailwind: {
			...defaultConfig?.tailwind,
			baseColor,
			cssVariables
		},
		typescript: defaultConfig.typescript,
		aliases: defaultConfig?.aliases,
		iconLibrary: defaultConfig?.iconLibrary
	});
}

//#endregion
//#region src/preflights/preflight-add.ts
async function preFlightAdd(options) {
	const errors = {};
	if (!fsExtra.existsSync(options.cwd) || !fsExtra.existsSync(path.resolve(options.cwd, "package.json"))) {
		errors[MISSING_DIR_OR_EMPTY_PROJECT] = true;
		return {
			errors,
			config: null
		};
	}
	if (!fsExtra.existsSync(path.resolve(options.cwd, "components.json"))) {
		errors[MISSING_CONFIG] = true;
		return {
			errors,
			config: null
		};
	}
	try {
		return {
			errors,
			config: await getConfig(options.cwd)
		};
	} catch (error) {
		logger.break();
		logger.error(`An invalid ${highlighter.info("components.json")} file was found at ${highlighter.info(options.cwd)}.\nBefore you can add components, you must create a valid ${highlighter.info("components.json")} file by running the ${highlighter.info("init")} command.`);
		logger.error(`Learn more at ${highlighter.info("https://shadcn-vue.com/docs/components-json")}.`);
		logger.break();
		process.exit(1);
	}
}

//#endregion
//#region src/commands/add.ts
const addOptionsSchema = z.object({
	components: z.array(z.string()).optional(),
	yes: z.boolean(),
	overwrite: z.boolean(),
	cwd: z.string(),
	all: z.boolean(),
	path: z.string().optional(),
	silent: z.boolean(),
	srcDir: z.boolean().optional(),
	cssVariables: z.boolean()
});
const add = new Command().name("add").description("add a component to your project").argument("[components...]", "names, url or local path to component").option("-y, --yes", "skip confirmation prompt.", false).option("-o, --overwrite", "overwrite existing files.", false).option("-c, --cwd <cwd>", "the working directory. defaults to the current directory.", process.cwd()).option("-a, --all", "add all available components", false).option("-p, --path <path>", "the path to add the component to.").option("-s, --silent", "mute output.", false).option("--css-variables", "use css variables for theming.", true).option("--no-css-variables", "do not use css variables for theming.").action(async (components, opts) => {
	try {
		const options = addOptionsSchema.parse({
			components,
			cwd: path.resolve(opts.cwd),
			...opts
		});
		await loadEnvFiles(options.cwd);
		let initialConfig = await getConfig(options.cwd);
		if (!initialConfig) initialConfig = createConfig({
			style: "new-york",
			resolvedPaths: { cwd: options.cwd }
		});
		let hasNewRegistries = false;
		if (components.length > 0) {
			const { config: updatedConfig$1, newRegistries } = await ensureRegistriesInConfig(components, initialConfig, {
				silent: options.silent,
				writeFile: false
			});
			initialConfig = updatedConfig$1;
			hasNewRegistries = newRegistries.length > 0;
		}
		let itemType;
		let shouldInstallBaseStyle = true;
		if (components.length > 0) {
			const [registryItem] = await getRegistryItems([components[0]], { config: initialConfig });
			itemType = registryItem?.type;
			shouldInstallBaseStyle = itemType !== "registry:theme" && itemType !== "registry:style";
			if (isUniversalRegistryItem(registryItem)) {
				await addComponents(components, initialConfig, {
					...options,
					baseStyle: shouldInstallBaseStyle
				});
				return;
			}
			if (!options.yes && (itemType === "registry:style" || itemType === "registry:theme")) {
				logger.break();
				const { confirm } = await prompts({
					type: "confirm",
					name: "confirm",
					message: highlighter.warn(`You are about to install a new ${itemType.replace("registry:", "")}. \nExisting CSS variables and components will be overwritten. Continue?`)
				});
				if (!confirm) {
					logger.break();
					logger.log(`Installation cancelled.`);
					logger.break();
					process.exit(1);
				}
			}
		}
		if (!options.components?.length) options.components = await promptForRegistryComponents(options);
		if ((await getProjectInfo(options.cwd))?.tailwindVersion === "v4") {
			const deprecatedComponents = DEPRECATED_COMPONENTS.filter((component) => options.components?.includes(component.name));
			if (deprecatedComponents?.length) {
				logger.break();
				deprecatedComponents.forEach((component) => {
					logger.warn(highlighter.warn(component.message));
				});
				logger.break();
				process.exit(1);
			}
		}
		let { errors, config } = await preFlightAdd(options);
		if (errors[MISSING_CONFIG]) {
			const { proceed } = await prompts({
				type: "confirm",
				name: "proceed",
				message: `You need to create a ${highlighter.info("components.json")} file to add components. Proceed?`,
				initial: true
			});
			if (!proceed) {
				logger.break();
				process.exit(1);
			}
			config = await runInit({
				cwd: options.cwd,
				yes: true,
				force: true,
				defaults: false,
				skipPreflight: false,
				silent: options.silent && !hasNewRegistries,
				isNewProject: false,
				srcDir: options.srcDir,
				cssVariables: options.cssVariables,
				baseStyle: shouldInstallBaseStyle,
				baseColor: shouldInstallBaseStyle ? void 0 : "neutral",
				components: options.components
			});
		}
		if (!config) throw new Error(`Failed to read config at ${highlighter.info(options.cwd)}.`);
		const { config: updatedConfig } = await ensureRegistriesInConfig(options.components, config, { silent: options.silent || hasNewRegistries });
		config = updatedConfig;
		await addComponents(options.components, config, {
			...options,
			baseStyle: shouldInstallBaseStyle
		});
	} catch (error) {
		logger.break();
		handleError(error);
	} finally {
		clearRegistryContext();
	}
});
async function promptForRegistryComponents(options) {
	const registryIndex = await getShadcnRegistryIndex();
	if (!registryIndex) {
		logger.break();
		handleError(/* @__PURE__ */ new Error("Failed to fetch registry index."));
		return [];
	}
	if (options.all) return registryIndex.map((entry) => entry.name).filter((component) => !DEPRECATED_COMPONENTS.some((c) => c.name === component));
	if (options.components?.length) return options.components;
	const { components } = await prompts({
		type: "multiselect",
		name: "components",
		message: "Which components would you like to add?",
		hint: "Space to select. A to toggle all. Enter to submit.",
		instructions: false,
		choices: registryIndex.filter((entry) => entry.type === "registry:ui" && !DEPRECATED_COMPONENTS.some((component) => component.name === entry.name)).map((entry) => ({
			title: entry.name,
			value: entry.name,
			selected: options.all ? true : options.components?.includes(entry.name)
		}))
	});
	if (!components?.length) {
		logger.warn("No components selected. Exiting.");
		logger.info("");
		process.exit(1);
	}
	const result = z.array(z.string()).safeParse(components);
	if (!result.success) {
		logger.error("");
		handleError(/* @__PURE__ */ new Error("Something went wrong. Please try again."));
		return [];
	}
	return result.data;
}

//#endregion
//#region src/preflights/preflight-build.ts
async function preFlightBuild(options) {
	const errors = {};
	const resolvePaths = {
		cwd: options.cwd,
		registryFile: path.resolve(options.cwd, options.registryFile),
		outputDir: path.resolve(options.cwd, options.outputDir)
	};
	if (!fsExtra.existsSync(resolvePaths.registryFile)) errors[BUILD_MISSING_REGISTRY_FILE] = true;
	await fsExtra.mkdir(resolvePaths.outputDir, { recursive: true });
	if (Object.keys(errors).length > 0) {
		if (errors[BUILD_MISSING_REGISTRY_FILE]) {
			logger.break();
			logger.error(`The path ${highlighter.info(resolvePaths.registryFile)} does not exist.`);
		}
		logger.break();
		process.exit(1);
	}
	return {
		errors,
		resolvePaths
	};
}

//#endregion
//#region src/commands/build.ts
const buildOptionsSchema = z.object({
	cwd: z.string(),
	registryFile: z.string(),
	outputDir: z.string()
});
const build = new Command().name("build").description("build components for a shadcn-vue registry").argument("[registry]", "path to registry.json file", "./registry.json").option("-o, --output <path>", "destination directory for json files", "./public/r").option("-c, --cwd <cwd>", "the working directory. defaults to the current directory.", process.cwd()).action(async (registry, opts) => {
	try {
		const { resolvePaths } = await preFlightBuild(buildOptionsSchema.parse({
			cwd: path$1.resolve(opts.cwd),
			registryFile: registry,
			outputDir: opts.output
		}));
		const content = await fs.readFile(resolvePaths.registryFile, "utf-8");
		const result = registrySchema.safeParse(JSON.parse(content));
		if (!result.success) {
			logger.error(`Invalid registry file found at ${highlighter.info(resolvePaths.registryFile)}.`);
			process.exit(1);
		}
		const buildSpinner = spinner("Building registry...");
		for (const registryItem of result.data.items) {
			buildSpinner.start(`Building ${registryItem.name}...`);
			registryItem.$schema = "https://shadcn-vue.com/schema/registry-item.json";
			for (const file of registryItem.files ?? []) file.content = (await fs.readFile(path$1.resolve(resolvePaths.cwd, file.path), "utf-8")).replace(/\r\n/g, "\n");
			const result$1 = registryItemSchema.safeParse(registryItem);
			if (!result$1.success) {
				logger.error(`Invalid registry item found for ${highlighter.info(registryItem.name)}.`);
				continue;
			}
			await fs.writeFile(path$1.resolve(resolvePaths.outputDir, `${result$1.data.name}.json`), JSON.stringify(result$1.data, null, 2));
		}
		await fs.copyFile(resolvePaths.registryFile, path$1.resolve(resolvePaths.outputDir, "registry.json"));
		buildSpinner.succeed("Building registry.");
	} catch (error) {
		logger.break();
		handleError(error);
	}
});

//#endregion
//#region src/commands/diff.ts
const updateOptionsSchema = z.object({
	component: z.string().optional(),
	yes: z.boolean(),
	cwd: z.string(),
	path: z.string().optional()
});
const diff = new Command().name("diff").description("check for updates against the registry").argument("[component]", "the component name").option("-y, --yes", "skip confirmation prompt.", false).option("-c, --cwd <cwd>", "the working directory. defaults to the current directory.", process.cwd()).action(async (name, opts) => {
	try {
		const options = updateOptionsSchema.parse({
			component: name,
			...opts
		});
		const cwd = path.resolve(options.cwd);
		if (!existsSync(cwd)) {
			logger.error(`The path ${cwd} does not exist. Please try again.`);
			process.exit(1);
		}
		const config = await getConfig(cwd);
		if (!config) {
			logger.warn(`Configuration is missing. Please run ${highlighter.success(`init`)} to create a components.json file.`);
			process.exit(1);
		}
		const registryIndex = await getShadcnRegistryIndex();
		if (!registryIndex) {
			handleError(/* @__PURE__ */ new Error("Failed to fetch registry index."));
			process.exit(1);
		}
		if (!options.component) {
			const targetDir = config.resolvedPaths.components;
			const projectComponents = registryIndex.filter((item) => {
				for (const file of item.files ?? []) if (existsSync(path.resolve(targetDir, typeof file === "string" ? file : file.path))) return true;
				return false;
			});
			const componentsWithUpdates = [];
			for (const component$1 of projectComponents) {
				const changes$1 = await diffComponent(component$1, config);
				if (changes$1.length) componentsWithUpdates.push({
					name: component$1.name,
					changes: changes$1
				});
			}
			if (!componentsWithUpdates.length) {
				logger.info("No updates found.");
				process.exit(0);
			}
			logger.info("The following components have updates available:");
			for (const component$1 of componentsWithUpdates) {
				logger.info(`- ${component$1.name}`);
				for (const change of component$1.changes) logger.info(`  - ${change.filePath}`);
			}
			logger.break();
			logger.info(`Run ${highlighter.success(`diff <component>`)} to see the changes.`);
			process.exit(0);
		}
		const component = registryIndex.find((item) => item.name === options.component);
		if (!component) {
			logger.error(`The component ${highlighter.success(options.component)} does not exist.`);
			process.exit(1);
		}
		const changes = await diffComponent(component, config);
		if (!changes.length) {
			logger.info(`No updates found for ${options.component}.`);
			process.exit(0);
		}
		for (const change of changes) {
			logger.info(`- ${change.filePath}`);
			await printDiff(change.patch);
			logger.info("");
		}
	} catch (error) {
		handleError(error);
	}
});
async function diffComponent(component, config) {
	const payload = await fetchTree(config.style, [component]);
	const baseColor = await getRegistryBaseColor(config.tailwind.baseColor);
	if (!payload) return [];
	const changes = [];
	for (const item of payload) {
		const targetDir = await getItemTargetPath(config, item);
		if (!targetDir) continue;
		for (const file of item.files ?? []) {
			const filePath = path.resolve(targetDir, typeof file === "string" ? file : file.path);
			if (!existsSync(filePath)) continue;
			const fileContent = await promises.readFile(filePath, "utf8");
			if (typeof file === "string" || !file.content) continue;
			const patch = diffLines(await transform({
				filename: file.path,
				raw: file.content,
				config,
				baseColor
			}), fileContent);
			if (patch.length > 1) changes.push({
				filePath,
				patch
			});
		}
	}
	return changes;
}
async function printDiff(diff$1) {
	diff$1.forEach((part) => {
		if (part) {
			if (part.added) return process.stdout.write(highlighter.success(part.value));
			if (part.removed) return process.stdout.write(highlighter.error(part.value));
			return process.stdout.write(part.value);
		}
	});
}

//#endregion
//#region src/commands/info.ts
const info = new Command().name("info").description("get information about your project").option("-c, --cwd <cwd>", "the working directory. defaults to the current directory.", process.cwd()).action(async (opts) => {
	try {
		logger.info("> project info");
		consola.log(await getProjectInfo(opts.cwd));
		logger.break();
		logger.info("> components.json");
		consola.log(await getConfig(opts.cwd));
	} catch (error) {
		handleError(error);
	}
});

//#endregion
//#region src/commands/mcp.ts
const SHADCN_MCP_VERSION = "latest";
const CLIENTS = [
	{
		name: "claude",
		label: "Claude Code",
		configPath: ".mcp.json",
		config: { mcpServers: { shadcnVue: {
			command: "npx",
			args: [`shadcn-vue@${SHADCN_MCP_VERSION}`, "mcp"]
		} } }
	},
	{
		name: "cursor",
		label: "Cursor",
		configPath: ".cursor/mcp.json",
		config: { mcpServers: { shadcnVue: {
			command: "npx",
			args: [`shadcn-vue@${SHADCN_MCP_VERSION}`, "mcp"]
		} } }
	},
	{
		name: "vscode",
		label: "VS Code",
		configPath: ".vscode/mcp.json",
		config: { servers: { shadcnVue: {
			command: "npx",
			args: [`shadcn-vue@${SHADCN_MCP_VERSION}`, "mcp"]
		} } }
	},
	{
		name: "codex",
		label: "Codex",
		configPath: ".codex/config.toml",
		config: `[mcp_servers.shadcn_vue]
command = "npx"
args = ["shadcn-vue@${SHADCN_MCP_VERSION}", "mcp"]
`
	},
	{
		name: "opencode",
		label: "Opencode",
		configPath: "opencode.json",
		config: {
			$schema: "https://opencode.ai/config.json",
			mcp: { shadcnVue: {
				type: "local",
				enabled: true,
				command: [
					"npx",
					`shadcn-vue@${SHADCN_MCP_VERSION}`,
					"mcp"
				]
			} }
		}
	}
];
const DEPENDENCIES = [`shadcn-vue@${SHADCN_MCP_VERSION}`];
const mcp = new Command().name("mcp").description("MCP server and configuration commands").option("-c, --cwd <cwd>", "the working directory. defaults to the current directory.", process.cwd()).action(async (options) => {
	try {
		await loadEnvFiles(options.cwd);
		const transport = new StdioServerTransport();
		await server.connect(transport);
	} catch (error) {
		logger.break();
		handleError(error);
	}
});
const mcpInitOptionsSchema = z$1.object({
	client: z$1.enum([
		"claude",
		"cursor",
		"vscode",
		"codex",
		"opencode"
	]),
	cwd: z$1.string()
});
mcp.command("init").description("Initialize MCP configuration for your client").option("--client <client>", `MCP client (${CLIENTS.map((c) => c.name).join(", ")})`).action(async (opts, command) => {
	try {
		const cwd = (command.parent?.opts() || {}).cwd || process.cwd();
		let client = opts.client;
		if (!client) {
			const response = await prompts({
				type: "select",
				name: "client",
				message: "Which MCP client are you using?",
				choices: CLIENTS.map((c) => ({
					title: c.label,
					value: c.name
				}))
			});
			if (!response.client) {
				logger.break();
				process.exit(1);
			}
			client = response.client;
		}
		const options = mcpInitOptionsSchema.parse({
			client,
			cwd
		});
		const config = await getConfig(options.cwd);
		if (options.client === "codex") {
			if (config) await updateDependencies([], DEPENDENCIES, config, { silent: false });
			else {
				const packageManager = await detectPackageManager(options.cwd);
				const installCommand = packageManager?.name === "npm" ? "install" : "add";
				const devFlag = packageManager?.name === "npm" ? "--save-dev" : "-D";
				const installSpinner = spinner("Installing dependencies...").start();
				await x(packageManager?.name || "npm", [
					installCommand,
					devFlag,
					...DEPENDENCIES
				], { nodeOptions: { cwd: options.cwd } });
				installSpinner.succeed("Installing dependencies.");
			}
			logger.break();
			logger.log("To configure the shadcn-vue MCP server in Codex:");
			logger.break();
			logger.log(`1. Open or create the file ${highlighter.info("~/.codex/config.toml")}`);
			logger.log("2. Add the following configuration:");
			logger.log();
			logger.info(`[mcp_servers.shadcn_vue]
command = "npx"
args = ["shadcn-vue@${SHADCN_MCP_VERSION}", "mcp"]`);
			logger.break();
			logger.info("3. Restart Codex to load the MCP server");
			logger.break();
			process.exit(0);
		}
		const configSpinner = spinner("Configuring MCP server...").start();
		const configPath = await runMcpInit(options);
		configSpinner.succeed("Configuring MCP server.");
		if (config) await updateDependencies([], DEPENDENCIES, config, { silent: false });
		else {
			const packageManager = await detectPackageManager(options.cwd);
			const installCommand = packageManager?.name === "npm" ? "install" : "add";
			const devFlag = packageManager?.name === "npm" ? "--save-dev" : "-D";
			const installSpinner = spinner("Installing dependencies...").start();
			await x(packageManager?.name || "npm", [
				installCommand,
				devFlag,
				...DEPENDENCIES
			], { nodeOptions: { cwd: options.cwd } });
			installSpinner.succeed("Installing dependencies.");
		}
		logger.break();
		logger.success(`Configuration saved to ${configPath}.`);
		logger.break();
	} catch (error) {
		handleError(error);
	}
});
const overwriteMerge = (_, sourceArray) => sourceArray;
async function runMcpInit(options) {
	const { client, cwd } = options;
	const clientInfo = CLIENTS.find((c) => c.name === client);
	if (!clientInfo) throw new Error(`Unknown client: ${client}. Available clients: ${CLIENTS.map((c) => c.name).join(", ")}`);
	const configPath = path.join(cwd, clientInfo.configPath);
	const dir = path.dirname(configPath);
	await fsExtra.ensureDir(dir);
	let existingConfig = {};
	try {
		const content = await promises.readFile(configPath, "utf-8");
		existingConfig = JSON.parse(content);
	} catch {}
	const mergedConfig = deepmerge(existingConfig, clientInfo.config, { arrayMerge: overwriteMerge });
	await promises.writeFile(configPath, `${JSON.stringify(mergedConfig, null, 2)}\n`, "utf-8");
	return clientInfo.configPath;
}

//#endregion
//#region src/migrations/migrate-icons.ts
async function migrateIcons(config) {
	if (!config.resolvedPaths.ui) throw new Error("We could not find a valid `ui` path in your `components.json` file. Please ensure you have a valid `ui` path in your `components.json` file.");
	const uiPath = config.resolvedPaths.ui;
	const [files, registryIcons] = await Promise.all([glob("**/*.{js,ts,jsx,tsx}", { cwd: uiPath }), getRegistryIcons()]);
	if (Object.keys(registryIcons).length === 0) throw new Error("Something went wrong fetching the registry icons.");
	const libraryChoices = Object.entries(ICON_LIBRARIES).map(([name, iconLibrary]) => ({
		title: iconLibrary.name,
		value: name
	}));
	const migrateOptions = await prompts([{
		type: "select",
		name: "sourceLibrary",
		message: `Which icon library would you like to ${highlighter.info("migrate from")}?`,
		choices: libraryChoices
	}, {
		type: "select",
		name: "targetLibrary",
		message: `Which icon library would you like to ${highlighter.info("migrate to")}?`,
		choices: libraryChoices
	}]);
	if (migrateOptions.sourceLibrary === migrateOptions.targetLibrary) throw new Error("You cannot migrate to the same icon library. Please choose a different icon library.");
	if (!(migrateOptions.sourceLibrary in ICON_LIBRARIES && migrateOptions.targetLibrary in ICON_LIBRARIES)) throw new Error("Invalid icon library. Please choose a valid icon library.");
	const sourceLibrary = ICON_LIBRARIES[migrateOptions.sourceLibrary];
	const targetLibrary = ICON_LIBRARIES[migrateOptions.targetLibrary];
	const { confirm } = await prompts({
		type: "confirm",
		name: "confirm",
		initial: true,
		message: `We will migrate ${highlighter.info(files.length)} files in ${highlighter.info(`./${path.relative(config.resolvedPaths.cwd, uiPath)}`)} from ${highlighter.info(sourceLibrary.name)} to ${highlighter.info(targetLibrary.name)}. Continue?`
	});
	if (!confirm) {
		logger.info("Migration cancelled.");
		process.exit(0);
	}
	if (targetLibrary.package) await updateDependencies([targetLibrary.package], [], config, { silent: false });
	const migrationSpinner = spinner(`Migrating icons...`)?.start();
	await Promise.all(files.map(async (file) => {
		migrationSpinner.text = `Migrating ${file}...`;
		const filePath = path.join(uiPath, file);
		const content = await migrateIconsFile(await promises.readFile(filePath, "utf-8"), migrateOptions.sourceLibrary, migrateOptions.targetLibrary, registryIcons);
		await promises.writeFile(filePath, content);
	}));
	migrationSpinner.succeed("Migration complete.");
}
async function migrateIconsFile(content, sourceLibrary, targetLibrary, iconsMapping) {
	const sourceLibraryImport = ICON_LIBRARIES[sourceLibrary]?.import;
	const targetLibraryImport = ICON_LIBRARIES[targetLibrary]?.import;
	const dir = await promises.mkdtemp(path.join(tmpdir(), "shadcn-"));
	const project = new Project({ compilerOptions: {} });
	const tempFile = path.join(dir, `shadcn-icons-${randomBytes(4).toString("hex")}.tsx`);
	const sourceFile = project.createSourceFile(tempFile, content, { scriptKind: ScriptKind.TSX });
	const targetedIcons = [];
	for (const importDeclaration of sourceFile.getImportDeclarations() ?? []) {
		if (importDeclaration.getModuleSpecifier()?.getText() !== `"${sourceLibraryImport}"`) continue;
		for (const specifier of importDeclaration.getNamedImports() ?? []) {
			const iconName = specifier.getName();
			const targetedIcon = Object.values(iconsMapping).find((icon) => icon[sourceLibrary] === iconName)?.[targetLibrary];
			if (!targetedIcon || targetedIcons.includes(targetedIcon)) continue;
			targetedIcons.push(targetedIcon);
			specifier.remove();
			sourceFile.getDescendantsOfKind(SyntaxKind.JsxSelfClosingElement).filter((node) => node.getTagNameNode()?.getText() === iconName).forEach((node) => node.getTagNameNode()?.replaceWithText(targetedIcon));
		}
		if (importDeclaration.getNamedImports()?.length === 0) importDeclaration.remove();
	}
	if (targetedIcons.length > 0) sourceFile.addImportDeclaration({
		moduleSpecifier: targetLibraryImport,
		namedImports: targetedIcons.map((icon) => ({ name: icon }))
	});
	return await sourceFile.getText();
}

//#endregion
//#region src/preflights/preflight-migrate.ts
async function preFlightMigrate(options) {
	const errors = {};
	if (!fsExtra.existsSync(options.cwd) || !fsExtra.existsSync(path.resolve(options.cwd, "package.json"))) {
		errors[MISSING_DIR_OR_EMPTY_PROJECT] = true;
		return {
			errors,
			config: null
		};
	}
	if (!fsExtra.existsSync(path.resolve(options.cwd, "components.json"))) {
		errors[MISSING_CONFIG] = true;
		return {
			errors,
			config: null
		};
	}
	try {
		return {
			errors,
			config: await getConfig(options.cwd)
		};
	} catch (error) {
		logger.break();
		logger.error(`An invalid ${highlighter.info("components.json")} file was found at ${highlighter.info(options.cwd)}.\nBefore you can run a migration, you must create a valid ${highlighter.info("components.json")} file by running the ${highlighter.info("init")} command.`);
		logger.error(`Learn more at ${highlighter.info("https://shadcn-vue.com/docs/components-json")}.`);
		logger.break();
		process.exit(1);
	}
}

//#endregion
//#region src/commands/migrate.ts
const migrations = [{
	name: "icons",
	description: "migrate your ui components to a different icon library."
}];
const migrateOptionsSchema = z.object({
	cwd: z.string(),
	list: z.boolean(),
	yes: z.boolean(),
	migration: z.string().refine((value) => value && migrations.some((migration) => migration.name === value), { message: "You must specify a valid migration. Run `shadcn migrate --list` to see available migrations." }).optional()
});
const migrate = new Command().name("migrate").description("run a migration.").argument("[migration]", "the migration to run.").option("-c, --cwd <cwd>", "the working directory. defaults to the current directory.", process.cwd()).option("-l, --list", "list all migrations.", false).option("-y, --yes", "skip confirmation prompt.", false).action(async (migration, opts) => {
	try {
		const options = migrateOptionsSchema.parse({
			cwd: path.resolve(opts.cwd),
			migration,
			list: opts.list,
			yes: opts.yes
		});
		if (options.list || !options.migration) {
			logger.info("Available migrations:");
			for (const migration$1 of migrations) logger.info(`- ${migration$1.name}: ${migration$1.description}`);
			return;
		}
		if (!options.migration) throw new Error("You must specify a migration. Run `shadcn migrate --list` to see available migrations.");
		const { errors, config } = await preFlightMigrate(options);
		if (errors[MISSING_DIR_OR_EMPTY_PROJECT] || errors[MISSING_CONFIG]) throw new Error("No `components.json` file found. Ensure you are at the root of your project.");
		if (!config) throw new Error("Something went wrong reading your `components.json` file. Please ensure you have a valid `components.json` file.");
		if (options.migration === "icons") await migrateIcons(config);
	} catch (error) {
		logger.break();
		handleError(error);
	}
});

//#endregion
//#region package.json
var version = "2.4.3";

//#endregion
//#region src/index.ts
process.on("SIGINT", () => process.exit(0));
process.on("SIGTERM", () => process.exit(0));
async function main() {
	const program = new Command().name("shadcn-vue").description("add components and dependencies to your project").version(version || "1.0.0", "-v, --version", "display the version number");
	program.addCommand(init).addCommand(add).addCommand(diff).addCommand(migrate).addCommand(info).addCommand(build).addCommand(mcp);
	program.parse();
}
main();

//#endregion
export { fetchTree, getItemTargetPath, getRegistriesConfig, getRegistriesIndex, getRegistry, getRegistryBaseColor, getRegistryBaseColors, getRegistryIcons, getRegistryItems, getRegistryStyles, getShadcnRegistryIndex, resolveRegistryItems, resolveTree };
//# sourceMappingURL=index.js.map