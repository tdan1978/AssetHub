{"version":3,"file":"registry-ClmPjtrG.js","names":["BUILTIN_REGISTRIES: z.infer<typeof registryConfigSchema>","url: string","responseBody?: string","registryName: string | null","filePath: string","item: string","registryName: string","missingVars: string[]","name: string","cwd: string","resolvedAliases: any","findCommonRoot","key","defaultConfig: Config","fs","fs","vars: string[]","match: RegExpExecArray | null","env: Record<string, string>","newKeys: string[]","path","parts: (string | null)[]","prefix","path","transform","path","targetedIconsMap: Map<string, string>","path","transform","metaTransform","filesCreated: string[]","filesUpdated: string[]","filesSkipped: string[]","envVarsAdded: string[]","envFile: string | null","transform","fs","path","metaTransform","isUrl","path","context: RegistryContext","headers: Record<string, string>","isUrl","path","fs","fs","result: any","result: any[]","result: Record<string, any>","registryHeaders: Record<string, Record<string, string>>","isUrl","result","payload: z.infer<typeof registryItemWithSourceSchema>[]","allDependencyItems: z.infer<typeof registryItemWithSourceSchema>[]","allDependencyRegistryNames: string[]","itemWithSource: z.infer<typeof registryItemWithSourceSchema>","registryUrls: string[]","items: z.infer<typeof registryItemSchema>[]","registryNames: string[]","depHash: string | undefined","queue: string[]","sorted: z.infer<typeof registryItemSchema>[]","isUrl","result","tree: z.infer<typeof registryIndexSchema>","entry","index","allItems: z.infer<typeof searchResultItemSchema>[]","result: z.infer<typeof searchResultsSchema>"],"sources":["../src/utils/frameworks.ts","../src/registry/constants.ts","../src/utils/highlighter.ts","../src/registry/errors.ts","../src/utils/resolve-import.ts","../src/utils/get-config.ts","../src/utils/get-package-info.ts","../src/utils/get-project-info.ts","../src/utils/logger.ts","../src/utils/spinner.ts","../src/registry/env.ts","../src/registry/parser.ts","../src/utils/compare.ts","../src/utils/env-helpers.ts","../src/utils/transformers/transform-css-vars.ts","../src/utils/transformers/transform-import.ts","../src/utils/transformers/transform-sfc.ts","../src/utils/transformers/transform-tw-prefix.ts","../src/utils/icon-libraries.ts","../src/utils/transformers/transform-icons.ts","../src/utils/transformers/index.ts","../src/utils/updaters/update-files.ts","../src/registry/utils.ts","../src/registry/config.ts","../src/registry/context.ts","../src/registry/validator.ts","../src/registry/builder.ts","../src/registry/fetcher.ts","../src/utils/handle-error.ts","../src/utils/updaters/update-tailwind-config.ts","../src/registry/resolver.ts","../src/registry/api.ts","../src/registry/search.ts"],"sourcesContent":["export const FRAMEWORKS = {\n  vite: {\n    name: 'vite',\n    label: 'Vite',\n    links: {\n      installation: 'https://shadcn-vue.com/docs/installation/vite',\n      tailwind: 'https://tailwindcss.com/docs/guides/vite',\n    },\n  },\n  nuxt3: {\n    name: 'nuxt3',\n    label: 'Nuxt 3',\n    links: {\n      installation: 'https://shadcn-vue.com/docs/installation/nuxt',\n      tailwind: 'https://tailwindcss.com/docs/guides/nuxtjs',\n    },\n  },\n  nuxt4: {\n    name: 'nuxt4',\n    label: 'Nuxt 4',\n    links: {\n      installation: 'https://shadcn-vue.com/docs/installation/nuxt',\n      tailwind: 'https://tailwindcss.com/docs/guides/nuxtjs',\n    },\n  },\n  astro: {\n    name: 'astro',\n    label: 'Astro',\n    links: {\n      installation: 'https://shadcn-vue.com/docs/installation/astro',\n      tailwind: 'https://tailwindcss.com/docs/guides/astro',\n    },\n  },\n  laravel: {\n    name: 'laravel',\n    label: 'Laravel',\n    links: {\n      installation: 'https://shadcn-vue.com/docs/installation/laravel',\n      tailwind: 'https://tailwindcss.com/docs/guides/laravel',\n    },\n  },\n  manual: {\n    name: 'manual',\n    label: 'Manual',\n    links: {\n      installation: 'https://shadcn-vue.com/docs/installation/manual',\n      tailwind: 'https://tailwindcss.com/docs/installation',\n    },\n  },\n  inertia: {\n    name: 'inertia',\n    label: 'Inertia',\n    links: {\n      installation: 'https://shadcn-vue.com/docs/installation/manual',\n      tailwind: 'https://tailwindcss.com/docs/installation',\n    },\n  },\n} as const\n\nexport type Framework = (typeof FRAMEWORKS)[keyof typeof FRAMEWORKS]\n","import type { z } from \"zod\"\nimport type { registryConfigSchema } from \"@/src/schema\"\n\nexport const REGISTRY_URL\n  = process.env.REGISTRY_URL ?? \"https://shadcn-vue.com/r\"\n\nexport const FALLBACK_STYLE = \"new-york-v4\"\n\nexport const BASE_COLORS = [\n  {\n    name: \"neutral\",\n    label: \"Neutral\",\n  },\n  {\n    name: \"gray\",\n    label: \"Gray\",\n  },\n  {\n    name: \"zinc\",\n    label: \"Zinc\",\n  },\n  {\n    name: \"stone\",\n    label: \"Stone\",\n  },\n  {\n    name: \"slate\",\n    label: \"Slate\",\n  },\n] as const\n\n// Built-in registries that are always available and cannot be overridden\nexport const BUILTIN_REGISTRIES: z.infer<typeof registryConfigSchema> = {\n  \"@shadcn\": `${REGISTRY_URL}/styles/{style}/{name}.json`,\n}\n\nexport const BUILTIN_MODULES = new Set([\n  [\n    // Node.js built-in modules\n    // From https://github.com/sindresorhus/builtin-modules.\n    \"node:assert\",\n    \"assert\",\n    \"node:assert/strict\",\n    \"assert/strict\",\n    \"node:async_hooks\",\n    \"async_hooks\",\n    \"node:buffer\",\n    \"buffer\",\n    \"node:child_process\",\n    \"child_process\",\n    \"node:cluster\",\n    \"cluster\",\n    \"node:console\",\n    \"console\",\n    \"node:constants\",\n    \"constants\",\n    \"node:crypto\",\n    \"crypto\",\n    \"node:dgram\",\n    \"dgram\",\n    \"node:diagnostics_channel\",\n    \"diagnostics_channel\",\n    \"node:dns\",\n    \"dns\",\n    \"node:dns/promises\",\n    \"dns/promises\",\n    \"node:domain\",\n    \"domain\",\n    \"node:events\",\n    \"events\",\n    \"node:fs\",\n    \"fs\",\n    \"node:fs/promises\",\n    \"fs/promises\",\n    \"node:http\",\n    \"http\",\n    \"node:http2\",\n    \"http2\",\n    \"node:https\",\n    \"https\",\n    \"node:inspector\",\n    \"inspector\",\n    \"node:inspector/promises\",\n    \"inspector/promises\",\n    \"node:module\",\n    \"module\",\n    \"node:net\",\n    \"net\",\n    \"node:os\",\n    \"os\",\n    \"node:path\",\n    \"path\",\n    \"node:path/posix\",\n    \"path/posix\",\n    \"node:path/win32\",\n    \"path/win32\",\n    \"node:perf_hooks\",\n    \"perf_hooks\",\n    \"node:process\",\n    \"process\",\n    \"node:querystring\",\n    \"querystring\",\n    \"node:quic\",\n    \"node:readline\",\n    \"readline\",\n    \"node:readline/promises\",\n    \"readline/promises\",\n    \"node:repl\",\n    \"repl\",\n    \"node:sea\",\n    \"node:sqlite\",\n    \"node:stream\",\n    \"stream\",\n    \"node:stream/consumers\",\n    \"stream/consumers\",\n    \"node:stream/promises\",\n    \"stream/promises\",\n    \"node:stream/web\",\n    \"stream/web\",\n    \"node:string_decoder\",\n    \"string_decoder\",\n    \"node:test\",\n    \"node:test/reporters\",\n    \"node:timers\",\n    \"timers\",\n    \"node:timers/promises\",\n    \"timers/promises\",\n    \"node:tls\",\n    \"tls\",\n    \"node:trace_events\",\n    \"trace_events\",\n    \"node:tty\",\n    \"tty\",\n    \"node:url\",\n    \"url\",\n    \"node:util\",\n    \"util\",\n    \"node:util/types\",\n    \"util/types\",\n    \"node:v8\",\n    \"v8\",\n    \"node:vm\",\n    \"vm\",\n    \"node:wasi\",\n    \"wasi\",\n    \"node:worker_threads\",\n    \"worker_threads\",\n    \"node:zlib\",\n    \"zlib\",\n\n    // Bun built-in modules.\n    \"bun\",\n    \"bun:test\",\n    \"bun:sqlite\",\n    \"bun:ffi\",\n    \"bun:jsc\",\n    \"bun:internal\",\n  ],\n])\n\nexport const DEPRECATED_COMPONENTS = [\n  {\n    name: \"toast\",\n    deprecatedBy: \"sonner\",\n    message:\n      \"The toast component is deprecated. Use the sonner component instead.\",\n  },\n  {\n    name: \"toaster\",\n    deprecatedBy: \"sonner\",\n    message:\n      \"The toaster component is deprecated. Use the sonner component instead.\",\n  },\n]\n","import { colors } from 'consola/utils'\n\nexport const highlighter = {\n  error: colors.red,\n  warn: colors.yellow,\n  info: colors.cyan,\n  success: colors.green,\n}\n","import { z } from \"zod\"\nimport { highlighter } from \"@/src/utils/highlighter\"\n\n// Error codes for programmatic error handling\nexport const RegistryErrorCode = {\n  // Network errors\n  NETWORK_ERROR: \"NETWORK_ERROR\",\n  NOT_FOUND: \"NOT_FOUND\",\n  UNAUTHORIZED: \"UNAUTHORIZED\",\n  FORBIDDEN: \"FORBIDDEN\",\n  FETCH_ERROR: \"FETCH_ERROR\",\n\n  // Configuration errors\n  NOT_CONFIGURED: \"NOT_CONFIGURED\",\n  INVALID_CONFIG: \"INVALID_CONFIG\",\n  MISSING_ENV_VARS: \"MISSING_ENV_VARS\",\n\n  // File system errors\n  LOCAL_FILE_ERROR: \"LOCAL_FILE_ERROR\",\n\n  // Parsing errors\n  PARSE_ERROR: \"PARSE_ERROR\",\n  VALIDATION_ERROR: \"VALIDATION_ERROR\",\n\n  // Generic errors\n  UNKNOWN_ERROR: \"UNKNOWN_ERROR\",\n} as const\n\n// eslint-disable-next-line ts/no-redeclare\nexport type RegistryErrorCode\n  = (typeof RegistryErrorCode)[keyof typeof RegistryErrorCode]\n\nexport class RegistryError extends Error {\n  public readonly code: RegistryErrorCode\n  public readonly statusCode?: number\n  public readonly context?: Record<string, unknown>\n  public readonly suggestion?: string\n  public readonly timestamp: Date\n  public readonly cause?: unknown\n\n  constructor(\n    message: string,\n    options: {\n      code?: RegistryErrorCode\n      statusCode?: number\n      cause?: unknown\n      context?: Record<string, unknown>\n      suggestion?: string\n    } = {},\n  ) {\n    super(message)\n    this.name = \"RegistryError\"\n    this.code = options.code || RegistryErrorCode.UNKNOWN_ERROR\n    this.statusCode = options.statusCode\n    this.cause = options.cause\n    this.context = options.context\n    this.suggestion = options.suggestion\n    this.timestamp = new Date()\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor)\n    }\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      code: this.code,\n      statusCode: this.statusCode,\n      context: this.context,\n      suggestion: this.suggestion,\n      timestamp: this.timestamp,\n      stack: this.stack,\n    }\n  }\n}\n\nexport class RegistryNotFoundError extends RegistryError {\n  constructor(public readonly url: string, cause?: unknown) {\n    const message = `The item at ${url} was not found. It may not exist at the registry.`\n\n    super(message, {\n      code: RegistryErrorCode.NOT_FOUND,\n      statusCode: 404,\n      cause,\n      context: { url },\n      suggestion:\n        \"Check if the item name is correct and the registry URL is accessible.\",\n    })\n    this.name = \"RegistryNotFoundError\"\n  }\n}\n\nexport class RegistryUnauthorizedError extends RegistryError {\n  constructor(public readonly url: string, cause?: unknown) {\n    const message = `You are not authorized to access the item at ${url}. If this is a remote registry, you may need to authenticate.`\n\n    super(message, {\n      code: RegistryErrorCode.UNAUTHORIZED,\n      statusCode: 401,\n      cause,\n      context: { url },\n      suggestion:\n        \"Check your authentication credentials and environment variables.\",\n    })\n    this.name = \"RegistryUnauthorizedError\"\n  }\n}\n\nexport class RegistryForbiddenError extends RegistryError {\n  constructor(public readonly url: string, cause?: unknown) {\n    const message = `You are not authorized to access the item at ${url}. If this is a remote registry, you may need to authenticate.`\n\n    super(message, {\n      code: RegistryErrorCode.FORBIDDEN,\n      statusCode: 403,\n      cause,\n      context: { url },\n      suggestion:\n        \"Check your authentication credentials and environment variables.\",\n    })\n    this.name = \"RegistryForbiddenError\"\n  }\n}\n\nexport class RegistryFetchError extends RegistryError {\n  constructor(\n    public readonly url: string,\n    statusCode?: number,\n    public readonly responseBody?: string,\n    cause?: unknown,\n  ) {\n    // Use the error detail from the server if available\n    const baseMessage = statusCode\n      ? `Failed to fetch from registry (${statusCode}): ${url}`\n      : `Failed to fetch from registry: ${url}`\n\n    const message\n      = typeof cause === \"string\" && cause\n        ? `${baseMessage} - ${cause}`\n        : baseMessage\n\n    let suggestion = \"Check your network connection and try again.\"\n    if (statusCode === 404) {\n      suggestion\n        = \"The requested resource was not found. Check the URL or item name.\"\n    }\n    else if (statusCode === 500) {\n      suggestion = \"The registry server encountered an error. Try again later.\"\n    }\n    else if (statusCode && statusCode >= 400 && statusCode < 500) {\n      suggestion = \"There was a client error. Check your request parameters.\"\n    }\n\n    super(message, {\n      code: RegistryErrorCode.FETCH_ERROR,\n      statusCode,\n      cause,\n      context: { url, responseBody },\n      suggestion,\n    })\n    this.name = \"RegistryFetchError\"\n  }\n}\n\nexport class RegistryNotConfiguredError extends RegistryError {\n  constructor(public readonly registryName: string | null) {\n    const message = registryName\n      ? `Unknown registry \"${registryName}\". Make sure it is defined in components.json as follows:\n{\n  \"registries\": {\n    \"${registryName}\": \"[URL_TO_REGISTRY]\"\n  }\n}`\n      : \"Unknown registry. Make sure it is defined in components.json under \\\"registries\\\".\"\n\n    super(message, {\n      code: RegistryErrorCode.NOT_CONFIGURED,\n      context: { registryName },\n      suggestion:\n        \"Add the registry configuration to your components.json file. Consult the registry documentation for the correct format.\",\n    })\n    this.name = \"RegistryNotConfiguredError\"\n  }\n}\n\nexport class RegistryLocalFileError extends RegistryError {\n  constructor(public readonly filePath: string, cause?: unknown) {\n    super(`Failed to read local registry file: ${filePath}`, {\n      code: RegistryErrorCode.LOCAL_FILE_ERROR,\n      cause,\n      context: { filePath },\n      suggestion: \"Check if the file exists and you have read permissions.\",\n    })\n    this.name = \"RegistryLocalFileError\"\n  }\n}\n\nexport class RegistryParseError extends RegistryError {\n  public readonly parseError: unknown\n\n  constructor(public readonly item: string, parseError: unknown) {\n    let message = `Failed to parse registry item: ${item}`\n\n    if (parseError instanceof z.ZodError) {\n      message = `Failed to parse registry item: ${item}\\n${parseError.errors\n        .map(e => `  - ${e.path.join(\".\")}: ${e.message}`)\n        .join(\"\\n\")}`\n    }\n\n    super(message, {\n      code: RegistryErrorCode.PARSE_ERROR,\n      cause: parseError,\n      context: { item },\n      suggestion:\n        \"The registry item may be corrupted or have an invalid format. Please make sure it returns a valid JSON object. See https://shadcn-vue.com/schema/registry-item.json.\",\n    })\n\n    this.parseError = parseError\n    this.name = \"RegistryParseError\"\n  }\n}\n\nexport class RegistryMissingEnvironmentVariablesError extends RegistryError {\n  constructor(\n    public readonly registryName: string,\n    public readonly missingVars: string[],\n  ) {\n    const message\n      = `Registry \"${registryName}\" requires the following environment variables:\\n\\n${\n        missingVars.map(v => `  â€¢ ${v}`).join(\"\\n\")}`\n\n    super(message, {\n      code: RegistryErrorCode.MISSING_ENV_VARS,\n      context: { registryName, missingVars },\n      suggestion:\n        \"Set the required environment variables to your .env or .env.local file.\",\n    })\n    this.name = \"RegistryMissingEnvironmentVariablesError\"\n  }\n}\n\nexport class RegistryInvalidNamespaceError extends RegistryError {\n  constructor(public readonly name: string) {\n    const message = `Invalid registry namespace: \"${name}\". Registry names must start with @ (e.g., @shadcn, @v0).`\n\n    super(message, {\n      code: RegistryErrorCode.VALIDATION_ERROR,\n      context: { name },\n      suggestion:\n        \"Use a valid registry name starting with @ or provide a direct URL to the registry.\",\n    })\n    this.name = \"RegistryInvalidNamespaceError\"\n  }\n}\n\nexport class ConfigMissingError extends RegistryError {\n  constructor(public readonly cwd: string) {\n    const message = `No components.json found in ${cwd} or parent directories.`\n\n    super(message, {\n      code: RegistryErrorCode.NOT_CONFIGURED,\n      context: { cwd },\n      suggestion:\n        \"Run 'npx shadcn@latest init' to create a components.json file, or check that you're in the correct directory.\",\n    })\n    this.name = \"ConfigMissingError\"\n  }\n}\n\nexport class ConfigParseError extends RegistryError {\n  constructor(public readonly cwd: string, parseError: unknown) {\n    let message = `Invalid components.json configuration in ${cwd}.`\n\n    if (parseError instanceof Error && parseError.message.includes(\"built-in registry and cannot be overridden\")) {\n      message = `Invalid components.json configuration in ${highlighter.info(`${cwd}/components.json`)}:\\n  - ${parseError.message}`\n    }\n\n    if (parseError instanceof SyntaxError) {\n      message = `Invalid components.json configuration in ${highlighter.info(`${cwd}/components.json`)}:\\n  - Syntax error: ${parseError.message.replace(`${cwd}/components.json`, \"\")}`\n    }\n\n    if (parseError instanceof z.ZodError) {\n      message = `Invalid components.json configuration in ${highlighter.info(`${cwd}/components.json`)}:\\n${parseError.errors\n        .map(e => `  - ${e.path.join(\".\")}: ${e.message}`)\n        .join(\"\\n\")}`\n    }\n\n    super(message, {\n      code: RegistryErrorCode.INVALID_CONFIG,\n      cause: parseError,\n      context: { cwd },\n      suggestion:\n        \"Check your components.json file for syntax errors or invalid configuration. Run 'npx shadcn@latest init' to regenerate a valid configuration.\",\n    })\n    this.name = \"ConfigParseError\"\n  }\n}\n\nexport class RegistriesIndexParseError extends RegistryError {\n  public readonly parseError: unknown\n\n  constructor(parseError: unknown) {\n    let message = \"Failed to parse registries index\"\n\n    if (parseError instanceof z.ZodError) {\n      const invalidNamespaces = parseError.errors\n        .filter(e => e.path.length > 0)\n        .map(e => `\"${e.path[0]}\"`)\n        .filter((v, i, arr) => arr.indexOf(v) === i) // remove duplicates\n\n      if (invalidNamespaces.length > 0) {\n        message = `Failed to parse registries index. Invalid registry namespace(s): ${invalidNamespaces.join(\n          \", \",\n        )}\\n${parseError.errors\n          .map(e => `  - ${e.path.join(\".\")}: ${e.message}`)\n          .join(\"\\n\")}`\n      }\n      else {\n        message = `Failed to parse registries index:\\n${parseError.errors\n          .map(e => `  - ${e.path.join(\".\")}: ${e.message}`)\n          .join(\"\\n\")}`\n      }\n    }\n\n    super(message, {\n      code: RegistryErrorCode.PARSE_ERROR,\n      cause: parseError,\n      context: { parseError },\n      suggestion:\n        \"The registries index may be corrupted or have invalid registry namespace format. Registry names must start with @ (e.g., @shadcn, @example).\",\n    })\n\n    this.parseError = parseError\n    this.name = \"RegistriesIndexParseError\"\n  }\n}\n","import type { TsConfigResult } from 'get-tsconfig'\nimport { createPathsMatcher } from 'get-tsconfig'\n\nexport function resolveImport(importPath: string, config: TsConfigResult) {\n  const matcher = createPathsMatcher(config)\n  if (matcher === null) {\n    return\n  }\n  const paths = matcher(importPath)\n  return paths[0]\n}\n","import type { z } from 'zod'\nimport { loadConfig } from 'c12'\nimport { getTsconfig } from 'get-tsconfig'\nimport path from 'pathe'\nimport { glob } from 'tinyglobby'\nimport { BUILTIN_REGISTRIES } from '@/src/registry/constants'\nimport { ConfigParseError } from '@/src/registry/errors'\nimport {\n  configSchema,\n  rawConfigSchema,\n  workspaceConfigSchema,\n} from '@/src/schema'\nimport { detectFrameworkConfigFiles, getProjectInfo, isTypeScriptProject } from '@/src/utils/get-project-info'\nimport { resolveImport } from '@/src/utils/resolve-import'\n\nexport const DEFAULT_STYLE = 'default'\nexport const DEFAULT_COMPONENTS = '@/components'\nexport const DEFAULT_UTILS = '@/lib/utils'\nexport const DEFAULT_TAILWIND_CSS = 'assets/css/tailwind.css' // decide to go with Nuxt's as default\nexport const DEFAULT_TAILWIND_CONFIG = 'tailwind.config.js'\nexport const DEFAULT_TAILWIND_BASE_COLOR = 'slate'\nexport const DEFAULT_TYPESCRIPT_CONFIG = './tsconfig.json'\n\nexport type Config = z.infer<typeof configSchema>\n\nexport async function getConfig(cwd: string) {\n  const config = await getRawConfig(cwd)\n\n  if (!config) {\n    return null\n  }\n\n  // Set default icon library if not provided.\n  if (!config.iconLibrary) {\n    config.iconLibrary = config.style === 'new-york' ? 'radix' : 'lucide'\n  }\n\n  return await resolveConfigPaths(cwd, config)\n}\n\nexport async function resolveConfigPaths(\n  cwd: string,\n  config: z.infer<typeof rawConfigSchema>,\n) {\n  // Merge built-in registries with user registries\n  config.registries = {\n    ...BUILTIN_REGISTRIES,\n    ...(config.registries || {}),\n  }\n\n  const detectedFramework = await detectFrameworkConfigFiles(cwd)\n  const isTypeScript = await isTypeScriptProject(cwd)\n\n  const tsConfigPath = path.resolve(\n    cwd,\n    detectedFramework?.name === 'nuxt4'\n      ? './.nuxt/tsconfig.app.json'\n      : detectedFramework?.name === 'nuxt3'\n        ? './.nuxt/tsconfig.json'\n        : detectedFramework?.name === 'inertia'\n          ? './inertia/tsconfig.json'\n          : isTypeScript\n            ? './tsconfig.json'\n            : './jsconfig.json',\n  )\n\n  // Read tsconfig.json.\n  const tsConfig = await getTsconfig(tsConfigPath, isTypeScript ? undefined : 'jsconfig.json')\n\n  if (tsConfig === null) {\n    throw new Error(\n      `Failed to load ${config.typescript ? 'tsconfig' : 'jsconfig'}.json.`.trim(),\n    )\n  }\n\n  return configSchema.parse({\n    ...config,\n    resolvedPaths: {\n      cwd,\n      tailwindConfig: config.tailwind.config\n        ? path.resolve(cwd, config.tailwind.config)\n        : '',\n      tailwindCss: path.resolve(cwd, config.tailwind.css),\n      utils: await resolveImport(config.aliases.utils, tsConfig),\n      components: await resolveImport(config.aliases.components, tsConfig),\n      ui: config.aliases.ui\n        ? await resolveImport(config.aliases.ui, tsConfig)\n        : path.resolve(\n            (await resolveImport(config.aliases.components, tsConfig))\n            ?? cwd,\n            'ui',\n          ),\n      // TODO: Make this configurable.\n      // For now, we assume the lib and composables directories are one level up from the components directory.\n      lib: config.aliases.lib\n        ? await resolveImport(config.aliases.lib, tsConfig)\n        : path.resolve(\n            (await resolveImport(config.aliases.utils, tsConfig)) ?? cwd,\n            '..',\n          ),\n      composables: config.aliases.composables\n        ? await resolveImport(config.aliases.composables, tsConfig)\n        : path.resolve(\n            (await resolveImport(config.aliases.components, tsConfig))\n            ?? cwd,\n            '..',\n            'composables',\n          ),\n    },\n  })\n}\n\nexport async function getRawConfig(\n  cwd: string,\n): Promise<z.infer<typeof rawConfigSchema> | null> {\n  try {\n    const configResult = await loadConfig({\n      name: 'components',\n      configFile: 'components',\n      cwd,\n      dotenv: false,\n      packageJson: false,\n      rcFile: false,\n      jitiOptions: {\n        rebuildFsCache: true,\n        moduleCache: true,\n      },\n    })\n\n    if (!configResult.config || Object.keys(configResult.config).length === 0) {\n      return null\n    }\n\n    const config = rawConfigSchema.parse(configResult.config)\n\n    // Check if user is trying to override built-in registries\n    if (config.registries) {\n      for (const registryName of Object.keys(config.registries)) {\n        if (registryName in BUILTIN_REGISTRIES) {\n          throw new Error(\n            `\"${registryName}\" is a built-in registry and cannot be overridden.`,\n          )\n        }\n      }\n    }\n\n    return config\n  }\n  catch (error) {\n    throw new ConfigParseError(cwd, error)\n  }\n}\n\n// Note: we can check for -workspace.yaml or \"workspace\" in package.json.\n// Since cwd is not necessarily the root of the project.\n// We'll instead check if ui aliases resolve to a different root.\nexport async function getWorkspaceConfig(config: Config) {\n  // eslint-disable-next-line prefer-const\n  let resolvedAliases: any = {}\n\n  for (const key of Object.keys(config.aliases)) {\n    if (!isAliasKey(key, config)) {\n      continue\n    }\n\n    const resolvedPath = config.resolvedPaths[key]\n    const packageRoot = await findPackageRoot(\n      config.resolvedPaths.cwd,\n      resolvedPath!,\n    )\n\n    if (!packageRoot) {\n      resolvedAliases[key] = config\n      continue\n    }\n\n    resolvedAliases[key] = await getConfig(packageRoot)\n  }\n\n  const result = workspaceConfigSchema.safeParse(resolvedAliases)\n  if (!result.success) {\n    return null\n  }\n\n  return result.data\n}\n\nexport async function findPackageRoot(cwd: string, resolvedPath: string) {\n  const commonRoot = findCommonRoot(cwd, resolvedPath)\n  const relativePath = path.relative(commonRoot, resolvedPath)\n\n  const packageRoots = await glob('**/package.json', {\n    cwd: commonRoot,\n    deep: 3,\n    ignore: ['**/node_modules/**', '**/dist/**', '**/build/**', '**/public/**'],\n  })\n\n  const matchingPackageRoot = packageRoots\n    .map(pkgPath => path.dirname(pkgPath))\n    .find(pkgDir => relativePath.startsWith(pkgDir))\n\n  return matchingPackageRoot ? path.join(commonRoot, matchingPackageRoot) : null\n}\n\nfunction isAliasKey(\n  key: string,\n  config: Config,\n): key is keyof Config['aliases'] {\n  return Object.keys(config.resolvedPaths)\n    .filter(key => key !== 'utils')\n    .includes(key)\n}\n\nexport function findCommonRoot(cwd: string, resolvedPath: string) {\n  const parts1 = cwd.split(path.sep)\n  const parts2 = resolvedPath.split(path.sep)\n  const commonParts = []\n\n  for (let i = 0; i < Math.min(parts1.length, parts2.length); i++) {\n    if (parts1[i] !== parts2[i]) {\n      break\n    }\n    commonParts.push(parts1[i])\n  }\n\n  return commonParts.join(path.sep)\n}\n\n// TODO: Cache this call.\nexport async function getTargetStyleFromConfig(cwd: string, fallback: string) {\n  const projectInfo = await getProjectInfo(cwd)\n  return projectInfo?.tailwindVersion === 'v4' ? 'new-york-v4' : fallback\n}\n\ntype DeepPartial<T> = {\n  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P]\n}\n\n/**\n * Creates a config object with sensible defaults.\n * Useful for universal registry items that bypass framework detection.\n *\n * @param partial - Partial config values to override defaults\n * @returns A complete Config object\n */\nexport function createConfig(partial?: DeepPartial<Config>): Config {\n  const defaultConfig: Config = {\n    typescript: true,\n    resolvedPaths: {\n      cwd: process.cwd(),\n      tailwindConfig: '',\n      tailwindCss: '',\n      utils: '',\n      components: '',\n      ui: '',\n      lib: '',\n      composables: '',\n    },\n    style: '',\n    tailwind: {\n      config: '',\n      css: '',\n      baseColor: '',\n      cssVariables: false,\n    },\n    // rsc: false,\n    // tsx: true,\n    aliases: {\n      components: '',\n      utils: '',\n    },\n    registries: {\n      ...BUILTIN_REGISTRIES,\n    },\n  }\n\n  // Deep merge the partial config with defaults\n  if (partial) {\n    return {\n      ...defaultConfig,\n      ...partial,\n      resolvedPaths: {\n        ...defaultConfig.resolvedPaths,\n        ...(partial.resolvedPaths || {}),\n      },\n      tailwind: {\n        ...defaultConfig.tailwind,\n        ...(partial.tailwind || {}),\n      },\n      aliases: {\n        ...defaultConfig.aliases,\n        ...(partial.aliases || {}),\n      },\n      registries: {\n        ...defaultConfig.registries,\n        ...(partial.registries || {}),\n      },\n    }\n  }\n\n  return defaultConfig\n}\n","import type { PackageJson } from 'type-fest'\nimport fs from 'fs-extra'\nimport path from 'pathe'\n\nexport function getPackageInfo(\n  cwd: string = '',\n  shouldThrow: boolean = true,\n): PackageJson | null {\n  const packageJsonPath = path.join(cwd, 'package.json')\n\n  return fs.readJSONSync(packageJsonPath, {\n    throws: shouldThrow,\n  }) as PackageJson\n}\n","import type { rawConfigSchema } from '@/src/schema'\nimport type { Framework } from '@/src/utils/frameworks'\nimport type { Config } from '@/src/utils/get-config'\nimport fs from 'fs-extra'\nimport { getTsconfig } from 'get-tsconfig'\nimport path from 'pathe'\nimport { coerce } from 'semver'\nimport { glob } from 'tinyglobby'\nimport { z } from 'zod'\nimport { FRAMEWORKS } from '@/src/utils/frameworks'\nimport { getConfig, resolveConfigPaths } from '@/src/utils/get-config'\nimport { getPackageInfo } from '@/src/utils/get-package-info'\n\nexport type TailwindVersion = 'v3' | 'v4' | null\n\nexport interface ProjectInfo {\n  framework: Framework\n  isSrcDir: boolean\n  // isRSC: boolean\n  // isTsx: boolean\n  typescript: boolean\n  tailwindConfigFile: string | null\n  tailwindCssFile: string | null\n  tailwindVersion: TailwindVersion\n  aliasPrefix: string | null\n}\n\nconst PROJECT_SHARED_IGNORE = [\n  '**/node_modules/**',\n  '.nuxt',\n  'public',\n  'dist',\n  'build',\n]\n\nconst TS_CONFIG_SCHEMA = z.object({\n  compilerOptions: z.object({\n    paths: z.record(z.string().or(z.array(z.string()))),\n  }),\n})\n\nexport async function detectFrameworkConfigFiles(cwd: string): Promise<Framework | null> {\n  const packageInfo = await getPackageInfo(cwd, false)\n  const configFiles = await glob('**/{nuxt,vite,astro,wxt}.config.*|composer.json', {\n    cwd,\n    deep: 3,\n    ignore: PROJECT_SHARED_IGNORE,\n  })\n\n  // Check for Nuxt\n  if (configFiles.find(file => file.startsWith('nuxt.config.'))) {\n    const nuxtPkg = packageInfo?.dependencies?.nuxt || packageInfo?.devDependencies?.nuxt\n    const nuxtVersion = (nuxtPkg && coerce(nuxtPkg)?.version) || '4.0.0'\n\n    if (nuxtVersion.startsWith('4')) {\n      return FRAMEWORKS.nuxt4\n    }\n    else if (nuxtVersion.startsWith('3')) {\n      return FRAMEWORKS.nuxt3\n    }\n\n    return null\n  }\n\n  // Check for Astro\n  if (configFiles.find(file => file.startsWith('astro.config.'))) {\n    return FRAMEWORKS.astro\n  }\n\n  // Check for Laravel\n  if (configFiles.find(file => file.startsWith('composer.json'))) {\n    return FRAMEWORKS.laravel\n  }\n\n  if (packageInfo?.dependencies?.['@inertiajs/vue3']\n    || packageInfo?.devDependencies?.['@inertiajs/vue3'] || (await fs.pathExists(path.join(cwd, 'resources/js')))) {\n    return FRAMEWORKS.inertia\n  }\n\n  // Check for WXT\n  if (configFiles.find(file => file.startsWith('wxt.config.'))) {\n    return FRAMEWORKS.vite\n  }\n\n  // Check for Vite\n  if (configFiles.find(file => file.startsWith('vite.config.'))) {\n    return FRAMEWORKS.vite\n  }\n\n  return null\n}\n\nexport async function isTypeScriptProject(cwd: string) {\n  const files = await glob('tsconfig.*', {\n    cwd,\n    deep: 1,\n    ignore: PROJECT_SHARED_IGNORE,\n  })\n\n  return files.length > 0\n}\n\nexport async function getProjectInfo(cwd: string): Promise<ProjectInfo | null> {\n  const [\n    detectedFramework,\n    typescript,\n    isSrcDir,\n    // isTsx,\n    tailwindConfigFile,\n    tailwindCssFile,\n    tailwindVersion,\n    aliasPrefix,\n    packageJson,\n  ] = await Promise.all([\n    detectFrameworkConfigFiles(cwd),\n    isTypeScriptProject(cwd),\n    fs.pathExists(path.resolve(cwd, 'src')),\n    getTailwindConfigFile(cwd),\n    getTailwindCssFile(cwd),\n    getTailwindVersion(cwd),\n    getTsConfigAliasPrefix(cwd),\n    getPackageInfo(cwd, false),\n  ])\n\n  const type: ProjectInfo = {\n    framework: detectedFramework || FRAMEWORKS.manual,\n    typescript,\n    isSrcDir,\n    tailwindConfigFile,\n    tailwindCssFile,\n    tailwindVersion,\n    aliasPrefix,\n  }\n\n  return type\n}\n\nexport async function getTailwindVersion(\n  cwd: string,\n): Promise<ProjectInfo['tailwindVersion']> {\n  const [packageInfo, config] = await Promise.all([\n    getPackageInfo(cwd, false),\n    getConfig(cwd),\n  ])\n\n  // If the config file is empty, we can assume that it's a v4 project.\n  if (config?.tailwind?.config === '') {\n    return 'v4'\n  }\n\n  const hasNuxtTailwind = !!(\n    packageInfo?.dependencies?.['@nuxtjs/tailwindcss']\n    || packageInfo?.devDependencies?.['@nuxtjs/tailwindcss']\n  )\n\n  const hasTailwindCss = !!(\n    packageInfo?.dependencies?.tailwindcss\n    || packageInfo?.devDependencies?.tailwindcss\n  )\n\n  if (!hasTailwindCss && !hasNuxtTailwind) {\n    return null\n  }\n\n  if (\n    /^(?:\\^|~)?3(?:\\.\\d+)*(?:-.*)?$/.test(\n      packageInfo?.dependencies?.tailwindcss\n      || packageInfo?.devDependencies?.tailwindcss\n      || '',\n    )\n  ) {\n    return 'v3'\n  }\n\n  return 'v4'\n}\n\nexport async function getTailwindCssFile(cwd: string) {\n  const [files, tailwindVersion] = await Promise.all([\n    glob(['**/*.css', '**/*.scss'], {\n      cwd,\n      deep: 5,\n      ignore: PROJECT_SHARED_IGNORE,\n    }),\n    getTailwindVersion(cwd),\n  ])\n\n  if (!files.length) {\n    return null\n  }\n\n  const needle\n    = tailwindVersion === 'v4' ? `@import \"tailwindcss\"` : '@tailwind base'\n  for (const file of files) {\n    const contents = await fs.readFile(path.resolve(cwd, file), 'utf8')\n    if (\n      contents.includes(`@import \"tailwindcss\"`)\n      || contents.includes(`@import 'tailwindcss'`)\n      || contents.includes(`@tailwind base`)\n    ) {\n      return file\n    }\n  }\n\n  return null\n}\n\nexport async function getTailwindConfigFile(cwd: string) {\n  const files = await glob('tailwind.config.*', {\n    cwd,\n    deep: 3,\n    ignore: PROJECT_SHARED_IGNORE,\n  })\n\n  if (!files.length) {\n    return null\n  }\n\n  return files[0]\n}\n\nexport async function getTsConfigAliasPrefix(cwd: string) {\n  const detectedFramework = await detectFrameworkConfigFiles(cwd)\n  const isTypeScript = await isTypeScriptProject(cwd)\n  const tsConfig = await getTsconfig(cwd, detectedFramework?.name === 'nuxt4'\n    ? './.nuxt/tsconfig.app.json'\n    : detectedFramework?.name === 'nuxt3'\n      ? './.nuxt/tsconfig.json'\n      : detectedFramework?.name === 'inertia'\n        ? './inertia/tsconfig.json'\n        : isTypeScript\n          ? './tsconfig.json'\n          : './jsconfig.json')\n\n  if (\n    tsConfig === null\n    || !Object.entries(tsConfig.config.compilerOptions?.paths ?? {}).length\n  ) {\n    return null\n  }\n\n  const aliasPaths = tsConfig.config.compilerOptions?.paths ?? {}\n\n  // This assume that the first alias is the prefix.\n  for (const [alias, paths] of Object.entries(aliasPaths)) {\n    if (\n      paths.includes('./*')\n      || paths.includes('./src/*')\n      || paths.includes('./app/*')\n      || paths.includes('./resources/js/*') // Laravel.\n    ) {\n      const cleanAlias = alias.replace(/\\/\\*$/, '') ?? null\n      // handle Nuxt\n      return cleanAlias === '#build' ? '@' : cleanAlias\n    }\n  }\n\n  // Use the first alias as the prefix.\n  return Object.keys(aliasPaths)?.[0]?.replace(/\\/\\*$/, '') ?? null\n}\n\nexport async function getTsConfig(cwd: string) {\n  for (const fallback of [\n    'tsconfig.json',\n    'tsconfig.web.json',\n    'tsconfig.app.json',\n  ]) {\n    const filePath = path.resolve(cwd, fallback)\n    if (!(await fs.pathExists(filePath))) {\n      continue\n    }\n\n    // We can't use fs.readJSON because it doesn't support comments.\n    const contents = await fs.readFile(filePath, 'utf8')\n    const cleanedContents = contents.replace(/\\/\\*\\s*\\*\\//g, '')\n    const result = TS_CONFIG_SCHEMA.safeParse(JSON.parse(cleanedContents))\n\n    if (result.error) {\n      continue\n    }\n\n    return result.data\n  }\n\n  return null\n}\n\nexport async function getProjectConfig(\n  cwd: string,\n  defaultProjectInfo: ProjectInfo | null = null,\n): Promise<Config | null> {\n  // Check for existing component config.\n  const [existingConfig, projectInfo] = await Promise.all([\n    getConfig(cwd),\n    !defaultProjectInfo\n      ? getProjectInfo(cwd)\n      : Promise.resolve(defaultProjectInfo),\n  ])\n\n  if (existingConfig) {\n    return existingConfig\n  }\n\n  if (\n    !projectInfo\n    || !projectInfo.tailwindCssFile\n    || (projectInfo.tailwindVersion === 'v3' && !projectInfo.tailwindConfigFile)\n  ) {\n    return null\n  }\n\n  const config: z.infer<typeof rawConfigSchema> = {\n    $schema: 'https://shadcn-vue.com/schema.json',\n    // rsc: projectInfo.isRSC,\n    // tsx: projectInfo.isTsx,\n    typescript: projectInfo.typescript,\n    style: 'new-york',\n    tailwind: {\n      config: projectInfo.tailwindConfigFile ?? '',\n      baseColor: 'zinc',\n      css: projectInfo.tailwindCssFile,\n      cssVariables: true,\n      prefix: '',\n    },\n    iconLibrary: 'lucide',\n    aliases: {\n      components: `${projectInfo.aliasPrefix}/components`,\n      ui: `${projectInfo.aliasPrefix}/components/ui`,\n      composables: `${projectInfo.aliasPrefix}/composables`,\n      lib: `${projectInfo.aliasPrefix}/lib`,\n      utils: `${projectInfo.aliasPrefix}/lib/utils`,\n    },\n  }\n\n  return await resolveConfigPaths(cwd, config)\n}\n\nexport async function getProjectTailwindVersionFromConfig(config: {\n  resolvedPaths: Pick<Config['resolvedPaths'], 'cwd'>\n}): Promise<TailwindVersion> {\n  if (!config.resolvedPaths?.cwd) {\n    return 'v3'\n  }\n\n  const projectInfo = await getProjectInfo(config.resolvedPaths.cwd)\n\n  if (!projectInfo?.tailwindVersion) {\n    return null\n  }\n\n  return projectInfo.tailwindVersion\n}\n","import consola from 'consola'\nimport { highlighter } from '@/src/utils/highlighter'\n\nexport const logger = {\n  error(...args: unknown[]) {\n    consola.log(highlighter.error(args.join(' ')))\n  },\n  warn(...args: unknown[]) {\n    consola.log(highlighter.warn(args.join(' ')))\n  },\n  info(...args: unknown[]) {\n    consola.log(highlighter.info(args.join(' ')))\n  },\n  success(...args: unknown[]) {\n    consola.log(highlighter.success(args.join(' ')))\n  },\n  log(...args: unknown[]) {\n    consola.log(args.join(' '))\n  },\n  break() {\n    consola.log('')\n  },\n}\n","import type { Options } from 'ora'\nimport ora from 'ora'\n\nexport function spinner(\n  text: Options['text'],\n  options?: {\n    silent?: boolean\n  },\n) {\n  return ora({\n    text,\n    isSilent: options?.silent,\n  })\n}\n","export function expandEnvVars(value: string) {\n  return value.replace(/\\$\\{(\\w+)\\}/g, (_match, key) => process.env[key] || \"\")\n}\n\nexport function extractEnvVars(value: string) {\n  const vars: string[] = []\n  const regex = /\\$\\{(\\w+)\\}/g\n  let match: RegExpExecArray | null\n\n  // eslint-disable-next-line no-cond-assign\n  while ((match = regex.exec(value)) !== null) {\n    vars.push(match[1])\n  }\n\n  return vars\n}\n","// Valid registry name pattern: @namespace where namespace is alphanumeric with hyphens/underscores\nconst REGISTRY_PATTERN = /^(@[a-z0-9](?:[\\w-]*[a-z0-9])?)\\/(.+)$/i\n\nexport function parseRegistryAndItemFromString(name: string) {\n  if (!name.startsWith(\"@\")) {\n    return {\n      registry: null,\n      item: name,\n    }\n  }\n\n  const match = name.match(REGISTRY_PATTERN)\n  if (match) {\n    return {\n      registry: match[1],\n      item: match[2],\n    }\n  }\n\n  return {\n    registry: null,\n    item: name,\n  }\n}\n","export function isContentSame(\n  existingContent: string,\n  newContent: string,\n  options: {\n    ignoreImports?: boolean\n  } = {},\n) {\n  const { ignoreImports = false } = options\n\n  // Normalize line endings and whitespace.\n  const normalizedExisting = existingContent.replace(/\\r\\n/g, '\\n').trim()\n  const normalizedNew = newContent.replace(/\\r\\n/g, '\\n').trim()\n\n  // First, try exact match after normalization.\n  if (normalizedExisting === normalizedNew) {\n    return true\n  }\n\n  // If not ignoring imports or exact match failed, return false\n  if (!ignoreImports) {\n    return false\n  }\n\n  // Compare with import statements normalized.\n  // This regex matches various import patterns including:\n  // - import defaultExport from \"module\"\n  // - import * as name from \"module\"\n  // - import { export1, export2 } from \"module\"\n  // - import { export1 as alias1 } from \"module\"\n  // - import defaultExport, { export1 } from \"module\"\n  // - import type { Type } from \"module\"\n  // - This Regex written by Claude Code.\n  const importRegex\n    // eslint-disable-next-line regexp/no-super-linear-backtracking\n    = /^(import\\s+(?:type\\s+)?(?:\\*\\s+as\\s+\\w+|\\{[^}]*\\}|\\w+)?(?:\\s*,\\s*(?:\\{[^}]*\\}|\\w+))?\\s+from\\s+[\"'])([^\"']+)([\"'])/gm\n\n  // Function to normalize import paths - remove alias differences.\n  const normalizeImports = (content: string) => {\n    return content.replace(\n      importRegex,\n      (_match, prefix, importPath, suffix) => {\n        // Keep relative imports as-is.\n        if (importPath.startsWith('.')) {\n          return `${prefix}${importPath}${suffix}`\n        }\n\n        // For aliased imports, normalize to a common format.\n        // Extract the last meaningful part of the path.\n        const parts = importPath.split('/')\n        const lastPart = parts[parts.length - 1]\n\n        // Normalize to a consistent format.\n        return `${prefix}@normalized/${lastPart}${suffix}`\n      },\n    )\n  }\n\n  const existingNormalized = normalizeImports(normalizedExisting)\n  const newNormalized = normalizeImports(normalizedNew)\n\n  return existingNormalized === newNormalized\n}\n","import { existsSync } from 'node:fs'\nimport path from 'pathe'\n\nexport function isEnvFile(filePath: string) {\n  const fileName = path.basename(filePath)\n  return /^\\.env(?:\\.|$)/.test(fileName)\n}\n\n/**\n * Finds a file variant in the project.\n * TODO: abstract this to a more generic function.\n */\nexport function findExistingEnvFile(targetDir: string) {\n  const variants = [\n    '.env.local',\n    '.env',\n    '.env.development.local',\n    '.env.development',\n  ]\n\n  for (const variant of variants) {\n    const filePath = path.join(targetDir, variant)\n    if (existsSync(filePath)) {\n      return filePath\n    }\n  }\n\n  return null\n}\n\n/**\n * Parse .env content into key-value pairs.\n */\nexport function parseEnvContent(content: string) {\n  const lines = content.split('\\n')\n  const env: Record<string, string> = {}\n\n  for (const line of lines) {\n    const trimmed = line.trim()\n\n    if (!trimmed || trimmed.startsWith('#')) {\n      continue\n    }\n\n    // Find the first = and split there\n    const equalIndex = trimmed.indexOf('=')\n    if (equalIndex === -1) {\n      continue\n    }\n\n    const key = trimmed.substring(0, equalIndex).trim()\n    const value = trimmed.substring(equalIndex + 1).trim()\n\n    if (key) {\n      env[key] = value.replace(/^[\"']|[\"']$/g, '')\n    }\n  }\n\n  return env\n}\n\n/**\n * Get the list of new keys that would be added when merging env content.\n */\nexport function getNewEnvKeys(existingContent: string, newContent: string) {\n  const existingEnv = parseEnvContent(existingContent)\n  const newEnv = parseEnvContent(newContent)\n\n  const newKeys = []\n  for (const key of Object.keys(newEnv)) {\n    if (!(key in existingEnv)) {\n      newKeys.push(key)\n    }\n  }\n\n  return newKeys\n}\n\n/**\n * Merge env content by appending ONLY new keys that don't exist in the existing content.\n * Existing keys are preserved with their original values.\n */\nexport function mergeEnvContent(existingContent: string, newContent: string) {\n  const existingEnv = parseEnvContent(existingContent)\n  const newEnv = parseEnvContent(newContent)\n\n  let result = existingContent.trimEnd()\n  if (result && !result.endsWith('\\n')) {\n    result += '\\n'\n  }\n\n  const newKeys: string[] = []\n  for (const [key, value] of Object.entries(newEnv)) {\n    if (!(key in existingEnv)) {\n      newKeys.push(`${key}=${value}`)\n    }\n  }\n\n  if (newKeys.length > 0) {\n    if (result) {\n      result += '\\n'\n    }\n    result += newKeys.join('\\n')\n    return `${result}\\n`\n  }\n\n  // Ensure existing content ends with newline.\n  if (result && !result.endsWith('\\n')) {\n    return `${result}\\n`\n  }\n\n  return result\n}\n","import type { CodemodPlugin } from 'vue-metamorph'\nimport type * as z from 'zod'\nimport type { TransformOpts } from '.'\nimport type { registryBaseColorSchema } from '@/src/schema'\n\nexport function transformCssVars(opts: TransformOpts): CodemodPlugin {\n  return {\n    type: 'codemod',\n    name: 'add prefix to tailwind classes',\n\n    transform({ scriptASTs, sfcAST, utils: { traverseScriptAST, traverseTemplateAST } }) {\n      let transformCount = 0\n      const { baseColor, config } = opts\n\n      if (config.tailwind?.cssVariables || !baseColor?.inlineColors)\n        return transformCount\n\n      for (const scriptAST of scriptASTs) {\n        traverseScriptAST(scriptAST, {\n          visitLiteral(path) {\n            if (path.parent.value.type !== 'ImportDeclaration' && typeof path.node.value === 'string') {\n              // mutate the node\n              const raw = path.node.value\n              const mapped = applyColorMapping(raw, baseColor.inlineColors).trim()\n              if (mapped !== raw) {\n                path.node.value = mapped\n                transformCount++\n              }\n            }\n\n            return this.traverse(path)\n          },\n        })\n      }\n\n      if (sfcAST) {\n        traverseTemplateAST(sfcAST, {\n          enterNode(node) {\n            if (node.type === 'Literal' && typeof node.value === 'string') {\n              if (!['BinaryExpression', 'Property'].includes(node.parent?.type ?? '')) {\n                const raw = node.value\n                const mapped = applyColorMapping(raw, baseColor.inlineColors).trim()\n                if (mapped !== raw) {\n                  node.value = mapped\n                  transformCount++\n                }\n              }\n            }\n            // handle class attribute without binding\n            else if (node.type === 'VLiteral' && typeof node.value === 'string') {\n              if (node.parent.key.name === 'class') {\n                const raw = node.value\n                const mapped = applyColorMapping(raw, baseColor.inlineColors).trim()\n                if (mapped !== raw) {\n                  node.value = mapped\n                  transformCount++\n                }\n              }\n            }\n          },\n          leaveNode() {\n\n          },\n        })\n      }\n\n      return transformCount\n    },\n  }\n}\n\n// Splits a className into variant-name-alpha.\n// eg. hover:bg-primary-100 -> [hover, bg-primary, 100]\nexport function splitClassName(className: string): (string | null)[] {\n  if (!className.includes('/') && !className.includes(':'))\n    return [null, className, null]\n\n  const parts: (string | null)[] = []\n  // First we split to find the alpha.\n  const [rest, alpha] = className.split('/')\n\n  // Check if rest has a colon.\n  if (!rest.includes(':'))\n    return [null, rest, alpha]\n\n  // Next we split the rest by the colon.\n  const split = rest.split(':')\n\n  // We take the last item from the split as the name.\n  const name = split.pop()\n\n  // We glue back the rest of the split.\n  const variant = split.join(':')\n\n  // Finally we push the variant, name and alpha.\n  parts.push(variant ?? null, name ?? null, alpha ?? null)\n\n  return parts\n}\n\nconst PREFIXES = ['bg-', 'text-', 'border-', 'ring-offset-', 'ring-']\n\nexport function applyColorMapping(\n  input: string,\n  mapping: z.infer<typeof registryBaseColorSchema>['inlineColors'],\n) {\n  // Handle border classes.\n  if (input.includes(' border '))\n    input = input.replace(' border ', ' border border-border ')\n\n  const classNames = input.split(' ')\n  const lightMode = new Set<string>()\n  const darkMode = new Set<string>()\n  for (const className of classNames) {\n    const [variant, value, modifier] = splitClassName(className)\n    const prefix = PREFIXES.find(prefix => value?.startsWith(prefix))\n    if (!prefix) {\n      if (!lightMode.has(className))\n        lightMode.add(className)\n\n      continue\n    }\n\n    const needle = value?.replace(prefix, '')\n    if (needle && needle in mapping.light) {\n      lightMode.add(\n        [variant, `${prefix}${mapping.light[needle]}`]\n          .filter(Boolean)\n          .join(':') + (modifier ? `/${modifier}` : ''),\n      )\n\n      darkMode.add(\n        ['dark', variant, `${prefix}${mapping.dark[needle]}`]\n          .filter(Boolean)\n          .join(':') + (modifier ? `/${modifier}` : ''),\n      )\n      continue\n    }\n\n    if (!lightMode.has(className))\n      lightMode.add(className)\n  }\n\n  return [...Array.from(lightMode), ...Array.from(darkMode)].join(' ').trim()\n}\n","import type { CodemodPlugin } from 'vue-metamorph'\nimport type { TransformOpts } from '.'\n\nexport function transformImport(opts: TransformOpts): CodemodPlugin {\n  return {\n    type: 'codemod',\n    name: 'modify import based on user config',\n\n    transform({ scriptASTs, utils: { traverseScriptAST } }) {\n      let transformCount = 0\n      const { config, isRemote } = opts\n\n      const utilsAlias = config.aliases?.utils\n      const workspaceAlias\n        = typeof utilsAlias === 'string' && utilsAlias.includes('/')\n          ? utilsAlias.split('/')[0]\n          : '@'\n      const utilsImport = `${workspaceAlias}/lib/utils`\n\n      for (const scriptAST of scriptASTs) {\n        traverseScriptAST(scriptAST, {\n          visitLiteral(path) {\n            if (typeof path.node.value === 'string') {\n              const parent = path.parent.value\n\n              // Handle both static imports and dynamic imports\n              if (parent.type === 'ImportDeclaration'\n                || (parent.type === 'CallExpression' && parent.callee?.name === 'import')) {\n                const sourcePath = path.node.value\n                const updatedImport = updateImportAliases(sourcePath, config, isRemote)\n\n                if (updatedImport !== sourcePath) {\n                  path.node.value = updatedImport\n                  transformCount++\n                }\n\n                // Replace `import { cn } from \"@/lib/utils\"` or `await import(\"@/lib/utils\")`\n                if (utilsImport === updatedImport || updatedImport === '@/lib/utils') {\n                  // For static imports, check named imports\n                  if (parent.type === 'ImportDeclaration') {\n                    const namedImports = parent.specifiers?.map(node => node.local?.name ?? '') ?? []\n                    const isCnImport = namedImports.find(i => i === 'cn')\n\n                    if (isCnImport && config.aliases.utils) {\n                      path.node.value = utilsImport === updatedImport\n                        ? updatedImport.replace(utilsImport, config.aliases.utils)\n                        : config.aliases.utils\n                      transformCount++\n                    }\n                  }\n                  // For dynamic imports, we need to check the context differently\n                  // This is a simplified approach - you might need more sophisticated checking\n                  else if (parent.type === 'CallExpression') {\n                    // Check if this dynamic import is destructuring cn\n                    // This would require more complex AST traversal to determine usage\n                    const grandParent = path.parent.parent?.value\n                    if (grandParent?.type === 'VariableDeclarator'\n                      && grandParent.id?.type === 'ObjectPattern') {\n                      const hasCnProperty = grandParent.id.properties?.some(\n                        prop => prop.key?.name === 'cn',\n                      )\n\n                      if (hasCnProperty && config.aliases.utils) {\n                        path.node.value = utilsImport === updatedImport\n                          ? updatedImport.replace(utilsImport, config.aliases.utils)\n                          : config.aliases.utils\n                        transformCount++\n                      }\n                    }\n                  }\n                }\n              }\n            }\n            return this.traverse(path)\n          },\n        })\n      }\n\n      return transformCount\n    },\n  }\n}\n\nfunction updateImportAliases(\n  moduleSpecifier: string,\n  config: TransformOpts['config'],\n  isRemote: boolean = false,\n) {\n  // Not a local import.\n  if (!moduleSpecifier.startsWith('@/') && !isRemote) {\n    return moduleSpecifier\n  }\n\n  // This treats the remote as coming from a faux registry.\n  if (isRemote && moduleSpecifier.startsWith('@/')) {\n    moduleSpecifier = moduleSpecifier.replace(/^@\\//, `@/registry/new-york/`)\n  }\n\n  // Not a registry import.\n  if (!moduleSpecifier.startsWith('@/registry/')) {\n    // We fix the alias and return.\n    const alias = config.aliases.components.split('/')[0]\n    return moduleSpecifier.replace(/^@\\//, `${alias}/`)\n  }\n\n  if (moduleSpecifier.match(/^@\\/registry\\/(.+)\\/ui/)) {\n    return moduleSpecifier.replace(\n      /^@\\/registry\\/(.+)\\/ui/,\n      config.aliases.ui ?? `${config.aliases.components}/ui`,\n    )\n  }\n\n  if (\n    config.aliases.components\n    && moduleSpecifier.match(/^@\\/registry\\/(.+)\\/components/)\n  ) {\n    return moduleSpecifier.replace(\n      /^@\\/registry\\/(.+)\\/components/,\n      config.aliases.components,\n    )\n  }\n\n  if (config.aliases.lib && moduleSpecifier.match(/^@\\/registry\\/(.+)\\/lib/)) {\n    return moduleSpecifier.replace(\n      /^@\\/registry\\/(.+)\\/lib/,\n      config.aliases.lib,\n    )\n  }\n\n  if (\n    config.aliases.composables\n    && moduleSpecifier.match(/^@\\/registry\\/(.+)\\/composables/)\n  ) {\n    return moduleSpecifier.replace(\n      /^@\\/registry\\/(.+)\\/composables/,\n      config.aliases.composables,\n    )\n  }\n\n  return moduleSpecifier.replace(\n    /^@\\/registry\\/[^/]+/,\n    config.aliases.components,\n  )\n}\n","import type { TransformOpts } from '.'\nimport { transform } from '@unovue/detypes'\n\nexport async function transformSFC(opts: TransformOpts) {\n  if (opts.config?.typescript)\n    return opts.raw\n\n  return await transformByDetype(opts.raw, opts.filename).then(res => res as string)\n}\n\nexport async function transformByDetype(content: string, filename: string) {\n  return await transform(content, filename, {\n    removeTsComments: true,\n    prettierOptions: {\n      proseWrap: 'never',\n    },\n  })\n}\n","import type { CodemodPlugin } from 'vue-metamorph'\nimport type { TransformOpts } from '.'\nimport type { TailwindVersion } from '../get-project-info'\nimport { getProjectTailwindVersionFromConfig } from '../get-project-info'\nimport { splitClassName } from './transform-css-vars'\n\nexport async function transformTwPrefix(opts: TransformOpts): Promise<CodemodPlugin> {\n  const tailwindVersion = await getProjectTailwindVersionFromConfig(opts.config)\n\n  return {\n    type: 'codemod',\n    name: 'add prefix to tailwind classes',\n\n    transform({ scriptASTs, sfcAST, utils: { traverseScriptAST, traverseTemplateAST, astHelpers } }) {\n      let transformCount = 0\n      const { config } = opts\n\n      if (!config.tailwind?.prefix)\n        return transformCount\n\n      const addPrefix = (input: string) => {\n        const result = applyPrefix(input, config.tailwind.prefix, tailwindVersion)\n        transformCount++\n\n        return result\n      }\n\n      // Helper function to check if a node is a variant property\n      function isVariantProperty(node: any): boolean {\n        if (node.type === 'Property') {\n          // Check if property key is \"variant\", \"size\", etc.\n          if (node.key?.type === 'Identifier') {\n            const keyName = node.key.name\n            return ['variant', 'size', 'color', 'type', 'state'].includes(keyName)\n          }\n          if (node.key?.type === 'Literal' && typeof node.key.value === 'string') {\n            const keyName = node.key.value\n            return ['variant', 'size', 'color', 'type', 'state'].includes(keyName)\n          }\n        }\n        return false\n      }\n\n      function traverseExpression(expression: any): void {\n        // Handle cn() function calls\n        if (expression.type === 'CallExpression'\n          && expression.callee?.type === 'Identifier'\n          && expression.callee.name === 'cn') {\n          expression.arguments.forEach((arg: any) => {\n            if (arg.type === 'Literal' && typeof arg.value === 'string') {\n              arg.value = addPrefix(arg.value)\n            }\n            else if (arg.type === 'ConditionalExpression') {\n              // Only transform consequent and alternate, not the test condition\n              if (arg.consequent?.type === 'Literal' && typeof arg.consequent.value === 'string') {\n                arg.consequent.value = addPrefix(arg.consequent.value)\n              }\n              if (arg.alternate?.type === 'Literal' && typeof arg.alternate.value === 'string') {\n                arg.alternate.value = addPrefix(arg.alternate.value)\n              }\n            }\n            else if (arg.type === 'BinaryExpression') {\n              // Only transform the right side if it's a string literal\n              if (arg.right?.type === 'Literal' && typeof arg.right.value === 'string') {\n                arg.right.value = addPrefix(arg.right.value)\n              }\n            }\n            else if (arg.type === 'ObjectExpression') {\n              // Handle object expressions like { variant: 'ghost', class: 'flex' }\n              arg.properties.forEach((prop: any) => {\n                if (prop.type === 'Property' && prop.value?.type === 'Literal' && typeof prop.value.value === 'string') {\n                  // Only transform if it's NOT a variant property\n                  if (!isVariantProperty(prop)) {\n                    prop.value.value = addPrefix(prop.value.value)\n                  }\n                }\n              })\n            }\n            else {\n              // For other expression types, use astHelpers to find all literals\n              const literals = astHelpers.findAll(arg, { type: 'Literal' })\n              literals.forEach((literal: any) => {\n                if (typeof literal.value === 'string') {\n                  // Check if this literal is part of a variant property\n                  let shouldTransform = true\n                  let parent = literal.parent\n                  while (parent) {\n                    if (isVariantProperty(parent)) {\n                      shouldTransform = false\n                      break\n                    }\n                    parent = parent.parent\n                  }\n\n                  if (shouldTransform) {\n                    literal.value = addPrefix(literal.value)\n                  }\n                }\n              })\n            }\n          })\n        }\n        // Handle other expression types recursively if needed\n        else if (expression.type === 'ConditionalExpression') {\n          // Only transform consequent and alternate, not the test condition\n          if (expression.consequent)\n            traverseExpression(expression.consequent)\n          if (expression.alternate)\n            traverseExpression(expression.alternate)\n        }\n        else if (expression.type === 'BinaryExpression') {\n          if (expression.left)\n            traverseExpression(expression.left)\n          if (expression.right)\n            traverseExpression(expression.right)\n        }\n      }\n\n      for (const scriptAST of scriptASTs) {\n        traverseScriptAST(scriptAST, {\n          visitCallExpression(path) {\n            // Handle cva function calls\n            if (path.node.callee.type === 'Identifier' && path.node.callee.name === 'cva') {\n              const args = path.node.arguments\n\n              // cva(base, ...)\n              if (args[0]?.type === 'Literal' && typeof args[0].value === 'string') {\n                args[0].value = addPrefix(args[0].value)\n              }\n\n              // cva(..., { variants: { ... } })\n              if (args[1]?.type === 'ObjectExpression') {\n                const variantsProperty = args[1].properties.find(\n                  prop => prop.type === 'Property'\n                    && prop.key.type === 'Identifier'\n                    && prop.key.name === 'variants',\n                )\n\n                if (variantsProperty && variantsProperty.type === 'Property' && variantsProperty.value.type === 'ObjectExpression') {\n                  // Only transform class strings in variants, not the variant names themselves\n                  const allProperties = astHelpers.findAll(variantsProperty.value, { type: 'Property' })\n                  allProperties.forEach((prop: any) => {\n                    if (prop.value?.type === 'Literal' && typeof prop.value.value === 'string') {\n                      prop.value.value = addPrefix(prop.value.value)\n                    }\n                    // Handle ArrayExpression values (e.g., vertical: [\"flex-col\", \"w-full\"])\n                    else if (prop.value?.type === 'ArrayExpression') {\n                      prop.value.elements.forEach((element: any) => {\n                        if (element?.type === 'Literal' && typeof element.value === 'string') {\n                          element.value = addPrefix(element.value)\n                        }\n                      })\n                    }\n                  })\n                }\n              }\n            }\n\n            // Handle cn function calls\n            if (path.node.callee.type === 'Identifier' && path.node.callee.name === 'cn') {\n              path.node.arguments.forEach((arg) => {\n                if (arg.type === 'Literal' && typeof arg.value === 'string') {\n                  arg.value = addPrefix(arg.value)\n                }\n                else if (arg.type === 'ConditionalExpression') {\n                  // Only transform consequent and alternate, not the test condition\n                  if (arg.consequent?.type === 'Literal' && typeof arg.consequent.value === 'string') {\n                    arg.consequent.value = addPrefix(arg.consequent.value)\n                  }\n                  if (arg.alternate?.type === 'Literal' && typeof arg.alternate.value === 'string') {\n                    arg.alternate.value = addPrefix(arg.alternate.value)\n                  }\n                }\n                else if (arg.type === 'BinaryExpression') {\n                  // Only transform the right side if it's a string literal\n                  if (arg.right?.type === 'Literal' && typeof arg.right.value === 'string') {\n                    arg.right.value = addPrefix(arg.right.value)\n                  }\n                }\n                else if (arg.type === 'ObjectExpression') {\n                  // Handle object expressions like { variant: 'ghost', class: 'flex' }\n                  arg.properties.forEach((prop: any) => {\n                    if (prop.type === 'Property' && prop.value?.type === 'Literal' && typeof prop.value.value === 'string') {\n                      // Only transform if it's NOT a variant property\n                      if (!isVariantProperty(prop)) {\n                        prop.value.value = addPrefix(prop.value.value)\n                      }\n                    }\n                  })\n                }\n                else {\n                  // For other complex expressions, find all string literals but exclude variant properties\n                  const literals = astHelpers.findAll(arg, { type: 'Literal' })\n                  literals.forEach((literal) => {\n                    if (typeof literal.value === 'string') {\n                      // Check if this literal is part of a variant property\n                      let shouldTransform = true\n                      let parent = literal.parent\n                      while (parent) {\n                        if (isVariantProperty(parent)) {\n                          shouldTransform = false\n                          break\n                        }\n                        parent = parent.parent\n                      }\n\n                      if (shouldTransform) {\n                        literal.value = addPrefix(literal.value)\n                      }\n                    }\n                  })\n                }\n              })\n            }\n\n            return this.traverse(path)\n          },\n        })\n      }\n\n      if (sfcAST) {\n        traverseTemplateAST(sfcAST, {\n          enterNode(node) {\n            // Handle v-bind:class, :class, v-bind:className, :className\n            if (node.type === 'VAttribute' && node.key.type === 'VDirectiveKey') {\n              if (node.key.argument?.type === 'VIdentifier') {\n                const argName = node.key.argument.name\n                if (['class', 'className', 'classes', 'classNames'].includes(argName)) {\n                  // Find literals but exclude condition values\n                  if (node.value?.type === 'VExpressionContainer' && node.value.expression) {\n                    traverseExpression(node.value.expression)\n                  }\n                }\n              }\n            }\n            // Handle static class attributes\n            else if (node.type === 'VLiteral' && typeof node.value === 'string') {\n              if (node.parent?.type === 'VAttribute'\n                && node.parent.key?.type === 'VIdentifier'\n                && ['class', 'className', 'classes', 'classNames'].includes(node.parent.key.name)) {\n                const cleanValue = node.value.replace(/\"/g, '')\n                const prefixedValue = addPrefix(cleanValue)\n                node.value = `\"${prefixedValue}\"`\n              }\n            }\n          },\n          leaveNode() {\n          },\n        })\n      }\n\n      return transformCount\n    },\n  }\n}\n\nexport function applyPrefix(input: string, prefix: string = '', tailwindVersion: TailwindVersion) {\n  if (tailwindVersion === 'v3') {\n    return input\n      .split(' ')\n      .map((className) => {\n        const [variant, value, modifier] = splitClassName(className)\n        if (variant) {\n          return modifier\n            ? `${variant}:${prefix}${value}/${modifier}`\n            : `${variant}:${prefix}${value}`\n        }\n        else {\n          return modifier\n            ? `${prefix}${value}/${modifier}`\n            : `${prefix}${value}`\n        }\n      })\n      .join(' ')\n  }\n\n  return input\n    .split(' ')\n    .map(className =>\n      className.indexOf(`${prefix}:`) === 0\n        ? className\n        : `${prefix}:${className.trim()}`,\n    )\n    .join(' ')\n}\n\nexport function applyPrefixesCss(css: string, prefix: string, tailwindVersion: TailwindVersion) {\n  const lines = css.split('\\n')\n  for (const line of lines) {\n    if (line.includes('@apply')) {\n      const originalTWCls = line.replace('@apply', '').trim()\n      const prefixedTwCls = applyPrefix(originalTWCls, prefix, tailwindVersion)\n      css = css.replace(originalTWCls, prefixedTwCls)\n    }\n  }\n  return css\n}\n","export const ICON_LIBRARIES = {\n  lucide: {\n    name: 'lucide-vue-next',\n    package: 'lucide-vue-next',\n    import: 'lucide-vue-next',\n  },\n  radix: {\n    name: '@radix-icons/vue',\n    package: '@radix-icons/vue',\n    import: '@radix-icons/vue',\n  },\n  tabler: {\n    name: '@tabler/icons-vue',\n    package: '@tabler/icons-vue',\n    import: '@tabler/icons-vue',\n  },\n  phosphor: {\n    name: '@phosphor-icons/vue',\n    package: '@phosphor-icons/vue',\n    import: '@phosphor-icons/vue',\n  },\n}\n","import type { CodemodPlugin } from 'vue-metamorph'\nimport type { TransformOpts } from '.'\nimport { ICON_LIBRARIES } from '@/src/utils/icon-libraries'\n\n// Lucide is the default icon library in the registry.\nconst SOURCE_LIBRARY = 'lucide'\n\n// Precompute the set of known icon library import sources to avoid hardcoding lists.\nconst ICON_LIBRARY_IMPORTS = new Set(\n  Object.values(ICON_LIBRARIES)\n    .map(l => l.import)\n    .filter(Boolean),\n)\n\nexport function transformIcons(opts: TransformOpts, registryIcons: Record<string, Record<string, string>>): CodemodPlugin {\n  return {\n    type: 'codemod',\n    name: 'modify import of icon library on user config',\n\n    transform({ scriptASTs, sfcAST, utils: { traverseScriptAST, traverseTemplateAST } }) {\n      let transformCount = 0\n      const { config } = opts\n\n      // No transform if we cannot read the icon library.\n      if (!config.iconLibrary || !(config.iconLibrary in ICON_LIBRARIES)) {\n        return transformCount\n      }\n\n      const sourceLibrary = SOURCE_LIBRARY\n      const targetLibrary = config.iconLibrary\n\n      if (sourceLibrary === targetLibrary) {\n        return transformCount\n      }\n\n      // Map<originalIcon, targetedIcon>\n      const targetedIconsMap: Map<string, string> = new Map()\n\n      for (const scriptAST of scriptASTs) {\n        traverseScriptAST(scriptAST, {\n          visitImportDeclaration(path) {\n            const source = String(path.node.source.value)\n            if (![...ICON_LIBRARY_IMPORTS].some(prefix => source.startsWith(prefix)))\n              return this.traverse(path)\n\n            let hasChanges = false\n\n            for (const specifier of path.node.specifiers ?? []) {\n              if (specifier.type === 'ImportSpecifier') {\n                const iconName = specifier.imported.name\n                const targetedIcon = registryIcons[iconName]?.[targetLibrary]\n\n                if (!targetedIcon || targetedIconsMap.has(iconName)) {\n                  continue\n                }\n\n                targetedIconsMap.set(iconName, targetedIcon)\n                specifier.imported.name = targetedIcon\n                hasChanges = true\n              }\n            }\n\n            if (hasChanges) {\n              path.node.source.value = ICON_LIBRARIES[targetLibrary as keyof typeof ICON_LIBRARIES].import\n              transformCount++\n            }\n\n            return this.traverse(path)\n          },\n        })\n      }\n\n      // Move template traversal outside the loop\n      if (sfcAST && targetedIconsMap.size > 0) {\n        traverseTemplateAST(sfcAST, {\n          enterNode(node) {\n            if (node.type === 'VElement' && targetedIconsMap.has(node.rawName)) {\n              node.rawName = targetedIconsMap.get(node.rawName) ?? ''\n              transformCount++\n            }\n          },\n        })\n      }\n\n      return transformCount\n    },\n  }\n}\n","import type { z } from 'zod'\nimport type { registryBaseColorSchema } from '@/src/schema'\nimport type { Config } from '@/src/utils/get-config'\nimport { transform as metaTransform } from 'vue-metamorph'\nimport { getRegistryIcons } from '@/src/registry/api'\nimport { transformCssVars } from '@/src/utils/transformers/transform-css-vars'\nimport { transformImport } from '@/src/utils/transformers/transform-import'\nimport { transformSFC } from '@/src/utils/transformers/transform-sfc'\nimport { transformTwPrefix } from '@/src/utils/transformers/transform-tw-prefix'\nimport { transformIcons } from './transform-icons'\n\nexport interface TransformOpts {\n  filename: string\n  raw: string\n  config: Config\n  baseColor?: z.infer<typeof registryBaseColorSchema>\n  isRemote?: boolean\n}\n\nexport async function transform(opts: TransformOpts) {\n  const source = await transformSFC(opts)\n\n  const registryIcons = await getRegistryIcons()\n\n  return metaTransform(source, opts.filename, [\n    transformImport(opts),\n    transformCssVars(opts),\n    await transformTwPrefix(opts),\n    transformIcons(opts, registryIcons),\n  ]).code\n}\n","import type { z } from 'zod'\nimport type { RegistryItem, registryItemFileSchema } from '@/src/schema'\nimport type { Config } from '@/src/utils/get-config'\nimport type { ProjectInfo } from '@/src/utils/get-project-info'\nimport { existsSync, promises as fs, statSync } from 'node:fs'\n// import { tmpdir } from 'node:os'\nimport { getTsconfig } from 'get-tsconfig'\nimport path, { basename } from 'pathe'\nimport prompts from 'prompts'\nimport { transform as metaTransform } from 'vue-metamorph'\nimport { getRegistryBaseColor } from '@/src/registry/api'\nimport { isContentSame } from '@/src/utils/compare'\nimport {\n  findExistingEnvFile,\n  getNewEnvKeys,\n  isEnvFile,\n  mergeEnvContent,\n  parseEnvContent,\n} from '@/src/utils/env-helpers'\nimport { getProjectInfo } from '@/src/utils/get-project-info'\nimport { highlighter } from '@/src/utils/highlighter'\nimport { logger } from '@/src/utils/logger'\nimport { resolveImport } from '@/src/utils/resolve-import'\nimport { spinner } from '@/src/utils/spinner'\nimport { transform } from '@/src/utils/transformers'\n\nexport async function updateFiles(\n  files: RegistryItem['files'],\n  config: Config,\n  options: {\n    overwrite?: boolean\n    force?: boolean\n    silent?: boolean\n    rootSpinner?: ReturnType<typeof spinner>\n    isRemote?: boolean\n    isWorkspace?: boolean\n    path?: string\n  },\n) {\n  if (!files?.length) {\n    return {\n      filesCreated: [],\n      filesUpdated: [],\n      filesSkipped: [],\n    }\n  }\n  options = {\n    overwrite: false,\n    force: false,\n    silent: false,\n    isRemote: false,\n    isWorkspace: false,\n    ...options,\n  }\n  const filesCreatedSpinner = spinner(`Updating files.`, {\n    silent: options.silent,\n  })?.start()\n\n  const [projectInfo, baseColor] = await Promise.all([\n    getProjectInfo(config.resolvedPaths.cwd),\n    config.tailwind.baseColor\n      ? getRegistryBaseColor(config.tailwind.baseColor)\n      : Promise.resolve(undefined),\n  ])\n\n  let filesCreated: string[] = []\n  let filesUpdated: string[] = []\n  let filesSkipped: string[] = []\n  let envVarsAdded: string[] = []\n  let envFile: string | null = null\n\n  for (let index = 0; index < files.length; index++) {\n    const file = files[index]\n    if (!file.content) {\n      continue\n    }\n\n    let filePath = resolveFilePath(file, config, {\n      // isSrcDir: projectInfo?.isSrcDir,\n      framework: projectInfo?.framework.name,\n      commonRoot: findCommonRoot(\n        files.map(f => f.path),\n        file.path,\n      ),\n      path: options.path,\n      fileIndex: index,\n    })\n\n    if (!filePath) {\n      continue\n    }\n\n    const fileName = basename(file.path)\n    const targetDir = path.dirname(filePath)\n\n    if (!config.typescript) {\n      filePath = filePath.replace(/\\.ts?$/, match => '.js')\n    }\n\n    if (isEnvFile(filePath) && !existsSync(filePath)) {\n      const alternativeEnvFile = findExistingEnvFile(targetDir)\n      if (alternativeEnvFile) {\n        filePath = alternativeEnvFile\n      }\n    }\n\n    const existingFile = existsSync(filePath)\n\n    // Check if the path exists and is a directory - we can't write to directories.\n    if (existingFile && statSync(filePath).isDirectory()) {\n      throw new Error(\n        `Cannot write to ${filePath}: path exists and is a directory. Please provide a file path instead.`,\n      )\n    }\n\n    // Run our transformers.\n    // Skip transformers for .env files to preserve exact content\n    const content = isEnvFile(filePath)\n      ? file.content\n      : await transform(\n          {\n            filename: file.path,\n            raw: file.content,\n            config,\n            baseColor,\n            // transformJsx: !config.tsx,\n            isRemote: options.isRemote,\n          },\n        )\n\n    // Skip the file if it already exists and the content is the same.\n    // Exception: Don't skip .env files as we merge content instead of replacing\n    if (existingFile && !isEnvFile(filePath)) {\n      const existingFileContent = await fs.readFile(filePath, 'utf-8')\n\n      if (\n        isContentSame(existingFileContent, content, {\n          // Ignore import differences for workspace components.\n          // TODO: figure out if we always want this.\n          ignoreImports: options.isWorkspace,\n        })\n      ) {\n        filesSkipped.push(path.relative(config.resolvedPaths.cwd, filePath))\n        continue\n      }\n    }\n\n    // Skip overwrite prompt for .env files - we'll handle them specially\n    if (existingFile && !options.overwrite && !isEnvFile(filePath)) {\n      filesCreatedSpinner.stop()\n      if (options.rootSpinner) {\n        options.rootSpinner.stop()\n      }\n      const { overwrite } = await prompts({\n        type: 'confirm',\n        name: 'overwrite',\n        message: `The file ${highlighter.info(\n          path.relative(config.resolvedPaths.ui, filePath),\n        )} already exists. Would you like to overwrite?`,\n        initial: false,\n      })\n\n      if (!overwrite) {\n        filesSkipped.push(path.relative(config.resolvedPaths.cwd, filePath))\n        if (options.rootSpinner) {\n          options.rootSpinner.start()\n        }\n        continue\n      }\n      filesCreatedSpinner?.start()\n      if (options.rootSpinner) {\n        options.rootSpinner.start()\n      }\n    }\n\n    // Create the target directory if it doesn't exist.\n    if (!existsSync(targetDir)) {\n      await fs.mkdir(targetDir, { recursive: true })\n    }\n\n    // Special handling for .env files - append only new keys\n    if (isEnvFile(filePath) && existingFile) {\n      const existingFileContent = await fs.readFile(filePath, 'utf-8')\n      const mergedContent = mergeEnvContent(existingFileContent, content)\n      envVarsAdded = getNewEnvKeys(existingFileContent, content)\n      envFile = path.relative(config.resolvedPaths.cwd, filePath)\n\n      if (!envVarsAdded.length) {\n        filesSkipped.push(path.relative(config.resolvedPaths.cwd, filePath))\n        continue\n      }\n\n      await fs.writeFile(filePath, mergedContent, 'utf-8')\n      filesUpdated.push(path.relative(config.resolvedPaths.cwd, filePath))\n      continue\n    }\n\n    await fs.writeFile(filePath, content, 'utf-8')\n\n    // Handle file creation logging\n    if (!existingFile) {\n      filesCreated.push(path.relative(config.resolvedPaths.cwd, filePath))\n\n      if (isEnvFile(filePath)) {\n        envVarsAdded = Object.keys(parseEnvContent(content))\n        envFile = path.relative(config.resolvedPaths.cwd, filePath)\n      }\n    }\n    else {\n      filesUpdated.push(path.relative(config.resolvedPaths.cwd, filePath))\n    }\n  }\n\n  const allFiles = [...filesCreated, ...filesUpdated, ...filesSkipped]\n  const updatedFiles = await resolveImports(allFiles, config)\n\n  // Let's update filesUpdated with the updated files.\n  filesUpdated.push(...updatedFiles)\n\n  // If a file is in filesCreated and filesUpdated, we should remove it from filesUpdated.\n  filesUpdated = filesUpdated.filter(file => !filesCreated.includes(file))\n\n  const hasUpdatedFiles = filesCreated.length || filesUpdated.length\n  if (!hasUpdatedFiles && !filesSkipped.length) {\n    filesCreatedSpinner?.info('No files updated.')\n  }\n\n  // Remove duplicates.\n  filesCreated = Array.from(new Set(filesCreated))\n  filesUpdated = Array.from(new Set(filesUpdated))\n  filesSkipped = Array.from(new Set(filesSkipped))\n\n  if (filesCreated.length) {\n    filesCreatedSpinner?.succeed(\n      `Created ${filesCreated.length} ${\n        filesCreated.length === 1 ? 'file' : 'files'\n      }:`,\n    )\n    if (!options.silent) {\n      for (const file of filesCreated) {\n        logger.log(`  - ${file}`)\n      }\n    }\n  }\n  else {\n    filesCreatedSpinner?.stop()\n  }\n\n  if (filesUpdated.length) {\n    spinner(\n      `Updated ${filesUpdated.length} ${\n        filesUpdated.length === 1 ? 'file' : 'files'\n      }:`,\n      {\n        silent: options.silent,\n      },\n    )?.info()\n    if (!options.silent) {\n      for (const file of filesUpdated) {\n        logger.log(`  - ${file}`)\n      }\n    }\n  }\n\n  if (filesSkipped.length) {\n    spinner(\n      `Skipped ${filesSkipped.length} ${\n        filesUpdated.length === 1 ? 'file' : 'files'\n      }: (files might be identical, use --overwrite to overwrite)`,\n      {\n        silent: options.silent,\n      },\n    )?.info()\n    if (!options.silent) {\n      for (const file of filesSkipped) {\n        logger.log(`  - ${file}`)\n      }\n    }\n  }\n\n  if (envVarsAdded.length && envFile) {\n    spinner(\n      `Added the following variables to ${highlighter.info(envFile)}:`,\n    )?.info()\n    if (!options.silent) {\n      for (const key of envVarsAdded) {\n        logger.log(`  ${highlighter.success('+')} ${key}`)\n      }\n    }\n  }\n\n  if (!options.silent) {\n    logger.break()\n  }\n\n  return {\n    filesCreated,\n    filesUpdated,\n    filesSkipped,\n  }\n}\n\nexport function resolveFilePath(\n  file: z.infer<typeof registryItemFileSchema>,\n  config: Config,\n  options: {\n    // isSrcDir?: boolean\n    commonRoot: string\n    framework?: ProjectInfo['framework']['name']\n    path?: string\n    fileIndex?: number\n  },\n) {\n  // Handle custom path if provided.\n  if (options.path) {\n    const resolvedPath = path.isAbsolute(options.path)\n      ? options.path\n      : path.join(config.resolvedPaths.cwd, options.path)\n\n    const isFilePath = /\\.[^/\\\\]+$/.test(resolvedPath)\n\n    if (isFilePath) {\n      // We'll only use the custom path for the first file.\n      // This is for registry items with multiple files.\n      if (options.fileIndex === 0) {\n        return resolvedPath\n      }\n    }\n    else {\n      // If the custom path is a directory,\n      // We'll place all files in the directory.\n      const fileName = path.basename(file.path)\n      return path.join(resolvedPath, fileName)\n    }\n  }\n\n  if (file.target) {\n    if (file.target.startsWith('~/')) {\n      return path.join(config.resolvedPaths.cwd, file.target.replace('~/', ''))\n    }\n\n    let target = file.target\n\n    if (file.type === 'registry:page') {\n      target = resolvePageTarget(target, options.framework)\n      if (!target) {\n        return ''\n      }\n    }\n\n    // return options.isSrcDir\n    //   ? path.join(config.resolvedPaths.cwd, 'src', target.replace('src/', ''))\n    //   : path.join(config.resolvedPaths.cwd, target.replace('src/', ''))\n\n    return path.join(config.resolvedPaths.cwd, target.replace('src/', ''))\n  }\n\n  const targetDir = resolveFileTargetDirectory(file, config)\n\n  const relativePath = resolveNestedFilePath(file.path, options.commonRoot, config)\n  return path.join(targetDir!, relativePath)\n}\n\nfunction resolveFileTargetDirectory(\n  file: z.infer<typeof registryItemFileSchema>,\n  config: Config,\n) {\n  if (file.type === 'registry:ui') {\n    return config.resolvedPaths.ui\n  }\n\n  if (file.type === 'registry:lib') {\n    return config.resolvedPaths.lib\n  }\n\n  if (file.type === 'registry:block' || file.type === 'registry:component') {\n    return config.resolvedPaths.components\n  }\n\n  if (file.type === 'registry:hook' || file.type === 'registry:composable') {\n    return config.resolvedPaths.composables\n  }\n\n  return config.resolvedPaths.components\n}\n\nexport function findCommonRoot(paths: string[], needle: string): string {\n  // Remove leading slashes for consistent handling\n  const normalizedPaths = paths.map(p => p.replace(/^\\//, ''))\n  const normalizedNeedle = needle.replace(/^\\//, '')\n\n  // Get the directory path of the needle by removing the file name\n  const needleDir = normalizedNeedle.split('/').slice(0, -1).join('/')\n\n  // If needle is at root level, return empty string\n  if (!needleDir) {\n    return ''\n  }\n\n  // Split the needle directory into segments\n  const needleSegments = needleDir.split('/')\n\n  // Start from the full path and work backwards\n  for (let i = needleSegments.length; i > 0; i--) {\n    const testPath = needleSegments.slice(0, i).join('/')\n    // Check if this is a common root by verifying if any other paths start with it\n    const hasRelatedPaths = normalizedPaths.some(\n      path => path !== normalizedNeedle && path.startsWith(`${testPath}/`),\n    )\n    if (hasRelatedPaths) {\n      return `/${testPath}` // Add leading slash back for the result\n    }\n  }\n\n  // If no common root found with other files, return the parent directory of the needle\n  return `/${needleDir}` // Add leading slash back for the result\n}\n\nexport function resolveNestedFilePath(\n  filePath: string,\n  commonRoot: string,\n  config: Config,\n): string {\n  // Normalize paths by removing leading/trailing slashes\n  const normalizedFilePath = filePath.replace(/^\\/|\\/$/g, '')\n  const normalizedCommonRoot = commonRoot.replace(/^\\/|\\/$/g, '')\n\n  // Get all aliases without @ prefix and normalize\n  const aliases = Object.values(config.aliases)\n    .map(alias => alias.replace(/^@\\//, '').replace(/^\\/|\\/$/g, ''))\n    .sort((a, b) => b.length - a.length) // Sort by length descending to match most specific first\n\n  // Check if the common root contains any of the aliases\n  for (const alias of aliases) {\n    if (normalizedCommonRoot.includes(alias)) {\n      // Find where the alias ends in the file path\n      const aliasEndIndex = normalizedFilePath.indexOf(alias) + alias.length\n\n      // Return everything after the alias (skip the leading slash if present)\n      // Example: \"components/ai-elements/artifact/Artifact.vue\" -> \"ai-elements/artifact/Artifact.vue\"\n      // Example: \"lib/utils/cn.ts\" -> \"utils/cn.ts\"\n      // Example: \"composables/useCounter.ts\" -> \"useCounter.ts\"\n      return normalizedFilePath.substring(aliasEndIndex).replace(/^\\//, '')\n    }\n  }\n\n  // Fallback to original logic for non-aliased paths\n  // Example: \"registry/new-york-v4/ui/button/Button.vue\" -> \"button/Button.vue\"\n  const lastCommonRootSegment = normalizedCommonRoot.split('/').pop()\n\n  // normalizedFilePath: registry/new-york-v4/ui/button/Button.vue\n  // normalizedCommonRoot: registry/new-york-v4/ui/button\n  // return button/Button.vue\n  return lastCommonRootSegment + normalizedFilePath.replace(normalizedCommonRoot, '')\n}\n\nexport function resolvePageTarget(\n  target: string,\n  framework?: ProjectInfo['framework']['name'],\n) {\n  if (!framework) {\n    return ''\n  }\n\n  if (framework === 'nuxt3' || framework === 'nuxt4') {\n    return target\n  }\n\n  // if (framework === 'next-pages') {\n  //   let result = target.replace(/^app\\//, 'pages/')\n  //   result = result.replace(/\\/page(\\.[jt]sx?)$/, '$1')\n\n  //   return result\n  // }\n\n  // if (framework === 'react-router') {\n  //   let result = target.replace(/^app\\//, 'app/routes/')\n  //   result = result.replace(/\\/page(\\.[jt]sx?)$/, '$1')\n\n  //   return result\n  // }\n\n  if (framework === 'laravel') {\n    let result = target.replace(/^app\\//, 'resources/js/pages/')\n    result = result.replace(/\\/page(\\.[jt]sx?)$/, '$1')\n\n    return result\n  }\n\n  return ''\n}\n\n// Replace the resolveImports function with this vue-metamorph version:\nasync function resolveImports(filePaths: string[], config: Config) {\n  const projectInfo = await getProjectInfo(config.resolvedPaths.cwd)\n  const tsConfig = getTsconfig(config.resolvedPaths.cwd)\n  const updatedFiles = []\n\n  if (!projectInfo || tsConfig === null) {\n    return []\n  }\n\n  for (const filepath of filePaths) {\n    const resolvedPath = path.resolve(config.resolvedPaths.cwd, filepath)\n\n    // Check if the file exists.\n    if (!existsSync(resolvedPath)) {\n      continue\n    }\n\n    const content = await fs.readFile(resolvedPath, 'utf-8')\n\n    try {\n      // Create a custom transformer for import resolution\n      const importResolverTransformer = (opts: any) => ({\n        name: 'import-resolver',\n        transform(node: any) {\n          // Handle import declarations\n          if (node.type === 'ImportDeclaration' && node.source?.value) {\n            const moduleSpecifier = node.source.value\n\n            // Filter out non-local imports.\n            if (\n              projectInfo?.aliasPrefix\n              && !moduleSpecifier.startsWith(`${projectInfo.aliasPrefix}/`)\n            ) {\n              return\n            }\n\n            // Find the probable import file path.\n            // This is where we expect to find the file on disk.\n            const probableImportFilePath = resolveImport(\n              moduleSpecifier,\n              tsConfig,\n            )\n\n            if (!probableImportFilePath) {\n              return\n            }\n\n            // Find the actual import file path.\n            const resolvedImportFilePath = resolveModuleByProbablePath(\n              probableImportFilePath,\n              filePaths,\n              config,\n            )\n\n            if (!resolvedImportFilePath) {\n              return\n            }\n\n            // Convert the resolved import file path to an aliased import.\n            const newImport = toAliasedImport(\n              resolvedImportFilePath,\n              config,\n              projectInfo,\n            )\n\n            if (!newImport || newImport === moduleSpecifier) {\n              return\n            }\n\n            // Update the import source\n            node.source.value = newImport\n            node.source.raw = `'${newImport}'`\n          }\n        },\n      })\n\n      // Use vue-metamorph transform\n      const result = metaTransform(content, resolvedPath, [\n        // @ts-expect-error type error\n        importResolverTransformer({}),\n      ])\n\n      // If the code changed, write it back\n      if (result.code !== content) {\n        await fs.writeFile(resolvedPath, result.code, 'utf-8')\n        updatedFiles.push(filepath)\n      }\n    }\n    catch (error) {\n      console.warn(`Failed to transform imports in ${filepath}:`, error)\n    }\n  }\n\n  return updatedFiles\n}\n\n/**\n * Given an absolute \"probable\" import path (no ext),\n * plus an array of absolute file paths you already know about,\n * return 0â€“N matches (best match first), and also check disk for any missing ones.\n */\nexport function resolveModuleByProbablePath(\n  probableImportFilePath: string,\n  files: string[],\n  config: Config,\n  extensions: string[] = ['.vue', '.ts', '.js', '.tsx', '.jsx', '.css'],\n) {\n  const cwd = path.normalize(config.resolvedPaths.cwd)\n\n  // 1) Build a set of POSIX-normalized, project-relative files\n  const relativeFiles = files.map(f => f.split(path.sep).join(path.posix.sep))\n  const fileSet = new Set(relativeFiles)\n\n  // 2) Strip any existing extension off the absolute base path\n  const extInPath = path.extname(probableImportFilePath)\n  const hasExt = extInPath !== ''\n  const absBase = hasExt\n    ? probableImportFilePath.slice(0, -extInPath.length)\n    : probableImportFilePath\n\n  // 3) Compute the project-relative \"base\" directory for strong matching\n  const relBaseRaw = path.relative(cwd, absBase)\n  const relBase = relBaseRaw.split(path.sep).join(path.posix.sep)\n\n  // 4) Decide which extensions to try\n  const tryExts = hasExt ? [extInPath] : extensions\n\n  // 5) Collect candidates\n  const candidates = new Set<string>()\n\n  // 5a) Fastâ€‘path: [base + ext] and [base/index + ext]\n  for (const e of tryExts) {\n    const absCand = absBase + e\n    const relCand = path.posix.normalize(path.relative(cwd, absCand))\n    if (fileSet.has(relCand) || existsSync(absCand)) {\n      candidates.add(relCand)\n    }\n\n    const absIdx = path.join(absBase, `index${e}`)\n    const relIdx = path.posix.normalize(path.relative(cwd, absIdx))\n    if (fileSet.has(relIdx) || existsSync(absIdx)) {\n      candidates.add(relIdx)\n    }\n  }\n\n  // 5b) Fallback: scan known files by basename\n  const name = path.basename(absBase)\n  for (const f of relativeFiles) {\n    if (tryExts.some(e => f.endsWith(`/${name}${e}`))) {\n      candidates.add(f)\n    }\n  }\n\n  // 6) If no matches, bail\n  if (candidates.size === 0)\n    return null\n\n  // 7) Sort by (1) extension priority, then (2) \"strong\" base match\n  const sorted = Array.from(candidates).sort((a, b) => {\n    // a) extension order\n    const aExt = path.posix.extname(a)\n    const bExt = path.posix.extname(b)\n    const ord = tryExts.indexOf(aExt) - tryExts.indexOf(bExt)\n    if (ord !== 0)\n      return ord\n    // b) strong match if path starts with relBase\n    const aStrong = relBase && a.startsWith(relBase) ? -1 : 1\n    const bStrong = relBase && b.startsWith(relBase) ? -1 : 1\n    return aStrong - bStrong\n  })\n\n  // 8) Return the first (best) candidate\n  return sorted[0]\n}\n\nexport function toAliasedImport(\n  filePath: string,\n  config: Config,\n  projectInfo: ProjectInfo,\n): string | null {\n  const abs = path.normalize(path.join(config.resolvedPaths.cwd, filePath))\n\n  // 1ï¸âƒ£ Find the longest matching alias root in resolvedPaths\n  //    e.g. key=\"ui\", root=\"/â€¦/components/ui\" beats key=\"components\"\n  const matches = Object.entries(config.resolvedPaths)\n    .filter(\n      ([, root]) => root && abs.startsWith(path.normalize(root + path.sep)),\n    )\n    .sort((a, b) => b[1].length - a[1].length)\n\n  if (matches.length === 0) {\n    return null\n  }\n  const [aliasKey, rootDir] = matches[0]\n\n  // 2ï¸âƒ£ Compute the path UNDER that root\n  let rel = path.relative(rootDir, abs)\n  // force POSIX-style separators\n  rel = rel.split(path.sep).join('/') // e.g. \"button/index.tsx\"\n\n  // 3ï¸âƒ£ Strip code-file extensions, keep others (css, json, etc.)\n  const ext = path.posix.extname(rel)\n  const codeExts = ['.vue', '.ts', '.tsx', '.js', '.jsx']\n  const keepExt = codeExts.includes(ext) ? '' : ext\n  let noExt = rel.slice(0, rel.length - ext.length)\n\n  // 4ï¸âƒ£ Collapse \"/index\" to its directory\n  if (noExt.endsWith('/index')) {\n    noExt = noExt.slice(0, -'/index'.length)\n  }\n\n  // 5ï¸âƒ£ Build the aliased path\n  //    config.aliases[aliasKey] is e.g. \"@/components/ui\"\n  const aliasBase\n    = aliasKey === 'cwd'\n      ? projectInfo.aliasPrefix\n      : config.aliases[aliasKey as keyof typeof config.aliases]\n  if (!aliasBase) {\n    return null\n  }\n  // if noExt is empty (i.e. file was exactly at the root), we import the root\n  let suffix = noExt === '' ? '' : `/${noExt}`\n\n  // Remove /src from suffix.\n  // Alias will handle this.\n  suffix = suffix.replace('/src', '')\n\n  // 6ï¸âƒ£ Prepend the prefix from projectInfo (e.g. \"@\") if needed\n  //    but usually config.aliases already include it.\n  return `${aliasBase}${suffix}${keepExt}`\n}\n","import type {\n  configSchema,\n  registryItemSchema,\n} from \"@/src/schema\"\nimport type { Config } from \"@/src/utils/get-config\"\nimport type { ProjectInfo } from \"@/src/utils/get-project-info\"\nimport * as fs from \"node:fs/promises\"\nimport { tmpdir } from \"node:os\"\nimport { getTsconfig } from \"get-tsconfig\"\nimport * as path from \"pathe\"\nimport { Project, ScriptKind } from \"ts-morph\"\nimport { z } from \"zod\"\nimport {\n  registryItemFileSchema,\n} from \"@/src/schema\"\nimport { getProjectInfo } from \"@/src/utils/get-project-info\"\nimport { resolveImport } from \"@/src/utils/resolve-import\"\nimport {\n  findCommonRoot,\n  resolveFilePath,\n} from \"@/src/utils/updaters/update-files\"\n\nconst FILE_EXTENSIONS_FOR_LOOKUP = [\".tsx\", \".ts\", \".jsx\", \".js\", \".css\"]\nconst FILE_PATH_SKIP_LIST = [\"lib/utils.ts\"]\nconst DEPENDENCY_SKIP_LIST = [\n  /^(react|react-dom|next)(\\/.*)?$/, // Matches react, react-dom, next and their submodules\n  /^(node|jsr|npm):.*$/, // Matches node:, jsr:, and npm: prefixed modules\n]\n\nconst project = new Project({\n  compilerOptions: {},\n})\n\n// This returns the dependency from the module specifier.\n// Here dependency means an npm package.\nexport function getDependencyFromModuleSpecifier(\n  moduleSpecifier: string,\n): string | null {\n  // Skip if the dependency matches any pattern in the skip list\n  if (DEPENDENCY_SKIP_LIST.some(pattern => pattern.test(moduleSpecifier))) {\n    return null\n  }\n\n  // If the module specifier does not start with `@` and has a /, add the dependency first part only.\n  // E.g. `foo/bar` -> `foo`\n  if (!moduleSpecifier.startsWith(\"@\") && moduleSpecifier.includes(\"/\")) {\n    moduleSpecifier = moduleSpecifier.split(\"/\")[0]\n  }\n\n  // For scoped packages, we want to keep the first two parts\n  // E.g. `@types/react/dom` -> `@types/react`\n  if (moduleSpecifier.startsWith(\"@\")) {\n    const parts = moduleSpecifier.split(\"/\")\n    if (parts.length > 2) {\n      moduleSpecifier = parts.slice(0, 2).join(\"/\")\n    }\n  }\n\n  return moduleSpecifier\n}\n\nexport async function recursivelyResolveFileImports(\n  filePath: string,\n  config: z.infer<typeof configSchema>,\n  projectInfo: ProjectInfo,\n  processedFiles: Set<string> = new Set(),\n): Promise<Pick<z.infer<typeof registryItemSchema>, \"files\" | \"dependencies\">> {\n  const resolvedFilePath = path.resolve(config.resolvedPaths.cwd, filePath)\n  const relativeRegistryFilePath = path.relative(\n    config.resolvedPaths.cwd,\n    resolvedFilePath,\n  )\n\n  // Skip if the file is in the skip list\n  if (FILE_PATH_SKIP_LIST.includes(relativeRegistryFilePath)) {\n    return { dependencies: [], files: [] }\n  }\n\n  // Skip if the file extension is not one of the supported extensions\n  const fileExtension = path.extname(filePath)\n  if (!FILE_EXTENSIONS_FOR_LOOKUP.includes(fileExtension)) {\n    return { dependencies: [], files: [] }\n  }\n\n  // Prevent infinite loop: skip if already processed\n  if (processedFiles.has(relativeRegistryFilePath)) {\n    return { dependencies: [], files: [] }\n  }\n  processedFiles.add(relativeRegistryFilePath)\n\n  const stat = await fs.stat(resolvedFilePath)\n  if (!stat.isFile()) {\n    // Optionally log or handle this case\n    return { dependencies: [], files: [] }\n  }\n\n  const content = await fs.readFile(resolvedFilePath, \"utf-8\")\n  const tempFile = await createTempSourceFile(path.basename(resolvedFilePath))\n  const sourceFile = project.createSourceFile(tempFile, content, {\n    scriptKind: ScriptKind.TSX,\n  })\n  const tsConfig = await getTsconfig(config.resolvedPaths.cwd)\n  if (tsConfig === null) {\n    return { dependencies: [], files: [] }\n  }\n\n  const files: z.infer<typeof registryItemSchema>[\"files\"] = []\n  const dependencies = new Set<string>()\n\n  // Add the original file first\n  const fileType = determineFileType(filePath)\n  const originalFile = {\n    path: relativeRegistryFilePath,\n    type: fileType,\n    target: \"\",\n  }\n  files.push(originalFile)\n\n  // 1. Find all import statements in the file.\n  const importStatements = sourceFile.getImportDeclarations()\n  for (const importStatement of importStatements) {\n    const moduleSpecifier = importStatement.getModuleSpecifierValue()\n\n    const isRelativeImport = moduleSpecifier.startsWith(\".\")\n    const isAliasImport = moduleSpecifier.startsWith(\n      `${projectInfo.aliasPrefix}/`,\n    )\n\n    // If not a local import, add to the dependencies array.\n    if (!isAliasImport && !isRelativeImport) {\n      const dependency = getDependencyFromModuleSpecifier(moduleSpecifier)\n      if (dependency) {\n        dependencies.add(dependency)\n      }\n      continue\n    }\n\n    let probableImportFilePath = await resolveImport(moduleSpecifier, tsConfig)\n\n    if (isRelativeImport) {\n      probableImportFilePath = path.resolve(\n        path.dirname(resolvedFilePath),\n        moduleSpecifier,\n      )\n    }\n\n    if (!probableImportFilePath) {\n      continue\n    }\n\n    // Check if the probable import path has a file extension.\n    // Try each extension until we find a file that exists.\n    const hasExtension = path.extname(probableImportFilePath)\n    if (!hasExtension) {\n      for (const ext of FILE_EXTENSIONS_FOR_LOOKUP) {\n        const pathWithExt: string = `${probableImportFilePath}${ext}`\n        try {\n          await fs.access(pathWithExt)\n          probableImportFilePath = pathWithExt\n          break\n        }\n        catch {\n          continue\n        }\n      }\n    }\n\n    const nestedRelativeRegistryFilePath = path.relative(\n      config.resolvedPaths.cwd,\n      probableImportFilePath,\n    )\n\n    // Skip if we've already processed this file or if it's in the skip list\n    if (\n      processedFiles.has(nestedRelativeRegistryFilePath)\n      || FILE_PATH_SKIP_LIST.includes(nestedRelativeRegistryFilePath)\n    ) {\n      continue\n    }\n\n    const fileType = determineFileType(moduleSpecifier)\n    const file = {\n      path: nestedRelativeRegistryFilePath,\n      type: fileType,\n      target: \"\",\n    }\n\n    // TODO (shadcn): fix this.\n    if (fileType === \"registry:page\" || fileType === \"registry:file\") {\n      file.target = moduleSpecifier\n    }\n\n    files.push(file)\n\n    // Recursively process the imported file, passing the shared processedFiles set\n    const nestedResults = await recursivelyResolveFileImports(\n      nestedRelativeRegistryFilePath,\n      config,\n      projectInfo,\n      processedFiles,\n    )\n\n    if (nestedResults.files) {\n      // Only add files that haven't been processed yet\n      for (const file of nestedResults.files) {\n        if (!processedFiles.has(file.path)) {\n          processedFiles.add(file.path)\n          files.push(file)\n        }\n      }\n    }\n\n    if (nestedResults.dependencies) {\n      nestedResults.dependencies.forEach(dep => dependencies.add(dep))\n    }\n  }\n\n  // Deduplicate files by path\n  const uniqueFiles = Array.from(\n    new Map(files.map(file => [file.path, file])).values(),\n  )\n\n  return {\n    dependencies: Array.from(dependencies),\n    files: uniqueFiles,\n  }\n}\n\nasync function createTempSourceFile(filename: string) {\n  const dir = await fs.mkdtemp(path.join(tmpdir(), \"shadcn-\"))\n  return path.join(dir, filename)\n}\n\n// This is a bit tricky to accurately determine.\n// For now we'll use the module specifier to determine the type.\nfunction determineFileType(\n  moduleSpecifier: string,\n): z.infer<typeof registryItemSchema>[\"type\"] {\n  if (moduleSpecifier.includes(\"/ui/\")) {\n    return \"registry:ui\"\n  }\n\n  if (moduleSpecifier.includes(\"/lib/\")) {\n    return \"registry:lib\"\n  }\n\n  if (moduleSpecifier.includes(\"/hooks/\") || moduleSpecifier.includes(\"/composables/\")) {\n    return \"registry:composable\"\n  }\n\n  if (moduleSpecifier.includes(\"/components/\")) {\n    return \"registry:component\"\n  }\n\n  return \"registry:component\"\n}\n\n// Additional utility functions for local file support\nexport function isUrl(path: string) {\n  try {\n    // eslint-disable-next-line no-new\n    new URL(path)\n    return true\n  }\n  catch (error) {\n    return false\n  }\n}\n\nexport function isLocalFile(path: string) {\n  return path.endsWith(\".json\") && !isUrl(path)\n}\n\n/**\n * Check if a registry item is universal (framework-agnostic).\n * A universal registry item must:\n * 1. Have type \"registry:item\" or \"registry:file\"\n * 2. If it has files, all files must have explicit targets and be type \"registry:file\" or \"registry:item\"\n * It can be installed without framework detection or components.json.\n */\nexport function isUniversalRegistryItem(\n  registryItem:\n    | Pick<z.infer<typeof registryItemSchema>, \"files\" | \"type\">\n    | null\n    | undefined,\n): boolean {\n  if (!registryItem) {\n    return false\n  }\n\n  if (\n    registryItem.type !== \"registry:item\"\n    && registryItem.type !== \"registry:file\"\n  ) {\n    return false\n  }\n\n  const files = registryItem.files ?? []\n\n  // If there are files, all must have targets and be of type registry:file or registry:item.\n  return files.every(\n    file =>\n      !!file.target\n      && (file.type === \"registry:file\" || file.type === \"registry:item\"),\n  )\n}\n\n// Deduplicates files based on their resolved target paths.\n// When multiple files resolve to the same target path, the last one wins.\nexport async function deduplicateFilesByTarget(\n  filesArrays: Array<z.infer<typeof registryItemFileSchema>[] | undefined>,\n  config: Config,\n) {\n  // Fallback to simple concatenation when we don't have complete config.\n  if (!canDeduplicateFiles(config)) {\n    return z\n      .array(registryItemFileSchema)\n      .parse(filesArrays.flat().filter(Boolean))\n  }\n\n  // Get project info for file resolution.\n  const projectInfo = await getProjectInfo(config.resolvedPaths.cwd)\n  const targetMap = new Map<string, z.infer<typeof registryItemFileSchema>>()\n  const allFiles = z\n    .array(registryItemFileSchema)\n    .parse(filesArrays.flat().filter(Boolean))\n\n  allFiles.forEach((file) => {\n    const resolvedPath = resolveFilePath(file, config, {\n      // isSrcDir: projectInfo?.isSrcDir,\n      framework: projectInfo?.framework.name,\n      commonRoot: findCommonRoot(\n        allFiles.map(f => f.path),\n        file.path,\n      ),\n    })\n\n    if (resolvedPath) {\n      // Last one wins - overwrites previous entry.\n      targetMap.set(resolvedPath, file)\n    }\n  })\n\n  return Array.from(targetMap.values())\n}\n\n// Checks if the config has the minimum required paths for file deduplication.\nexport function canDeduplicateFiles(config: Config) {\n  return !!(\n    config?.resolvedPaths?.cwd\n    && (config?.resolvedPaths?.ui\n      || config?.resolvedPaths?.lib\n      || config?.resolvedPaths?.components\n      || config?.resolvedPaths?.composables)\n  )\n}\n","import type { Config } from \"@/src/utils/get-config\"\nimport deepmerge from \"deepmerge\"\nimport { BUILTIN_REGISTRIES, FALLBACK_STYLE } from \"@/src/registry/constants\"\nimport { configSchema } from \"@/src/schema\"\nimport { createConfig } from \"@/src/utils/get-config\"\n\nfunction resolveStyleFromConfig(config: Partial<Config> | Config) {\n  if (!config.style) {\n    return FALLBACK_STYLE\n  }\n\n  // Check if we should use new-york-v4 for Tailwind v4.\n  // We assume that if tailwind.config is empty, we're using Tailwind v4.\n  if (config.style === \"new-york\" && config.tailwind?.config === \"\") {\n    return FALLBACK_STYLE\n  }\n\n  return config.style\n}\n\nexport function configWithDefaults(config?: Partial<Config> | Config) {\n  const baseConfig = createConfig({\n    style: FALLBACK_STYLE,\n    registries: BUILTIN_REGISTRIES,\n  })\n\n  if (!config) {\n    return baseConfig\n  }\n\n  return configSchema.parse(\n    deepmerge(baseConfig, {\n      ...config,\n      style: resolveStyleFromConfig(config),\n      registries: { ...BUILTIN_REGISTRIES, ...config.registries },\n    }),\n  )\n}\n","interface RegistryContext {\n  headers: Record<string, Record<string, string>>\n}\n\nconst context: RegistryContext = {\n  headers: {},\n}\n\nexport function setRegistryHeaders(\n  headers: Record<string, Record<string, string>>,\n) {\n  // Merge new headers with existing ones to preserve headers for nested dependencies\n  context.headers = { ...context.headers, ...headers }\n}\n\nexport function getRegistryHeadersFromContext(\n  url: string,\n): Record<string, string> {\n  return context.headers[url] || {}\n}\n\nexport function clearRegistryContext() {\n  context.headers = {}\n}\n","import type { z } from \"zod\"\nimport type { registryConfigItemSchema } from \"@/src/schema\"\nimport type { Config } from \"@/src/utils/get-config\"\nimport { buildUrlAndHeadersForRegistryItem } from \"@/src/registry/builder\"\nimport { configWithDefaults } from \"@/src/registry/config\"\nimport { clearRegistryContext } from \"@/src/registry/context\"\nimport { extractEnvVars } from \"@/src/registry/env\"\nimport { RegistryMissingEnvironmentVariablesError } from \"@/src/registry/errors\"\n\nexport function extractEnvVarsFromRegistryConfig(\n  config: z.infer<typeof registryConfigItemSchema>,\n): string[] {\n  const vars = new Set<string>()\n\n  if (typeof config === \"string\") {\n    extractEnvVars(config).forEach(v => vars.add(v))\n  }\n  else {\n    extractEnvVars(config.url).forEach(v => vars.add(v))\n\n    if (config.params) {\n      Object.values(config.params).forEach((value) => {\n        extractEnvVars(value).forEach(v => vars.add(v))\n      })\n    }\n\n    if (config.headers) {\n      Object.values(config.headers).forEach((value) => {\n        extractEnvVars(value).forEach(v => vars.add(v))\n      })\n    }\n  }\n\n  return Array.from(vars)\n}\n\nexport function validateRegistryConfig(\n  registryName: string,\n  config: z.infer<typeof registryConfigItemSchema>,\n): void {\n  const requiredVars = extractEnvVarsFromRegistryConfig(config)\n  const missing = requiredVars.filter(v => !process.env[v])\n\n  if (missing.length > 0) {\n    throw new RegistryMissingEnvironmentVariablesError(registryName, missing)\n  }\n}\n\nexport function validateRegistryConfigForItems(\n  items: string[],\n  config?: Config,\n): void {\n  for (const item of items) {\n    buildUrlAndHeadersForRegistryItem(item, configWithDefaults(config))\n  }\n\n  // Clear the registry context after validation.\n  clearRegistryContext()\n}\n","import type { z } from \"zod\"\nimport type { registryConfigItemSchema } from \"@/src/schema\"\nimport type { Config } from \"@/src/utils/get-config\"\nimport { REGISTRY_URL } from \"@/src/registry/constants\"\nimport { expandEnvVars } from \"@/src/registry/env\"\nimport { RegistryNotConfiguredError } from \"@/src/registry/errors\"\nimport { parseRegistryAndItemFromString } from \"@/src/registry/parser\"\nimport { isUrl } from \"@/src/registry/utils\"\nimport { validateRegistryConfig } from \"@/src/registry/validator\"\n\nconst NAME_PLACEHOLDER = \"{name}\"\nconst STYLE_PLACEHOLDER = \"{style}\"\nconst ENV_VAR_PATTERN = /\\$\\{(\\w+)\\}/g\nconst QUERY_PARAM_SEPARATOR = \"?\"\nconst QUERY_PARAM_DELIMITER = \"&\"\n\nexport function buildUrlAndHeadersForRegistryItem(\n  name: string,\n  config?: Config,\n) {\n  const { registry, item } = parseRegistryAndItemFromString(name)\n\n  if (!registry) {\n    return null\n  }\n\n  const registries = config?.registries || {}\n  const registryConfig = registries[registry]\n  if (!registryConfig) {\n    throw new RegistryNotConfiguredError(registry)\n  }\n\n  // TODO: I don't like this here.\n  // But this will do for now.\n  validateRegistryConfig(registry, registryConfig)\n\n  return {\n    url: buildUrlFromRegistryConfig(item, registryConfig, config),\n    headers: buildHeadersFromRegistryConfig(registryConfig),\n  }\n}\n\nexport function buildUrlFromRegistryConfig(\n  item: string,\n  registryConfig: z.infer<typeof registryConfigItemSchema>,\n  config?: Config,\n) {\n  if (typeof registryConfig === \"string\") {\n    let url = registryConfig.replace(NAME_PLACEHOLDER, item)\n    if (config?.style && url.includes(STYLE_PLACEHOLDER)) {\n      url = url.replace(STYLE_PLACEHOLDER, config.style)\n    }\n    return expandEnvVars(url)\n  }\n\n  let baseUrl = registryConfig.url.replace(NAME_PLACEHOLDER, item)\n  if (config?.style && baseUrl.includes(STYLE_PLACEHOLDER)) {\n    baseUrl = baseUrl.replace(STYLE_PLACEHOLDER, config.style)\n  }\n  baseUrl = expandEnvVars(baseUrl)\n\n  if (!registryConfig.params) {\n    return baseUrl\n  }\n\n  return appendQueryParams(baseUrl, registryConfig.params)\n}\n\nexport function buildHeadersFromRegistryConfig(\n  config: z.infer<typeof registryConfigItemSchema>,\n) {\n  if (typeof config === \"string\" || !config.headers) {\n    return {}\n  }\n\n  const headers: Record<string, string> = {}\n\n  for (const [key, value] of Object.entries(config.headers)) {\n    const expandedValue = expandEnvVars(value)\n\n    if (shouldIncludeHeader(value, expandedValue)) {\n      headers[key] = expandedValue\n    }\n  }\n\n  return headers\n}\n\nfunction appendQueryParams(baseUrl: string, params: Record<string, string>) {\n  const urlParams = new URLSearchParams()\n\n  for (const [key, value] of Object.entries(params)) {\n    const expandedValue = expandEnvVars(value)\n    if (expandedValue) {\n      urlParams.append(key, expandedValue)\n    }\n  }\n\n  const queryString = urlParams.toString()\n  if (!queryString) {\n    return baseUrl\n  }\n\n  const separator = baseUrl.includes(QUERY_PARAM_SEPARATOR)\n    ? QUERY_PARAM_DELIMITER\n    : QUERY_PARAM_SEPARATOR\n\n  return `${baseUrl}${separator}${queryString}`\n}\n\nfunction shouldIncludeHeader(originalValue: string, expandedValue: string) {\n  const trimmedExpanded = expandedValue.trim()\n\n  if (!trimmedExpanded) {\n    return false\n  }\n\n  // If the original value contains valid env vars, only include if expansion changed the value.\n  if (originalValue.includes(\"${\")) {\n    // Check if there are actual env vars in the string\n    const envVars = originalValue.match(ENV_VAR_PATTERN)\n    if (envVars) {\n      const templateWithoutVars = originalValue\n        .replace(ENV_VAR_PATTERN, \"\")\n        .trim()\n      return trimmedExpanded !== templateWithoutVars\n    }\n  }\n\n  return true\n}\n\n/**\n * Resolves a registry URL from a path or URL string.\n * Handles special cases like v0 registry URLs that need /json suffix.\n *\n * @param pathOrUrl - Either a relative path or a full URL\n * @returns The resolved registry URL\n */\nexport function resolveRegistryUrl(pathOrUrl: string) {\n  if (isUrl(pathOrUrl)) {\n    // If the url contains /chat/b/, we assume it's the v0 registry.\n    // We need to add the /json suffix if it's missing.\n    const url = new URL(pathOrUrl)\n    if (url.pathname.match(/\\/chat\\/b\\//) && !url.pathname.endsWith(\"/json\")) {\n      url.pathname = `${url.pathname}/json`\n    }\n\n    return url.toString()\n  }\n\n  return `${REGISTRY_URL}/${pathOrUrl}`\n}\n","import type { FetchError } from \"ofetch\"\nimport { promises as fs } from \"node:fs\"\nimport { homedir } from \"node:os\"\nimport { ofetch } from \"ofetch\"\nimport path from \"pathe\"\nimport { ProxyAgent } from \"undici\"\nimport { z } from \"zod\"\nimport { resolveRegistryUrl } from \"@/src/registry/builder\"\nimport { getRegistryHeadersFromContext } from \"@/src/registry/context\"\nimport {\n  RegistryFetchError,\n  RegistryForbiddenError,\n  RegistryLocalFileError,\n  RegistryNotFoundError,\n  RegistryParseError,\n  RegistryUnauthorizedError,\n} from \"@/src/registry/errors\"\nimport { registryItemSchema } from \"@/src/schema\"\n\nconst agent = process.env.https_proxy\n  ? new ProxyAgent(process.env.https_proxy)\n  : undefined\n\nconst registryCache = new Map<string, Promise<any>>()\n\nexport function clearRegistryCache() {\n  registryCache.clear()\n}\n\nexport async function fetchRegistry(\n  paths: string[],\n  options: { useCache?: boolean } = {},\n) {\n  options = {\n    useCache: true,\n    ...options,\n  }\n\n  // eslint-disable-next-line no-useless-catch\n  try {\n    const results = await Promise.all(\n      paths.map(async (path) => {\n        const url = resolveRegistryUrl(path)\n\n        // Check cache first if caching is enabled\n        if (options.useCache && registryCache.has(url)) {\n          return registryCache.get(url)\n        }\n\n        // Store the promise in the cache before awaiting if caching is enabled.\n        const fetchPromise = (async () => {\n          // Get headers from context for this URL.\n          const headers = getRegistryHeadersFromContext(url)\n\n          const response = await ofetch.raw(url, {\n            agent,\n            dispatcher: agent,\n            parseResponse: JSON.parse,\n            headers: {\n              ...headers,\n            },\n          }).catch(async (error: FetchError) => {\n            if (!error.response) {\n              throw new RegistryFetchError(url, undefined, error.message)\n            }\n            const response = error.response\n\n            let messageFromServer\n\n            if (\n              response.headers.get(\"content-type\")?.includes(\"application/json\")\n            ) {\n              const json = await response._data\n              const parsed = z\n                .object({\n                  // RFC 7807.\n                  detail: z.string().optional(),\n                  title: z.string().optional(),\n                  // Standard error response.\n                  message: z.string().optional(),\n                  error: z.string().optional(),\n                })\n                .safeParse(json)\n\n              if (parsed.success) {\n                // Prefer RFC 7807 detail field, then message field.\n                messageFromServer = parsed.data.detail || parsed.data.message\n\n                if (parsed.data.error) {\n                  messageFromServer = `[${parsed.data.error}] ${messageFromServer}`\n                }\n              }\n            }\n\n            if (response.status === 401) {\n              throw new RegistryUnauthorizedError(url, messageFromServer)\n            }\n\n            if (response.status === 404) {\n              throw new RegistryNotFoundError(url, messageFromServer)\n            }\n\n            if (response.status === 403) {\n              throw new RegistryForbiddenError(url, messageFromServer)\n            }\n\n            throw new RegistryFetchError(\n              url,\n              response.status,\n              messageFromServer,\n            )\n          })\n\n          return response._data\n        })()\n\n        if (options.useCache) {\n          registryCache.set(url, fetchPromise)\n        }\n        return fetchPromise\n      }),\n    )\n\n    return results\n  }\n  catch (error) {\n    throw error\n  }\n}\n\nexport async function fetchRegistryLocal(filePath: string) {\n  try {\n    // Handle tilde expansion for home directory\n    let expandedPath = filePath\n    if (filePath.startsWith(\"~/\")) {\n      expandedPath = path.join(homedir(), filePath.slice(2))\n    }\n\n    const resolvedPath = path.resolve(expandedPath)\n    const content = await fs.readFile(resolvedPath, \"utf8\")\n    const parsed = JSON.parse(content)\n\n    try {\n      return registryItemSchema.parse(parsed)\n    }\n    catch (error) {\n      throw new RegistryParseError(filePath, error)\n    }\n  }\n  catch (error) {\n    // Check if this is a file not found error\n    if (\n      error instanceof Error\n      && (error.message.includes(\"ENOENT\")\n        || error.message.includes(\"no such file\"))\n    ) {\n      throw new RegistryLocalFileError(filePath, error)\n    }\n    // Re-throw parse errors as-is\n    if (error instanceof RegistryParseError) {\n      throw error\n    }\n    // For other errors (like JSON parse errors), throw as local file error\n    throw new RegistryLocalFileError(filePath, error)\n  }\n}\n","import { z } from 'zod'\nimport { RegistryError } from '@/src/registry/errors'\nimport { highlighter } from '@/src/utils/highlighter'\nimport { logger } from '@/src/utils/logger'\n\nexport function handleError(error: unknown) {\n  logger.break()\n  logger.error(\n    `Something went wrong. Please check the error below for more details.`,\n  )\n  logger.error(`If the problem persists, please open an issue on GitHub.`)\n  logger.error('')\n  if (typeof error === 'string') {\n    logger.error(error)\n    logger.break()\n    process.exit(1)\n  }\n\n  if (error instanceof RegistryError) {\n    if (error.message) {\n      logger.error(error.cause ? 'Error:' : 'Message:')\n      logger.error(error.message)\n    }\n\n    if (error.cause) {\n      logger.error('\\nMessage:')\n      logger.error(error.cause)\n    }\n\n    if (error.suggestion) {\n      logger.error('\\nSuggestion:')\n      logger.error(error.suggestion)\n    }\n    logger.break()\n    process.exit(1)\n  }\n\n  if (error instanceof z.ZodError) {\n    logger.error('Validation failed:')\n    for (const [key, value] of Object.entries(error.flatten().fieldErrors)) {\n      logger.error(`- ${highlighter.info(key)}: ${value}`)\n    }\n    logger.break()\n    process.exit(1)\n  }\n\n  if (error instanceof Error) {\n    logger.error(error.message)\n    logger.break()\n    process.exit(1)\n  }\n\n  logger.break()\n  process.exit(1)\n}\n","import type { Config as TailwindConfig } from 'tailwindcss'\nimport type {\n  ArrayLiteralExpression,\n  ObjectLiteralExpression,\n  PropertyAssignment,\n  VariableStatement,\n} from 'ts-morph'\nimport type { z } from 'zod'\nimport type {\n  registryItemCssVarsSchema,\n  registryItemTailwindSchema,\n} from '@/src/schema'\nimport type { Config } from '@/src/utils/get-config'\nimport type { TailwindVersion } from '@/src/utils/get-project-info'\nimport { promises as fs } from 'node:fs'\nimport { tmpdir } from 'node:os'\nimport deepmerge from 'deepmerge'\nimport path from 'pathe'\nimport objectToString from 'stringify-object'\nimport {\n  Project,\n  QuoteKind,\n  ScriptKind,\n  SyntaxKind,\n} from 'ts-morph'\nimport { highlighter } from '@/src/utils/highlighter'\nimport { spinner } from '@/src/utils/spinner'\n\nexport type UpdaterTailwindConfig = Omit<TailwindConfig, 'plugins'> & {\n  // We only want string plugins for now.\n  plugins?: string[]\n}\n\nexport async function updateTailwindConfig(\n  tailwindConfig:\n    | z.infer<typeof registryItemTailwindSchema>['config']\n    | undefined,\n  config: Config,\n  options: {\n    silent?: boolean\n    tailwindVersion?: TailwindVersion\n  },\n) {\n  if (!tailwindConfig) {\n    return\n  }\n\n  options = {\n    silent: false,\n    tailwindVersion: 'v3',\n    ...options,\n  }\n\n  // No tailwind config in v4.\n  if (options.tailwindVersion === 'v4') {\n    return\n  }\n\n  const tailwindFileRelativePath = path.relative(\n    config.resolvedPaths.cwd,\n    config.resolvedPaths.tailwindConfig,\n  )\n  const tailwindSpinner = spinner(\n    `Updating ${highlighter.info(tailwindFileRelativePath)}`,\n    {\n      silent: options.silent,\n    },\n  ).start()\n  const raw = await fs.readFile(config.resolvedPaths.tailwindConfig, 'utf8')\n  const output = await transformTailwindConfig(raw, tailwindConfig, config)\n  await fs.writeFile(config.resolvedPaths.tailwindConfig, output, 'utf8')\n  tailwindSpinner?.succeed()\n}\n\nexport async function transformTailwindConfig(\n  input: string,\n  tailwindConfig: UpdaterTailwindConfig,\n  config: Config,\n) {\n  const sourceFile = await _createSourceFile(input, config)\n  // Find the object with content property.\n  // This is faster than traversing the default export.\n  // TODO: maybe we do need to traverse the default export?\n  const configObject = sourceFile\n    .getDescendantsOfKind(SyntaxKind.ObjectLiteralExpression)\n    .find(node =>\n      node\n        .getProperties()\n        .some(\n          property =>\n            property.isKind(SyntaxKind.PropertyAssignment)\n            && property.getName() === 'content',\n        ),\n    )\n\n  // We couldn't find the config object, so we return the input as is.\n  if (!configObject) {\n    return input\n  }\n\n  const quoteChar = _getQuoteChar(configObject)\n\n  // Add darkMode.\n  addTailwindConfigProperty(\n    configObject,\n    {\n      name: 'darkMode',\n      value: 'class',\n    },\n    { quoteChar },\n  )\n\n  // Add Tailwind config plugins.\n  tailwindConfig.plugins?.forEach((plugin) => {\n    addTailwindConfigPlugin(configObject, plugin)\n  })\n\n  // Add Tailwind config theme.\n  if (tailwindConfig.theme) {\n    await addTailwindConfigTheme(configObject, tailwindConfig.theme)\n  }\n\n  return sourceFile.getFullText()\n}\n\nfunction addTailwindConfigProperty(\n  configObject: ObjectLiteralExpression,\n  property: {\n    name: string\n    value: string\n  },\n  {\n    quoteChar,\n  }: {\n    quoteChar: string\n  },\n) {\n  const existingProperty = configObject.getProperty('darkMode')\n\n  if (!existingProperty) {\n    const newProperty = {\n      name: property.name,\n      initializer: `[${quoteChar}${property.value}${quoteChar}]`,\n    }\n\n    // We need to add darkMode as the first property.\n    if (property.name === 'darkMode') {\n      configObject.insertPropertyAssignment(0, newProperty)\n      return configObject\n    }\n\n    configObject.addPropertyAssignment(newProperty)\n\n    return configObject\n  }\n\n  if (existingProperty.isKind(SyntaxKind.PropertyAssignment)) {\n    const initializer = existingProperty.getInitializer()\n    const newValue = `${quoteChar}${property.value}${quoteChar}`\n\n    // If property is a string, change it to an array and append.\n    if (initializer?.isKind(SyntaxKind.StringLiteral)) {\n      const initializerText = initializer.getText()\n      initializer.replaceWithText(`[${initializerText}, ${newValue}]`)\n      return configObject\n    }\n\n    // If property is an array, append.\n    if (initializer?.isKind(SyntaxKind.ArrayLiteralExpression)) {\n      // Check if the array already contains the value.\n      if (\n        initializer\n          .getElements()\n          .map(element => element.getText())\n          .includes(newValue)\n      ) {\n        return configObject\n      }\n      initializer.addElement(newValue)\n    }\n\n    return configObject\n  }\n\n  return configObject\n}\n\nasync function addTailwindConfigTheme(\n  configObject: ObjectLiteralExpression,\n  theme: UpdaterTailwindConfig['theme'],\n) {\n  // Ensure there is a theme property.\n  if (!configObject.getProperty('theme')) {\n    configObject.addPropertyAssignment({\n      name: 'theme',\n      initializer: '{}',\n    })\n  }\n\n  // Nest all spread properties.\n  nestSpreadProperties(configObject)\n\n  const themeProperty = configObject\n    .getPropertyOrThrow('theme')\n    ?.asKindOrThrow(SyntaxKind.PropertyAssignment)\n\n  const themeInitializer = themeProperty.getInitializer()\n  if (themeInitializer?.isKind(SyntaxKind.ObjectLiteralExpression)) {\n    const themeObjectString = themeInitializer.getText()\n    const themeObject = await parseObjectLiteral(themeObjectString)\n    // @ts-expect-error type error\n    const result = deepmerge(themeObject, theme, {\n      arrayMerge: (dst, src) => src,\n    })\n    const resultString = objectToString(result)\n      .replace(/'\\.\\.\\.(.*)'/g, '...$1') // Remove quote around spread element\n      .replace(/'\"/g, '\\'') // Replace `\\\" with \"\n      .replace(/\"'/g, '\\'') // Replace `\\\" with \"\n      .replace(/'\\[/g, '[') // Replace `[ with [\n      .replace(/\\]'/g, ']') // Replace `] with ]\n      .replace(/'\\\\'/g, '\\'') // Replace `\\' with '\n      .replace(/\\\\'/g, '\\'') // Replace \\' with '\n      .replace(/\\\\''/g, '\\'')\n      .replace(/''/g, '\\'')\n    themeInitializer.replaceWithText(resultString)\n  }\n\n  // Unnest all spread properties.\n  unnestSpreadProperties(configObject)\n}\n\nfunction addTailwindConfigPlugin(\n  configObject: ObjectLiteralExpression,\n  plugin: string,\n) {\n  const existingPlugins = configObject.getProperty('plugins')\n\n  if (!existingPlugins) {\n    configObject.addPropertyAssignment({\n      name: 'plugins',\n      initializer: `[${plugin}]`,\n    })\n\n    return configObject\n  }\n\n  if (existingPlugins.isKind(SyntaxKind.PropertyAssignment)) {\n    const initializer = existingPlugins.getInitializer()\n\n    if (initializer?.isKind(SyntaxKind.ArrayLiteralExpression)) {\n      if (\n        initializer\n          .getElements()\n          .map((element) => {\n            return element.getText().replace(/[\"']/g, '')\n          })\n          .includes(plugin.replace(/[\"']/g, ''))\n      ) {\n        return configObject\n      }\n      initializer.addElement(plugin)\n    }\n\n    return configObject\n  }\n\n  return configObject\n}\n\nexport async function _createSourceFile(input: string, config: Config | null) {\n  const dir = await fs.mkdtemp(path.join(tmpdir(), 'shadcn-'))\n  const resolvedPath\n    = config?.resolvedPaths?.tailwindConfig || 'tailwind.config.ts'\n  const tempFile = path.join(dir, `shadcn-${path.basename(resolvedPath)}`)\n\n  const project = new Project({\n    compilerOptions: {},\n  })\n  const sourceFile = project.createSourceFile(tempFile, input, {\n    // Note: .js and .mjs can still be valid for TS projects.\n    // We can't infer TypeScript from config.tsx.\n    scriptKind:\n      path.extname(resolvedPath) === '.ts' ? ScriptKind.TS : ScriptKind.JS,\n  })\n\n  return sourceFile\n}\n\nexport function _getQuoteChar(configObject: ObjectLiteralExpression) {\n  return configObject\n    .getFirstDescendantByKind(SyntaxKind.StringLiteral)\n    ?.getQuoteKind() === QuoteKind.Single\n    ? '\\''\n    : '\"'\n}\n\nexport function nestSpreadProperties(obj: ObjectLiteralExpression) {\n  const properties = obj.getProperties()\n\n  for (let i = 0; i < properties.length; i++) {\n    const prop = properties[i]\n    if (prop.isKind(SyntaxKind.SpreadAssignment)) {\n      const spreadAssignment = prop.asKindOrThrow(SyntaxKind.SpreadAssignment)\n      const spreadText = spreadAssignment.getExpression().getText()\n\n      // Replace spread with a property assignment\n      obj.insertPropertyAssignment(i, {\n        // Need to escape the name with \" so that deepmerge doesn't mishandle the key\n        name: `\"___${spreadText.replace(/^\\.\\.\\./, '')}\"`,\n        initializer: `\"...${spreadText.replace(/^\\.\\.\\./, '')}\"`,\n      })\n\n      // Remove the original spread assignment\n      spreadAssignment.remove()\n    }\n    else if (prop.isKind(SyntaxKind.PropertyAssignment)) {\n      const propAssignment = prop.asKindOrThrow(SyntaxKind.PropertyAssignment)\n      const initializer = propAssignment.getInitializer()\n\n      if (\n        initializer\n        && initializer.isKind(SyntaxKind.ObjectLiteralExpression)\n      ) {\n        // Recursively process nested object literals\n        nestSpreadProperties(\n          initializer.asKindOrThrow(SyntaxKind.ObjectLiteralExpression),\n        )\n      }\n      else if (\n        initializer\n        && initializer.isKind(SyntaxKind.ArrayLiteralExpression)\n      ) {\n        nestSpreadElements(\n          initializer.asKindOrThrow(SyntaxKind.ArrayLiteralExpression),\n        )\n      }\n    }\n  }\n}\n\nexport function nestSpreadElements(arr: ArrayLiteralExpression) {\n  const elements = arr.getElements()\n  for (let j = 0; j < elements.length; j++) {\n    const element = elements[j]\n    if (element.isKind(SyntaxKind.ObjectLiteralExpression)) {\n      // Recursive check on objects within arrays\n      nestSpreadProperties(\n        element.asKindOrThrow(SyntaxKind.ObjectLiteralExpression),\n      )\n    }\n    else if (element.isKind(SyntaxKind.ArrayLiteralExpression)) {\n      // Recursive check on nested arrays\n      nestSpreadElements(\n        element.asKindOrThrow(SyntaxKind.ArrayLiteralExpression),\n      )\n    }\n    else if (element.isKind(SyntaxKind.SpreadElement)) {\n      const spreadText = element.getText()\n      // Spread element within an array\n      arr.removeElement(j)\n      arr.insertElement(j, `\"${spreadText}\"`)\n    }\n  }\n}\n\nexport function unnestSpreadProperties(obj: ObjectLiteralExpression) {\n  const properties = obj.getProperties()\n\n  for (let i = 0; i < properties.length; i++) {\n    const prop = properties[i]\n    if (prop.isKind(SyntaxKind.PropertyAssignment)) {\n      const propAssignment = prop as PropertyAssignment\n      const initializer = propAssignment.getInitializer()\n\n      if (initializer && initializer.isKind(SyntaxKind.StringLiteral)) {\n        const value = initializer\n          .asKindOrThrow(SyntaxKind.StringLiteral)\n          .getLiteralValue()\n        if (value.startsWith('...')) {\n          obj.insertSpreadAssignment(i, { expression: value.slice(3) })\n          propAssignment.remove()\n        }\n      }\n      else if (initializer?.isKind(SyntaxKind.ObjectLiteralExpression)) {\n        unnestSpreadProperties(initializer as ObjectLiteralExpression)\n      }\n      else if (\n        initializer\n        && initializer.isKind(SyntaxKind.ArrayLiteralExpression)\n      ) {\n        unsetSpreadElements(\n          initializer.asKindOrThrow(SyntaxKind.ArrayLiteralExpression),\n        )\n      }\n    }\n  }\n}\n\nexport function unsetSpreadElements(arr: ArrayLiteralExpression) {\n  const elements = arr.getElements()\n  for (let j = 0; j < elements.length; j++) {\n    const element = elements[j]\n    if (element.isKind(SyntaxKind.ObjectLiteralExpression)) {\n      // Recursive check on objects within arrays\n      unnestSpreadProperties(\n        element.asKindOrThrow(SyntaxKind.ObjectLiteralExpression),\n      )\n    }\n    else if (element.isKind(SyntaxKind.ArrayLiteralExpression)) {\n      // Recursive check on nested arrays\n      unsetSpreadElements(\n        element.asKindOrThrow(SyntaxKind.ArrayLiteralExpression),\n      )\n    }\n    else if (element.isKind(SyntaxKind.StringLiteral)) {\n      const spreadText = element.getText()\n      // check if spread element\n      const spreadTest = /^['\"](\\.\\.\\..*)['\"]$/g\n      if (spreadTest.test(spreadText)) {\n        arr.removeElement(j)\n        arr.insertElement(j, spreadText.replace(spreadTest, '$1'))\n      }\n    }\n  }\n}\n\nasync function parseObjectLiteral(objectLiteralString: string): Promise<any> {\n  const sourceFile = await _createSourceFile(\n    `const theme = ${objectLiteralString}`,\n    null,\n  )\n\n  const statement = sourceFile.getStatements()[0]\n  if (statement?.getKind() === SyntaxKind.VariableStatement) {\n    const declaration = (statement as VariableStatement)\n      .getDeclarationList()\n      ?.getDeclarations()[0]\n    const initializer = declaration.getInitializer()\n    if (initializer?.isKind(SyntaxKind.ObjectLiteralExpression)) {\n      return await parseObjectLiteralExpression(initializer)\n    }\n  }\n\n  throw new Error('Invalid input: not an object literal')\n}\n\nfunction parseObjectLiteralExpression(node: ObjectLiteralExpression): any {\n  const result: any = {}\n  for (const property of node.getProperties()) {\n    if (property.isKind(SyntaxKind.PropertyAssignment)) {\n      const name = property.getName().replace(/'/g, '')\n      if (\n        property.getInitializer()?.isKind(SyntaxKind.ObjectLiteralExpression)\n      ) {\n        result[name] = parseObjectLiteralExpression(\n          property.getInitializer() as ObjectLiteralExpression,\n        )\n      }\n      else if (\n        property.getInitializer()?.isKind(SyntaxKind.ArrayLiteralExpression)\n      ) {\n        result[name] = parseArrayLiteralExpression(\n          property.getInitializer() as ArrayLiteralExpression,\n        )\n      }\n      else {\n        result[name] = parseValue(property.getInitializer())\n      }\n    }\n  }\n  return result\n}\n\nfunction parseArrayLiteralExpression(node: ArrayLiteralExpression): any[] {\n  const result: any[] = []\n  for (const element of node.getElements()) {\n    if (element.isKind(SyntaxKind.ObjectLiteralExpression)) {\n      result.push(\n        parseObjectLiteralExpression(\n          element.asKindOrThrow(SyntaxKind.ObjectLiteralExpression),\n        ),\n      )\n    }\n    else if (element.isKind(SyntaxKind.ArrayLiteralExpression)) {\n      result.push(\n        parseArrayLiteralExpression(\n          element.asKindOrThrow(SyntaxKind.ArrayLiteralExpression),\n        ),\n      )\n    }\n    else {\n      result.push(parseValue(element))\n    }\n  }\n  return result\n}\n\nfunction parseValue(node: any): any {\n  switch (node.getKind()) {\n    case SyntaxKind.StringLiteral:\n      return node.getText()\n    case SyntaxKind.NumericLiteral:\n      return Number(node.getText())\n    case SyntaxKind.TrueKeyword:\n      return true\n    case SyntaxKind.FalseKeyword:\n      return false\n    case SyntaxKind.NullKeyword:\n      return null\n    case SyntaxKind.ArrayLiteralExpression:\n      return node.getElements().map(parseValue)\n    case SyntaxKind.ObjectLiteralExpression:\n      return parseObjectLiteralExpression(node)\n    default:\n      return node.getText()\n  }\n}\n\nexport function buildTailwindThemeColorsFromCssVars(\n  cssVars: z.infer<typeof registryItemCssVarsSchema>,\n) {\n  const result: Record<string, any> = {}\n\n  for (const key of Object.keys(cssVars)) {\n    const parts = key.split('-')\n    const colorName = parts[0]\n    const subType = parts.slice(1).join('-')\n\n    if (subType === '') {\n      if (typeof result[colorName] === 'object') {\n        result[colorName].DEFAULT = `hsl(var(--${key}))`\n      }\n      else {\n        result[colorName] = `hsl(var(--${key}))`\n      }\n    }\n    else {\n      if (typeof result[colorName] !== 'object') {\n        result[colorName] = { DEFAULT: `hsl(var(--${colorName}))` }\n      }\n      result[colorName][subType] = `hsl(var(--${key}))`\n    }\n  }\n\n  // Remove DEFAULT if it's not in the original cssVars\n  for (const [colorName, value] of Object.entries(result)) {\n    if (\n      typeof value === 'object'\n      && value.DEFAULT === `hsl(var(--${colorName}))`\n      && !(colorName in cssVars)\n    ) {\n      delete value.DEFAULT\n    }\n  }\n\n  return result\n}\n","import type { Config } from \"@/src/utils/get-config\"\nimport { createHash } from \"node:crypto\"\nimport deepmerge from \"deepmerge\"\nimport path from \"pathe\"\nimport { z } from \"zod\"\nimport {\n  getRegistryBaseColor,\n  getShadcnRegistryIndex,\n} from \"@/src/registry/api\"\nimport {\n  buildUrlAndHeadersForRegistryItem,\n  resolveRegistryUrl,\n} from \"@/src/registry/builder\"\nimport { setRegistryHeaders } from \"@/src/registry/context\"\nimport {\n  RegistryNotConfiguredError,\n  RegistryParseError,\n} from \"@/src/registry/errors\"\nimport { fetchRegistry, fetchRegistryLocal } from \"@/src/registry/fetcher\"\nimport { parseRegistryAndItemFromString } from \"@/src/registry/parser\"\nimport {\n  deduplicateFilesByTarget,\n  isLocalFile,\n  isUrl,\n} from \"@/src/registry/utils\"\nimport {\n  registryItemSchema,\n  registryResolvedItemsTreeSchema,\n} from \"@/src/schema\"\nimport { getTargetStyleFromConfig } from \"@/src/utils/get-config\"\nimport { getProjectTailwindVersionFromConfig } from \"@/src/utils/get-project-info\"\nimport { handleError } from \"@/src/utils/handle-error\"\nimport { buildTailwindThemeColorsFromCssVars } from \"@/src/utils/updaters/update-tailwind-config\"\n\nexport function resolveRegistryItemsFromRegistries(\n  items: string[],\n  config: Config,\n) {\n  const registryHeaders: Record<string, Record<string, string>> = {}\n  const resolvedItems = [...items]\n\n  if (!config?.registries) {\n    setRegistryHeaders({})\n    return resolvedItems\n  }\n\n  for (let i = 0; i < resolvedItems.length; i++) {\n    const resolved = buildUrlAndHeadersForRegistryItem(resolvedItems[i], config)\n\n    if (resolved) {\n      resolvedItems[i] = resolved.url\n\n      if (Object.keys(resolved.headers).length > 0) {\n        registryHeaders[resolved.url] = resolved.headers\n      }\n    }\n  }\n\n  setRegistryHeaders(registryHeaders)\n\n  return resolvedItems\n}\n\n// Internal function that fetches registry items without clearing context.\n// This is used for recursive dependency resolution.\nexport async function fetchRegistryItems(\n  items: string[],\n  config: Config,\n  options: { useCache?: boolean } = {},\n) {\n  const results = await Promise.all(\n    items.map(async (item) => {\n      if (isLocalFile(item)) {\n        return fetchRegistryLocal(item)\n      }\n\n      if (isUrl(item)) {\n        const [result] = await fetchRegistry([item], options)\n        try {\n          return registryItemSchema.parse(result)\n        }\n        catch (error) {\n          throw new RegistryParseError(item, error)\n        }\n      }\n\n      if (item.startsWith(\"@\") && config?.registries) {\n        const paths = resolveRegistryItemsFromRegistries([item], config)\n        const [result] = await fetchRegistry(paths, options)\n        try {\n          return registryItemSchema.parse(result)\n        }\n        catch (error) {\n          throw new RegistryParseError(item, error)\n        }\n      }\n\n      const path = `styles/${config?.style ?? \"new-york-v4\"}/${item}.json`\n      const [result] = await fetchRegistry([path], options)\n      try {\n        return registryItemSchema.parse(result)\n      }\n      catch (error) {\n        throw new RegistryParseError(item, error)\n      }\n    }),\n  )\n\n  return results\n}\n\n// Helper schema for items with source tracking\nconst registryItemWithSourceSchema = registryItemSchema.extend({\n  _source: z.string().optional(),\n})\n\n// Resolves a list of registry items with all their dependencies and returns\n// a complete installation bundle with merged configuration.\nexport async function resolveRegistryTree(\n  names: z.infer<typeof registryItemSchema>[\"name\"][],\n  config: Config,\n  options: { useCache?: boolean } = {},\n) {\n  try {\n    options = {\n      useCache: true,\n      ...options,\n    }\n\n    let payload: z.infer<typeof registryItemWithSourceSchema>[] = []\n    const allDependencyItems: z.infer<typeof registryItemWithSourceSchema>[] = []\n    const allDependencyRegistryNames: string[] = []\n\n    const uniqueNames = Array.from(new Set(names))\n\n    const results = await fetchRegistryItems(uniqueNames, config, options)\n\n    const resultMap = new Map<string, z.infer<typeof registryItemSchema>>()\n    for (let i = 0; i < results.length; i++) {\n      if (results[i]) {\n        resultMap.set(uniqueNames[i], results[i])\n      }\n    }\n\n    for (const [sourceName, item] of Array.from(resultMap.entries())) {\n      // Add source tracking\n      const itemWithSource: z.infer<typeof registryItemWithSourceSchema> = {\n        ...item,\n        _source: sourceName,\n      }\n      payload.push(itemWithSource)\n\n      if (item.registryDependencies) {\n        // Resolve namespace syntax and set headers for dependencies\n        let resolvedDependencies = item.registryDependencies\n\n        // Check for namespaced dependencies when no registries are configured\n        if (!config?.registries) {\n          const namespacedDeps = item.registryDependencies.filter(\n            (dep: string) => dep.startsWith(\"@\"),\n          )\n          if (namespacedDeps.length > 0) {\n            const { registry } = parseRegistryAndItemFromString(\n              namespacedDeps[0],\n            )\n            throw new RegistryNotConfiguredError(registry)\n          }\n        }\n        else {\n          resolvedDependencies = resolveRegistryItemsFromRegistries(\n            item.registryDependencies,\n            config,\n          )\n        }\n\n        const { items, registryNames } = await resolveDependenciesRecursively(\n          resolvedDependencies,\n          config,\n          options,\n          new Set(uniqueNames),\n        )\n        allDependencyItems.push(...items)\n        allDependencyRegistryNames.push(...registryNames)\n      }\n    }\n\n    payload.push(...allDependencyItems)\n\n    // Handle any remaining registry names that need index resolution\n    if (allDependencyRegistryNames.length > 0) {\n      // Remove duplicates from registry names\n      const uniqueRegistryNames = Array.from(\n        new Set(allDependencyRegistryNames),\n      )\n\n      // Separate namespaced and non-namespaced items\n      const nonNamespacedItems = uniqueRegistryNames.filter(\n        name => !name.startsWith(\"@\"),\n      )\n      const namespacedDepItems = uniqueRegistryNames.filter(name =>\n        name.startsWith(\"@\"),\n      )\n\n      // Handle namespaced dependency items\n      if (namespacedDepItems.length > 0) {\n        // This will now throw specific errors on failure\n        const depResults = await fetchRegistryItems(\n          namespacedDepItems,\n          config,\n          options,\n        )\n\n        for (let i = 0; i < depResults.length; i++) {\n          const item = depResults[i]\n          const itemWithSource: z.infer<typeof registryItemWithSourceSchema> = {\n            ...item,\n            _source: namespacedDepItems[i],\n          }\n          payload.push(itemWithSource)\n        }\n      }\n\n      // For non-namespaced items, we need the index and style resolution\n      if (nonNamespacedItems.length > 0) {\n        const index = await getShadcnRegistryIndex()\n        if (!index && payload.length === 0) {\n          return null\n        }\n\n        if (index) {\n          // If we're resolving the index, we want it to go first\n          if (nonNamespacedItems.includes(\"index\")) {\n            nonNamespacedItems.unshift(\"index\")\n          }\n\n          // Resolve non-namespaced items through the existing flow\n          // Get URLs for all registry items including their dependencies\n          const registryUrls: string[] = []\n          for (const name of nonNamespacedItems) {\n            const itemDependencies = await resolveRegistryDependencies(\n              name,\n              config,\n              options,\n            )\n            registryUrls.push(...itemDependencies)\n          }\n\n          // Deduplicate URLs\n          const uniqueUrls = Array.from(new Set(registryUrls))\n          const result = await fetchRegistry(uniqueUrls, options)\n          const registryPayload = z.array(registryItemSchema).parse(result)\n          payload.push(...registryPayload)\n        }\n      }\n    }\n\n    if (!payload.length) {\n      return null\n    }\n\n    // No deduplication - we want to support multiple items with the same name from different sources\n\n    // If we're resolving the index, we want to fetch\n    // the theme item if a base color is provided.\n    // We do this for index only.\n    // Other components will ship with their theme tokens.\n    if (\n      uniqueNames.includes(\"index\")\n      || allDependencyRegistryNames.includes(\"index\")\n    ) {\n      if (config.tailwind.baseColor) {\n        const theme = await registryGetTheme(config.tailwind.baseColor, config)\n        if (theme) {\n          payload.unshift(theme)\n        }\n      }\n    }\n\n    // Build source map for topological sort\n    const sourceMap = new Map<z.infer<typeof registryItemSchema>, string>()\n    payload.forEach((item) => {\n      // Use the _source property if it was added, otherwise use the name\n      const source = item._source || item.name\n      sourceMap.set(item, source)\n    })\n\n    // Apply topological sort to ensure dependencies come before dependents\n    payload = topologicalSortRegistryItems(payload, sourceMap)\n\n    // Sort the payload so that registry:theme items come first,\n    // while maintaining the relative order of all items.\n    payload.sort((a, b) => {\n      if (a.type === \"registry:theme\" && b.type !== \"registry:theme\") {\n        return -1\n      }\n      if (a.type !== \"registry:theme\" && b.type === \"registry:theme\") {\n        return 1\n      }\n      return 0\n    })\n\n    let tailwind = {}\n    payload.forEach((item) => {\n      tailwind = deepmerge(tailwind, item.tailwind ?? {})\n    })\n\n    let cssVars = {}\n    payload.forEach((item) => {\n      cssVars = deepmerge(cssVars, item.cssVars ?? {})\n    })\n\n    let css = {}\n    payload.forEach((item) => {\n      css = deepmerge(css, item.css ?? {})\n    })\n\n    let docs = \"\"\n    payload.forEach((item) => {\n      if (item.docs) {\n        docs += `${item.docs}\\n`\n      }\n    })\n\n    let envVars = {}\n    payload.forEach((item) => {\n      envVars = deepmerge(envVars, item.envVars ?? {})\n    })\n\n    // Deduplicate files based on resolved target paths.\n    const deduplicatedFiles = await deduplicateFilesByTarget(\n      payload.map(item => item.files ?? []),\n      config,\n    )\n\n    const parsed = registryResolvedItemsTreeSchema.parse({\n      dependencies: deepmerge.all(\n        payload.map(item => item.dependencies ?? []),\n      ),\n      devDependencies: deepmerge.all(\n        payload.map(item => item.devDependencies ?? []),\n      ),\n      files: deduplicatedFiles,\n      tailwind,\n      cssVars,\n      css,\n      docs,\n    })\n\n    if (Object.keys(envVars).length > 0) {\n      parsed.envVars = envVars\n    }\n\n    return parsed\n  }\n  catch (error) {\n    handleError(error)\n    return null\n  }\n}\n\nasync function resolveDependenciesRecursively(\n  dependencies: string[],\n  config: Config,\n  options: { useCache?: boolean } = {},\n  visited: Set<string> = new Set(),\n) {\n  const items: z.infer<typeof registryItemSchema>[] = []\n  const registryNames: string[] = []\n\n  for (const dep of dependencies) {\n    if (visited.has(dep)) {\n      continue\n    }\n    visited.add(dep)\n\n    // Handle URLs and local files directly.\n    if (isUrl(dep) || isLocalFile(dep)) {\n      const [item] = await fetchRegistryItems([dep], config, options)\n      if (item) {\n        items.push(item)\n        if (item.registryDependencies) {\n          // Resolve namespaced dependencies to set proper headers.\n          const resolvedDeps = config?.registries\n            ? resolveRegistryItemsFromRegistries(\n                item.registryDependencies,\n                config,\n              )\n            : item.registryDependencies\n\n          const nested = await resolveDependenciesRecursively(\n            resolvedDeps,\n            config,\n            options,\n            visited,\n          )\n          items.push(...nested.items)\n          registryNames.push(...nested.registryNames)\n        }\n      }\n    }\n    // Handle namespaced items (e.g., @one/foo, @two/bar).\n    else if (dep.startsWith(\"@\") && config?.registries) {\n      // Check if the registry exists.\n      const { registry } = parseRegistryAndItemFromString(dep)\n      if (registry && !(registry in config.registries)) {\n        throw new RegistryNotConfiguredError(registry)\n      }\n\n      // Let getRegistryItem handle the namespaced item with config\n      // This ensures proper authentication headers are used\n      const [item] = await fetchRegistryItems([dep], config, options)\n      if (item) {\n        items.push(item)\n        if (item.registryDependencies) {\n          // Resolve namespaced dependencies to set proper headers.\n          const resolvedDeps = config?.registries\n            ? resolveRegistryItemsFromRegistries(\n                item.registryDependencies,\n                config,\n              )\n            : item.registryDependencies\n\n          const nested = await resolveDependenciesRecursively(\n            resolvedDeps,\n            config,\n            options,\n            visited,\n          )\n          items.push(...nested.items)\n          registryNames.push(...nested.registryNames)\n        }\n      }\n    }\n    // Handle regular component names.\n    else {\n      registryNames.push(dep)\n\n      if (config) {\n        try {\n          const [item] = await fetchRegistryItems([dep], config, options)\n          if (item && item.registryDependencies) {\n            // Resolve namespaced dependencies to set proper headers.\n            const resolvedDeps = config?.registries\n              ? resolveRegistryItemsFromRegistries(\n                  item.registryDependencies,\n                  config,\n                )\n              : item.registryDependencies\n\n            const nested = await resolveDependenciesRecursively(\n              resolvedDeps,\n              config,\n              options,\n              visited,\n            )\n            items.push(...nested.items)\n            registryNames.push(...nested.registryNames)\n          }\n        }\n        catch (error) {\n          // If we can't fetch the registry item, that's okay - we'll still\n          // include the name.\n        }\n      }\n    }\n  }\n\n  return { items, registryNames }\n}\n\nasync function resolveRegistryDependencies(\n  url: string,\n  config: Config,\n  options: { useCache?: boolean } = {},\n) {\n  if (isUrl(url)) {\n    return [url]\n  }\n\n  const { registryNames } = await resolveDependenciesRecursively(\n    [url],\n    config,\n    options,\n    new Set(),\n  )\n\n  const style = config.resolvedPaths?.cwd\n    ? await getTargetStyleFromConfig(config.resolvedPaths.cwd, config.style)\n    : config.style\n\n  const urls = registryNames.map(name =>\n    resolveRegistryUrl(isUrl(name) ? name : `styles/${style}/${name}.json`),\n  )\n\n  return Array.from(new Set(urls))\n}\n\nasync function registryGetTheme(name: string, config: Config) {\n  const [baseColor, tailwindVersion] = await Promise.all([\n    getRegistryBaseColor(name),\n    getProjectTailwindVersionFromConfig(config),\n  ])\n  if (!baseColor) {\n    return null\n  }\n\n  // TODO: Move this to the registry i.e registry:theme.\n  const theme = {\n    name,\n    type: \"registry:theme\",\n    tailwind: {\n      config: {\n        theme: {\n          extend: {\n            borderRadius: {\n              lg: \"var(--radius)\",\n              md: \"calc(var(--radius) - 2px)\",\n              sm: \"calc(var(--radius) - 4px)\",\n            },\n            colors: {},\n          },\n        },\n      },\n    },\n    cssVars: {\n      theme: {},\n      light: {\n        radius: \"0.5rem\",\n      },\n      dark: {},\n    },\n  } satisfies z.infer<typeof registryItemSchema>\n\n  if (config.tailwind.cssVariables) {\n    theme.tailwind.config.theme.extend.colors = {\n      ...theme.tailwind.config.theme.extend.colors,\n      ...buildTailwindThemeColorsFromCssVars(baseColor.cssVars.dark ?? {}),\n    }\n    theme.cssVars = {\n      theme: {\n        ...baseColor.cssVars.theme,\n        ...theme.cssVars.theme,\n      },\n      light: {\n        ...baseColor.cssVars.light,\n        ...theme.cssVars.light,\n      },\n      dark: {\n        ...baseColor.cssVars.dark,\n        ...theme.cssVars.dark,\n      },\n    }\n\n    if (tailwindVersion === \"v4\" && baseColor.cssVarsV4) {\n      theme.cssVars = {\n        theme: {\n          ...baseColor.cssVarsV4.theme,\n          ...theme.cssVars.theme,\n        },\n        light: {\n          radius: \"0.625rem\",\n          ...baseColor.cssVarsV4.light,\n        },\n        dark: {\n          ...baseColor.cssVarsV4.dark,\n        },\n      }\n    }\n  }\n\n  return theme\n}\n\nfunction computeItemHash(\n  item: Pick<z.infer<typeof registryItemSchema>, \"name\">,\n  source?: string,\n) {\n  const identifier = source || item.name\n\n  const hash = createHash(\"sha256\")\n    .update(identifier)\n    .digest(\"hex\")\n    .substring(0, 8)\n\n  return `${item.name}::${hash}`\n}\n\nfunction extractItemIdentifierFromDependency(dependency: string) {\n  if (isUrl(dependency)) {\n    const url = new URL(dependency)\n    const pathname = url.pathname\n    const match = pathname.match(/\\/([^/]+)\\.json$/)\n    const name = match ? match[1] : path.basename(pathname, \".json\")\n\n    return {\n      name,\n      hash: computeItemHash({ name }, dependency),\n    }\n  }\n\n  if (isLocalFile(dependency)) {\n    const match = dependency.match(/\\/([^/]+)\\.json$/)\n    const name = match ? match[1] : path.basename(dependency, \".json\")\n\n    return {\n      name,\n      hash: computeItemHash({ name }, dependency),\n    }\n  }\n\n  const { item } = parseRegistryAndItemFromString(dependency)\n  return {\n    name: item,\n    hash: computeItemHash({ name: item }, dependency),\n  }\n}\n\nfunction topologicalSortRegistryItems(\n  items: z.infer<typeof registryItemSchema>[],\n  sourceMap: Map<z.infer<typeof registryItemSchema>, string>,\n) {\n  const itemMap = new Map<string, z.infer<typeof registryItemSchema>>()\n  const hashToItem = new Map<string, z.infer<typeof registryItemSchema>>()\n  const inDegree = new Map<string, number>()\n  const adjacencyList = new Map<string, string[]>()\n\n  items.forEach((item) => {\n    const source = sourceMap.get(item) || item.name\n    const hash = computeItemHash(item, source)\n\n    itemMap.set(hash, item)\n    hashToItem.set(hash, item)\n    inDegree.set(hash, 0)\n    adjacencyList.set(hash, [])\n  })\n\n  // Build a map of dependency to possible items.\n  const depToHashes = new Map<string, string[]>()\n  items.forEach((item) => {\n    const source = sourceMap.get(item) || item.name\n    const hash = computeItemHash(item, source)\n\n    if (!depToHashes.has(item.name)) {\n      depToHashes.set(item.name, [])\n    }\n    depToHashes.get(item.name)!.push(hash)\n\n    if (source !== item.name) {\n      if (!depToHashes.has(source)) {\n        depToHashes.set(source, [])\n      }\n      depToHashes.get(source)!.push(hash)\n    }\n  })\n\n  items.forEach((item) => {\n    const itemSource = sourceMap.get(item) || item.name\n    const itemHash = computeItemHash(item, itemSource)\n\n    if (item.registryDependencies) {\n      item.registryDependencies.forEach((dep) => {\n        let depHash: string | undefined\n\n        const exactMatches = depToHashes.get(dep) || []\n        if (exactMatches.length === 1) {\n          depHash = exactMatches[0]\n        }\n        else if (exactMatches.length > 1) {\n          // Multiple matches - try to disambiguate.\n          // For now, just use the first one and warn.\n          depHash = exactMatches[0]\n        }\n        else {\n          const { name } = extractItemIdentifierFromDependency(dep)\n          const nameMatches = depToHashes.get(name) || []\n          if (nameMatches.length > 0) {\n            depHash = nameMatches[0]\n          }\n        }\n\n        if (depHash && itemMap.has(depHash)) {\n          adjacencyList.get(depHash)!.push(itemHash)\n          inDegree.set(itemHash, inDegree.get(itemHash)! + 1)\n        }\n      })\n    }\n  })\n\n  // Implements Kahn's algorithm.\n  const queue: string[] = []\n  const sorted: z.infer<typeof registryItemSchema>[] = []\n\n  inDegree.forEach((degree, hash) => {\n    if (degree === 0) {\n      queue.push(hash)\n    }\n  })\n\n  while (queue.length > 0) {\n    const currentHash = queue.shift()!\n    const item = itemMap.get(currentHash)!\n    sorted.push(item)\n\n    adjacencyList.get(currentHash)!.forEach((dependentHash) => {\n      const newDegree = inDegree.get(dependentHash)! - 1\n      inDegree.set(dependentHash, newDegree)\n\n      if (newDegree === 0) {\n        queue.push(dependentHash)\n      }\n    })\n  }\n\n  if (sorted.length !== items.length) {\n    console.warn(\"Circular dependency detected in registry items\")\n    // Return all items even if there are circular dependencies\n    // Items not in sorted are part of circular dependencies\n    const sortedHashes = new Set(\n      sorted.map((item) => {\n        const source = sourceMap.get(item) || item.name\n        return computeItemHash(item, source)\n      }),\n    )\n\n    items.forEach((item) => {\n      const source = sourceMap.get(item) || item.name\n      const hash = computeItemHash(item, source)\n      if (!sortedHashes.has(hash)) {\n        sorted.push(item)\n      }\n    })\n  }\n\n  return sorted\n}\n","import type { Config } from \"@/src/utils/get-config\"\nimport path from \"pathe\"\nimport { z } from \"zod\"\nimport { buildUrlAndHeadersForRegistryItem } from \"@/src/registry/builder\"\nimport { configWithDefaults } from \"@/src/registry/config\"\nimport {\n  BASE_COLORS,\n  BUILTIN_REGISTRIES,\n  REGISTRY_URL,\n} from \"@/src/registry/constants\"\nimport {\n  clearRegistryContext,\n  setRegistryHeaders,\n} from \"@/src/registry/context\"\nimport {\n  ConfigParseError,\n  RegistriesIndexParseError,\n  RegistryInvalidNamespaceError,\n  RegistryNotFoundError,\n  RegistryParseError,\n} from \"@/src/registry/errors\"\nimport { fetchRegistry } from \"@/src/registry/fetcher\"\nimport {\n  fetchRegistryItems,\n  resolveRegistryTree,\n} from \"@/src/registry/resolver\"\nimport { isUrl } from \"@/src/registry/utils\"\nimport {\n  iconsSchema,\n  registriesIndexSchema,\n  registryBaseColorSchema,\n  registryConfigSchema,\n  registryIndexSchema,\n  registryItemSchema,\n  registrySchema,\n  stylesSchema,\n} from \"@/src/schema\"\nimport { getRawConfig } from \"@/src/utils/get-config\"\nimport { handleError } from \"@/src/utils/handle-error\"\nimport { logger } from \"@/src/utils/logger\"\n\nexport async function getRegistry(\n  name: string,\n  options?: {\n    config?: Partial<Config>\n    useCache?: boolean\n  },\n) {\n  const { config, useCache } = options || {}\n\n  if (isUrl(name)) {\n    const [result] = await fetchRegistry([name], { useCache })\n    try {\n      return registrySchema.parse(result)\n    }\n    catch (error) {\n      throw new RegistryParseError(name, error)\n    }\n  }\n\n  if (!name.startsWith(\"@\")) {\n    throw new RegistryInvalidNamespaceError(name)\n  }\n\n  let registryName = name\n  if (!registryName.endsWith(\"/registry\")) {\n    registryName = `${registryName}/registry`\n  }\n\n  const urlAndHeaders = buildUrlAndHeadersForRegistryItem(\n    registryName as `@${string}`,\n    configWithDefaults(config),\n  )\n\n  if (!urlAndHeaders?.url) {\n    throw new RegistryNotFoundError(registryName)\n  }\n\n  if (urlAndHeaders.headers && Object.keys(urlAndHeaders.headers).length > 0) {\n    setRegistryHeaders({\n      [urlAndHeaders.url]: urlAndHeaders.headers,\n    })\n  }\n\n  const [result] = await fetchRegistry([urlAndHeaders.url], { useCache })\n\n  try {\n    return registrySchema.parse(result)\n  }\n  catch (error) {\n    throw new RegistryParseError(registryName, error)\n  }\n}\n\nexport async function getRegistryItems(\n  items: string[],\n  options?: {\n    config?: Partial<Config>\n    useCache?: boolean\n  },\n) {\n  const { config, useCache = false } = options || {}\n\n  clearRegistryContext()\n\n  return fetchRegistryItems(items, configWithDefaults(config), { useCache })\n}\n\nexport async function resolveRegistryItems(\n  items: string[],\n  options?: {\n    config?: Partial<Config>\n    useCache?: boolean\n  },\n) {\n  const { config, useCache = false } = options || {}\n\n  clearRegistryContext()\n  return resolveRegistryTree(items, configWithDefaults(config), { useCache })\n}\n\nexport async function getRegistriesConfig(\n  cwd: string,\n) {\n  const configResult = await getRawConfig(cwd)\n\n  if (!configResult) {\n    // Do not throw an error if the config is missing.\n    // We still have access to the built-in registries.\n    return {\n      registries: BUILTIN_REGISTRIES,\n    }\n  }\n\n  // Parse just the registries field from the config\n  const registriesConfig = z\n    .object({\n      registries: registryConfigSchema.optional(),\n    })\n    .safeParse(configResult)\n\n  if (!registriesConfig.success) {\n    throw new ConfigParseError(cwd, registriesConfig.error)\n  }\n\n  // Merge built-in registries with user registries\n  return {\n    registries: {\n      ...BUILTIN_REGISTRIES,\n      ...(registriesConfig.data.registries || {}),\n    },\n  }\n}\n\nexport async function getShadcnRegistryIndex() {\n  try {\n    const [result] = await fetchRegistry([\"index.json\"])\n\n    return registryIndexSchema.parse(result)\n  }\n  catch (error) {\n    logger.error(\"\\n\")\n    handleError(error)\n  }\n}\n\nexport async function getRegistryStyles() {\n  try {\n    const [result] = await fetchRegistry([\"styles/index.json\"])\n\n    return stylesSchema.parse(result)\n  }\n  catch (error) {\n    logger.error(\"\\n\")\n    handleError(error)\n    return []\n  }\n}\n\nexport async function getRegistryIcons() {\n  try {\n    const [result] = await fetchRegistry([\"icons/index.json\"])\n    return iconsSchema.parse(result)\n  }\n  catch (error) {\n    handleError(error)\n    return {}\n  }\n}\n\nexport async function getRegistryBaseColors() {\n  return BASE_COLORS\n}\n\nexport async function getRegistryBaseColor(baseColor: string) {\n  try {\n    const [result] = await fetchRegistry([`colors/${baseColor}.json`])\n\n    return registryBaseColorSchema.parse(result)\n  }\n  catch (error) {\n    handleError(error)\n  }\n}\n\n/**\n * @deprecated This function is deprecated and will be removed in a future version.\n */\nexport async function resolveTree(\n  index: z.infer<typeof registryIndexSchema>,\n  names: string[],\n) {\n  const tree: z.infer<typeof registryIndexSchema> = []\n\n  for (const name of names) {\n    const entry = index.find(entry => entry.name === name)\n\n    if (!entry) {\n      continue\n    }\n\n    tree.push(entry)\n\n    if (entry.registryDependencies) {\n      const dependencies = await resolveTree(index, entry.registryDependencies)\n      tree.push(...dependencies)\n    }\n  }\n\n  return tree.filter(\n    (component, index, self) =>\n      self.findIndex(c => c.name === component.name) === index,\n  )\n}\n\n/**\n * @deprecated This function is deprecated and will be removed in a future version.\n */\nexport async function fetchTree(\n  style: string,\n  tree: z.infer<typeof registryIndexSchema>,\n) {\n  try {\n    const paths = tree.map(item => `styles/${style}/${item.name}.json`)\n    const results = await fetchRegistry(paths)\n    return results.map(result => registryItemSchema.parse(result))\n  }\n  catch (error) {\n    handleError(error)\n    return []\n  }\n}\n\n/**\n * @deprecated This function is deprecated and will be removed in a future version.\n */\nexport async function getItemTargetPath(\n  config: Config,\n  item: Pick<z.infer<typeof registryItemSchema>, \"type\">,\n  override?: string,\n) {\n  if (override) {\n    return override\n  }\n\n  if (item.type === \"registry:ui\") {\n    return config.resolvedPaths.ui ?? config.resolvedPaths.components\n  }\n\n  const [parent, type] = item.type?.split(\":\") ?? []\n  if (!(parent in config.resolvedPaths)) {\n    return null\n  }\n\n  return path.join(\n    config.resolvedPaths[parent as keyof typeof config.resolvedPaths]!,\n    type,\n  )\n}\n\nexport async function getRegistriesIndex(options?: { useCache?: boolean }) {\n  options = {\n    useCache: true,\n    ...options,\n  }\n\n  const url = `${REGISTRY_URL}/registries.json`\n  const [data] = await fetchRegistry([url], {\n    useCache: options.useCache,\n  })\n\n  try {\n    return registriesIndexSchema.parse(data)\n  }\n  catch (error) {\n    if (error instanceof z.ZodError) {\n      throw new RegistriesIndexParseError(error)\n    }\n\n    throw error\n  }\n}\n","import type { searchResultItemSchema } from \"@/src/schema\"\nimport type { Config } from \"@/src/utils/get-config\"\nimport fuzzysort from \"fuzzysort\"\nimport { z } from \"zod\"\nimport { searchResultsSchema } from \"@/src/schema\"\n\nimport { getRegistry } from \"./api\"\n\nexport async function searchRegistries(\n  registries: string[],\n  options?: {\n    query?: string\n    limit?: number\n    offset?: number\n    config?: Partial<Config>\n    useCache?: boolean\n  },\n) {\n  const { query, limit, offset, config, useCache } = options || {}\n\n  let allItems: z.infer<typeof searchResultItemSchema>[] = []\n\n  for (const registry of registries) {\n    const registryData = await getRegistry(registry, { config, useCache })\n\n    const itemsWithRegistry = (registryData.items || []).map(item => ({\n      name: item.name,\n      type: item.type,\n      description: item.description,\n      registry,\n      addCommandArgument: buildRegistryItemNameFromRegistry(\n        item.name,\n        registry,\n      ),\n    }))\n\n    allItems = allItems.concat(itemsWithRegistry)\n  }\n\n  if (query) {\n    allItems = searchItems(allItems, {\n      query,\n      limit: allItems.length,\n      keys: [\"name\", \"description\"],\n    }) as z.infer<typeof searchResultItemSchema>[]\n  }\n\n  const paginationOffset = offset || 0\n  const paginationLimit = limit || allItems.length\n  const totalItems = allItems.length\n\n  const result: z.infer<typeof searchResultsSchema> = {\n    pagination: {\n      total: totalItems,\n      offset: paginationOffset,\n      limit: paginationLimit,\n      hasMore: paginationOffset + paginationLimit < totalItems,\n    },\n    items: allItems.slice(paginationOffset, paginationOffset + paginationLimit),\n  }\n\n  return searchResultsSchema.parse(result)\n}\n\nconst searchableItemSchema = z\n  .object({\n    name: z.string(),\n    type: z.string().optional(),\n    description: z.string().optional(),\n    registry: z.string().optional(),\n    addCommandArgument: z.string().optional(),\n  })\n  .passthrough()\n\ntype SearchableItem = z.infer<typeof searchableItemSchema>\n\nfunction searchItems<\n  T extends {\n    name: string\n    type?: string\n    description?: string\n    addCommandArgument?: string\n    [key: string]: any\n  } = SearchableItem,\n>(\n  items: T[],\n  options: {\n    query: string\n  } & Pick<Parameters<typeof fuzzysort.go>[2], \"keys\" | \"threshold\" | \"limit\">,\n) {\n  options = {\n    limit: 100,\n    threshold: -10000,\n    ...options,\n  }\n\n  const searchResults = fuzzysort.go(options.query, items, {\n    keys: options.keys,\n    threshold: options.threshold,\n    limit: options.limit,\n  })\n\n  const results = searchResults.map(result => result.obj)\n\n  return z.array(searchableItemSchema).parse(results)\n}\n\nfunction isUrl(string: string): boolean {\n  try {\n    // eslint-disable-next-line no-new\n    new URL(string)\n    return true\n  }\n  catch {\n    return false\n  }\n}\n\n// Builds the registry item name for the add command.\n// For namespaced registries, returns \"registry/item\".\n// For URL registries, replaces \"registry\" with the item name in the URL.\nexport function buildRegistryItemNameFromRegistry(\n  name: string,\n  registry: string,\n) {\n  // If registry is not a URL, return namespace format.\n  if (!isUrl(registry)) {\n    return `${registry}/${name}`\n  }\n\n  // Find where the host part ends in the original string.\n  const protocolEnd = registry.indexOf(\"://\") + 3\n  const hostEnd = registry.indexOf(\"/\", protocolEnd)\n\n  if (hostEnd === -1) {\n    // No path, check for query params.\n    const queryStart = registry.indexOf(\"?\", protocolEnd)\n    if (queryStart !== -1) {\n      // Has query params but no path.\n      const beforeQuery = registry.substring(0, queryStart)\n      const queryAndAfter = registry.substring(queryStart)\n      // Replace \"registry\" with itemName in query params only.\n      const updatedQuery = queryAndAfter.replace(/\\bregistry\\b/g, name)\n      return beforeQuery + updatedQuery\n    }\n    // No path or query, return as is.\n    return registry\n  }\n\n  // Split at host boundary.\n  const hostPart = registry.substring(0, hostEnd)\n  const pathAndQuery = registry.substring(hostEnd)\n\n  // Find all occurrences of \"registry\" in path and query.\n  // Replace only the last occurrence in the path segment.\n  const pathEnd\n    = pathAndQuery.includes(\"?\")\n      ? pathAndQuery.indexOf(\"?\")\n      : pathAndQuery.length\n  const pathOnly = pathAndQuery.substring(0, pathEnd)\n  const queryAndAfter = pathAndQuery.substring(pathEnd)\n\n  // Replace the last occurrence of \"registry\" in the path.\n  const lastIndex = pathOnly.lastIndexOf(\"registry\")\n  let updatedPath = pathOnly\n  if (lastIndex !== -1) {\n    updatedPath\n      = pathOnly.substring(0, lastIndex)\n        + name\n        + pathOnly.substring(lastIndex + \"registry\".length)\n  }\n\n  // Replace all occurrences of \"registry\" in query params.\n  const updatedQuery = queryAndAfter.replace(/\\bregistry\\b/g, name)\n\n  return hostPart + updatedPath + updatedQuery\n}\n"],"mappings":"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"}